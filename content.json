{"meta":{"title":"靖风行'S blog","subtitle":null,"description":"独立 自由 分享 感悟","author":"Yifoo","url":"http://blog.haohome.top"},"pages":[{"title":"","date":"2018-12-31T09:27:05.657Z","updated":"2017-11-25T13:14:06.000Z","comments":true,"path":"404.html","permalink":"http://blog.haohome.top/404.html","excerpt":"","text":""},{"title":"","date":"2019-01-28T06:40:48.393Z","updated":"2019-01-28T06:40:48.383Z","comments":true,"path":"readme.html","permalink":"http://blog.haohome.top/readme.html","excerpt":"","text":"博客目录20192019-01-28 JavaScript设计模式之迭代器模式 20182018-11-18 自己动手实现一个前端路由 2018-10-31 Vue项目总结 2018-10-22 跨域问题解决方案汇总 2018-10-21 你不知道的JavaScript之this 2018-10-20 你不知道的JavaScript之词法作用域与动态作用域 2018-10-18 你不知道的JavaScript之闭包 2018-10-10 iTerm终端设置代理 2018-10-07 JavaScript设计模式之适配器模式 2018-10-06 JavaScript设计模式之单例模式 2018-10-05 Mac下使用iTerm2让SSH记录远程服务器账号和密码 2018-09-30 图片上传与压缩 2018-09-28 Data类型的url简介 2018-09-26 浏览器兼容性 2018-08-28 JS判断当前文本输入状态 2018-08-28 hashchange事件 2018-07-11 垃圾回收机制与内存管理 2018-05-29 点击事件重复请求 2018-05-14 Vuex入门基础 2018-05-02 Node.js的web服务器路由重构 2018-04-14 模拟jQuery的ajax方法封装 2018-04-07 创建对象的Object.create与new 2018-04-07 跨域请求的jsonp处理 2018-03-29 浏览器缓存问题 2018-03-11 通俗易懂的原型与原型链 2018-03-10 原生JS实现瀑布流效果 2018-03-06 利用H5画随机色圆 2018-03-05 一道简单的setTimeout面试题 2018-03-01 闭包与模块 2018-02-25 flex弹性布局 2018-02-22 JS数组以及对象的深拷贝 2018-02-20 Viewport剖析 2018-02-20 前端网摘 2018-02-18 DOM通用事件绑定 2018-02-14 Vue的点赞效果 2018-02-12 Vue的CSS作用域问题 2018-01-28 Webpack入门 2018-01-21 Vue实现简单分页功能 2018-01-21 Node基础 2018-01-14 跨域资源共享CORS 2018-01-13 字符串操作slice、substr、sbustring比较 2018-01-07 Java中的接口 2018-01-01 Java中的抽象类 2018-01-01 Java中的类和对象 2018-01-01 FreeMaker 模板_数据模型 2018-01-01 Java中的多态 2018-01-01 Java中super关键字的使用 20172017-12-21 Java中的static的使用 2017-12-17 Backbone学习笔记 2017-12-11 Java中extends和implements的区别 2017-12-10 get和post推荐使用场景 2017-11-28 DOM渲染流程 2017-11-15 58同城面试总结 2017-11-11 ready与load比较 2017-11-09 flex-shrink 新弹性和模型属性 2017-02-23 关于递归计算 20162016-11-02 CSS样式—-文字长度溢出显示省略号 2016-10-12 CSS学习记录 2016-07-12 餐饮研发员的基本素质 2016-06-08 一年四季的时令蔬菜水果表 2016-05-12 浅谈餐饮的标准化 2016-04-19 苹果为什么会褐变"},{"title":"分类","date":"2016-11-17T07:59:25.000Z","updated":"2016-11-19T01:08:24.000Z","comments":true,"path":"categories/index.html","permalink":"http://blog.haohome.top/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2016-06-17T07:20:16.000Z","updated":"2017-11-15T14:06:30.000Z","comments":true,"path":"about/index.html","permalink":"http://blog.haohome.top/about/index.html","excerpt":"","text":"我像风一样自由在自然中游荡飘过原野吹过丛林越过海洋无拘无束"},{"title":"标签","date":"2016-11-19T00:44:13.000Z","updated":"2016-11-19T01:12:00.000Z","comments":true,"path":"tags/index.html","permalink":"http://blog.haohome.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JavaScript设计模式之迭代器模式","slug":"JavaScript/JavaScript设计模式之迭代器模式","date":"2019-01-26T16:00:00.000Z","updated":"2019-01-28T06:30:25.458Z","comments":true,"path":"2019/01/27/JavaScript/JavaScript设计模式之迭代器模式/","link":"","permalink":"http://blog.haohome.top/2019/01/27/JavaScript/JavaScript设计模式之迭代器模式/","excerpt":"迭代器模式是指在不暴露对象内部结构的同时,可以顺序的访问聚合对象的内部元素 迭代器主要解决不同的方式来遍历整个整合对象 业务场景: 根据不同浏览器获取相应的上传组件对象 1234567891011var getUploadObj = function()&#123; try &#123; return new ActiveXObject(...) &#125;catch(e)&#123; if(supportFlash())&#123; return flashUpload &#125;else&#123; return h5Upload &#125; &#125;&#125; 如果浏览器支持上传控件,会优先选用上传控件,如果没有则判断是否支持flash,如果连flash也没有安装,则采用h5原生的上传方式","text":"迭代器模式是指在不暴露对象内部结构的同时,可以顺序的访问聚合对象的内部元素 迭代器主要解决不同的方式来遍历整个整合对象 业务场景: 根据不同浏览器获取相应的上传组件对象 1234567891011var getUploadObj = function()&#123; try &#123; return new ActiveXObject(...) &#125;catch(e)&#123; if(supportFlash())&#123; return flashUpload &#125;else&#123; return h5Upload &#125; &#125;&#125; 如果浏览器支持上传控件,会优先选用上传控件,如果没有则判断是否支持flash,如果连flash也没有安装,则采用h5原生的上传方式 为了得到一个upload对象,程序使用了try…catch和if语句,造成阅读困难,同时违反开放封闭原则 如果每一种获取upload对象方法封装成独立的函数里,再使用迭代器遍历这些函数组成的集合,从而获取到可用的upload对象 1234567891011121314151617var getActiveObj = function()&#123; try&#123; return new ActiveXObject(...) &#125;catch(e)&#123; return false &#125;&#125; var getFlashObj = function()&#123; if(supportFlash())&#123; return flashUpload &#125;else&#123; return false &#125; &#125; var getH5Upload = function()&#123; return h5Uplaod &#125; 迭代器只需要做以下工作: 提供一个可以遍历集合的方法,使得按照一定的优先级顺序遍历迭代 如果正在被迭代的函数返回一个对象,则表示找到了正确的upload对象,如果返回false,则迭代器继续工作 123456789var iteratorUploadObj = function()&#123; for ( var i = 0, fn; fn = arguments[ i++ ]; )&#123; var uploadObj = fn(); if ( uploadObj !== false )&#123; return uploadObj; &#125; &#125;&#125;;var uploadObj = iteratorUploadObj(getActiveObj,getFlashObj,getH5Upload) 这样的迭代模式使得获取不同上传对象的方法独立,很方便后续的维护,比如添加了一个上传控件方法: 12345678var newUploadPlugin = function()&#123; if(supportPlugin())&#123; return uploadPluginObj &#125;else&#123; return false &#125;&#125;var uploadObj = iteratorUploadObj(newUploadPlugin,getActiveObj,getFlashObj,getH5Upload)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blog.haohome.top/tags/JS/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.haohome.top/tags/设计模式/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"自己动手实现一个前端路由","slug":"JavaScript/自己动手实现一个前端路由","date":"2018-11-17T16:00:00.000Z","updated":"2018-11-19T13:08:25.000Z","comments":true,"path":"2018/11/18/JavaScript/自己动手实现一个前端路由/","link":"","permalink":"http://blog.haohome.top/2018/11/18/JavaScript/自己动手实现一个前端路由/","excerpt":"单页面应用利用了JavaScript动态变换网页内容,避免了页面重载;路由则提供了浏览器地址变化,网页内容也跟随变化,两者结合起来则为我们提供了体验良好的单页面web应用 前端路由实现方式路由需要实现三个功能: ​ ①浏览器地址变化,切换页面; ​ ②点击浏览器【后退】、【前进】按钮，网页内容跟随变化； ​ ③刷新浏览器，网页加载当前路由对应内容 在单页面web网页中,单纯的浏览器地址改变,网页不会重载,如单纯的hash网址改变网页不会变化,因此我们的路由主要是通过监听事件,并利用js实现动态改变网页内容,有两种实现方式: hash路由: 监听浏览器地址hash值变化,执行相应的js切换网页history路由: 利用history API实现url地址改变,网页内容改变","text":"单页面应用利用了JavaScript动态变换网页内容,避免了页面重载;路由则提供了浏览器地址变化,网页内容也跟随变化,两者结合起来则为我们提供了体验良好的单页面web应用 前端路由实现方式路由需要实现三个功能: ​ ①浏览器地址变化,切换页面; ​ ②点击浏览器【后退】、【前进】按钮，网页内容跟随变化； ​ ③刷新浏览器，网页加载当前路由对应内容 在单页面web网页中,单纯的浏览器地址改变,网页不会重载,如单纯的hash网址改变网页不会变化,因此我们的路由主要是通过监听事件,并利用js实现动态改变网页内容,有两种实现方式: hash路由: 监听浏览器地址hash值变化,执行相应的js切换网页history路由: 利用history API实现url地址改变,网页内容改变 hash路由首先定义一个Router类 12345678910111213141516171819class Router &#123; constructor(obj) &#123; // 路由模式 this.mode = obj.mode // 配置路由 this.routes = &#123; '/index' : 'views/index/index', '/index/detail' : 'views/index/detail/detail', '/index/detail/more' : 'views/index/detail/more/more', '/subscribe' : 'views/subscribe/subscribe', '/proxy' : 'views/proxy/proxy', '/state' : 'views/state/stateDemo', '/state/sub' : 'views/state/components/subState', '/dom' : 'views/visualDom/visualDom', '/error' : 'views/error/error' &#125; this.init() &#125;&#125; 路由初始化init()时监听load,hashchange两个事件: 12window.addEventListener('load', this.hashRefresh.bind(this), false);window.addEventListener('hashchange', this.hashRefresh.bind(this), false); 浏览器地址hash值变化直接通过a标签链接实现 123456789101112&lt;nav id=\"nav\" class=\"nav-tab\"&gt; &lt;ul class='tab'&gt; &lt;li&gt;&lt;a class='nav-item' href=\"#/index\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class='nav-item' href=\"#/subscribe\"&gt;观察者&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class='nav-item' href=\"#/proxy\"&gt;代理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class='nav-item' href=\"#/state\"&gt;状态管理&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a class='nav-item' href=\"#/dom\"&gt;虚拟DOM&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;div id=\"container\" class='container'&gt; &lt;div id=\"main\" class='main'&gt;&lt;/div&gt;&lt;/div&gt; hash值变化后,回调方法: 12345678910111213141516171819/** * hash路由刷新执行 */hashRefresh() &#123; // 获取当前路径,去掉查询字符串,默认'/index' var currentURL = location.hash.slice(1).split('?')[0] || '/index'; this.name = this.routes[this.currentURL] this.controller(this.name)&#125;/** * 组件控制器 * @param &#123;string&#125; name */controller(name) &#123; // 获得相应组件 var Component = require('../' + name).default; // 判断是否已经配置挂载元素,默认为$('#main') var controller = new Component($('#main'))&#125; 考虑到存在多级页面嵌套路由的存在,需要对嵌套路由进行处理: 直接子页面路由时,按父路由到子路由的顺序加载页面 父页面已经加载,再加载子页面时,父页面保留,只加载子页面 改造后的路由刷新方法为: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950hashRefresh() &#123; // 获取当前路径,去掉查询字符串,默认'/index' var currentURL = location.hash.slice(1).split('?')[0] || '/index'; // 多级链接拆分为数组,遍历依次加载 this.currentURLlist = currentURL.slice(1).split('/') this.url = \"\" this.currentURLlist.forEach((item, index) =&gt; &#123; // 导航菜单激活显示 if (index === 0) &#123; this.navActive(item) &#125; this.url += \"/\" + item this.name = this.routes[this.url] // 404页面处理 if (!this.name) &#123; location.href = '#/error' return false &#125; // 对于嵌套路由的处理 if (this.oldURL &amp;&amp; this.oldURL[0]==this.currentURLlist[0]) &#123; this.handleSubRouter(item,index) &#125; else &#123; this.controller(this.name) &#125; &#125;); // 记录链接数组,后续处理子级组件 this.oldURL = JSON.parse(JSON.stringify(this.currentURLlist))&#125;/** * 处理嵌套路由 * @param &#123;string&#125; item 链接list中当前项 * @param &#123;number&#125; index 链接list中当前索引 */handleSubRouter(item,index)&#123; // 新路由是旧路由的子级 if (this.oldURL.length &lt; this.currentURLlist.length) &#123; // 相同路由部分不重新加载 if (item !== this.oldURL[index]) &#123; this.controller(this.name) &#125; &#125; // 新路由是旧路由的父级 if (this.oldURL.length &gt; this.currentURLlist.length) &#123; var len = Math.min(this.oldURL.length, this.currentURLlist.length) // 只重新加载最后一个路由 if (index == len - 1) &#123; this.controller(this.name) &#125; &#125;&#125; 这样,一个hash路由组件就实现了 使用时,只需new一个Router实例即可:new Router({mode:&#39;hash&#39;}) history 路由window.history属性指向 History 对象,是浏览器的一个属性,表示当前窗口的浏览历史,History 对象保存了当前窗口访问过的所有页面地址。更多了解History对象,可参考阮一峰老师的介绍: History 对象 webpack开发环境下,需要在devServer对象添加以下配置: 123456&gt; historyApiFallback: &#123;&gt; rewrites: [&gt; &#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') &#125;,&gt; ],&gt; &#125;&gt; history路由主要是通过history.pushState()方法向浏览记录中添加一条历史记录,并同时触发js回调加载页面 当【前进】、【后退】时，会触发history.popstate 事件,加载history.state中存放的路径 history路由实现与hash路由的步骤类似,由于需要配置路由模式切换,页面中所有的a链接都采用了hash类型链接,history路由初始化时,需要拦截a标签的默认跳转: 1234567891011121314151617181920212223242526 /** * history模式劫持 a链接 */ bindLink() &#123; $('#nav').on('click', 'a.nav-item', this.handleLink.bind(this)) &#125;/** * history 处理a链接 * @param e 当前对象Event */ handleLink(e) &#123; e.preventDefault(); // 获取元素路径属性 let href = $(e.target).attr('href') // 对非路由链接直接跳转 if (href.slice(0, 1) !== '#') &#123; window.location.href = href &#125; else &#123; let path = href.slice(1) history.pushState(&#123; path: path &#125;, null, path) // 加载相应页面 this.loadView(path.split('?')[0]) &#125; &#125; history路由初始化需要绑定load、popstate事件 123this.bindLink()window.addEventListener('load', this.loadView.bind(this, location.pathname));window.addEventListener('popstate', this.historyRefresh.bind(this)); 浏览是【前进】或【后退】时,触发popstate事件,执行回调函数 1234567891011/** * history模式刷新页面 * @param e 当前对象Event */historyRefresh(e) &#123; const state = e.state || &#123;&#125; const path = state.path.split('?')[0] || null if (path) &#123; this.loadView(path) &#125;&#125; history路由模式首次加载页面时,可以默认一个页面,这时可以用history.replaceState方法 1234if (this.mode === 'history' &amp;&amp; currentURL === '/') &#123; history.replaceState(&#123;path: '/'&#125;, null, '/') currentURL = '/index'&#125; 对于404页面的处理,也类似 12history.replaceState(&#123;path: '/error'&#125;, null, '/error')this.loadView('/error') 点击预览 更多源码请访问Github","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://blog.haohome.top/tags/jQuery/"},{"name":"router","slug":"router","permalink":"http://blog.haohome.top/tags/router/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"Vue项目总结","slug":"Program/Vue项目总结","date":"2018-10-30T16:00:00.000Z","updated":"2019-01-28T06:37:03.256Z","comments":true,"path":"2018/10/31/Program/Vue项目总结/","link":"","permalink":"http://blog.haohome.top/2018/10/31/Program/Vue项目总结/","excerpt":"1. 前言最近做了一个内嵌在APP的H5项目,起初是准备自己选择vue框架和UI库搭建项目框架,后来发现已经有项目组采用了一个muse-ui库.为了APP的页面整体统一性,我只好clone了小伙伴的项目,在其基础上继续开发. 项目开发过程中遇到了不少坑,这个迭代开发结束就来逐步总结下.","text":"1. 前言最近做了一个内嵌在APP的H5项目,起初是准备自己选择vue框架和UI库搭建项目框架,后来发现已经有项目组采用了一个muse-ui库.为了APP的页面整体统一性,我只好clone了小伙伴的项目,在其基础上继续开发. 项目开发过程中遇到了不少坑,这个迭代开发结束就来逐步总结下. 闲话不多说,开始正题: 2. 关于muse-ui这个框架采用material风格,对vue的支持就很友好,图标也是Google官方推荐的Material Icons字体包,用起来也很方便。官方有详细的安装介绍,import后采用Vue.use()即可: 1234import Vue from 'vue'import MuseUI from 'muse-ui'import 'muse-ui/dist/muse-ui.css'Vue.use(MuseUI) 我们的项目采用的是muse2.1版本,官方现在已经是3.0版本的了,2.1版本的API文档写的不是详细,所以当遇到坑时就头疼了. 3. 基于muse-ui封装表单组件由于我们项目此次主要是表单,里面有大量的input、textarea、select等表单的应用场景,我们选择了对muse-ui表单组件进行二次封装,以利于ui组件适用于本项目移动端的样式,同时表单组件可随处复用。 3.1 组件数据双向绑定v-model数据双向绑定是vue中比较实用的一个功能,如: 12345678Vue.component('formInput', &#123; data:&#123; return &#123; val:\"\" &#125; &#125;, template: `&lt;input v-model='val'&gt;`&#125;) 而在父组件中,如何去实现实时获取子组件formInput的value呢? 12345678Vue.component('parent',&#123; data:&#123; return&#123; inputVal:\"\" &#125; &#125;, template: `&lt;form-input v-model=\"inputVal\"&gt;&lt;/form-input&gt;`&#125;) vue的父子组件传递有一个口诀:props down,events up即父组件通过props向子组件传值,子组件通过evens向父组件传值,另外在官方文档中有这样的介绍: 12345&lt;input v-model=&quot;searchText&quot;&gt;&lt;!-- 等价于 --&gt;&lt;input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event.target.value&quot;&gt; 当用在组件上时: 123456&lt;custom-input v-bind:value=&quot;searchText&quot; v-on:input=&quot;searchText = $event&quot;&gt;&lt;/custom-input&gt;即&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt; 为了能正常传值,组件内的 &lt;input&gt; 必须： 将其 value 特性绑定到一个名叫 value 的 prop 上 在其 input 事件被触发时，将新的值通过自定义的 input 事件抛出 这段相当于让自定义组件通过input事件触发父组件的自定义事件,并传值给父组件 123456789Vue.component('custom-input', &#123; props: ['value'], template: ` &lt;input v-bind:value=\"value\" v-on:input=\"$emit('input', $event.target.value)\" &gt; `&#125;) 这样就能达到我们想要的目的了. 在单选框和复选框这类可能会将value用作不同的特性,vue提供了另一种方式: 1234567891011121314151617181920Vue.component('base-checkbox', &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: Boolean &#125;, template: ` &lt;input type=\"checkbox\" v-bind:checked=\"checked\" v-on:change=\"$emit('change', $event.target.checked)\" &gt; `&#125;)// 组件上&lt;base-checkbox v-model=\"lovingVue\"&gt;&lt;/base-checkbox&gt;// lovingVue 的值将会传入这个名为 checked 的 prop// ! 需要在组件的 props 选项里声明 checked 这个 prop。 3.2 列表遍历v-for删除指定元素有时数组列表渲染我们比较喜欢采用数组本身的下标索引作为v-for绑定的key值如: 在做图片上传的时候,需要添加上传进度和删除图片,彼此间互不干扰,这就需要每个组件都需要具备独立的功能: 图片预览 图片自动压缩 图片上传 上传进度动态展示 删除图片 上传失败错误图标 点击错误图标重传 我写了两个组件,一个是图片single组件,一个是图片list组件,在实际运行的时候发现,删除某一张图片会自动删除最后一张图片,通过console.log控制台打印索引index,删除的索引是正确的,百思不得其解!最后百度才发现问题出在了循环v-for的:key上了 为方便理解,先举个例子: single图片组件具备了上述功能,选择一个图片后在list组件及时push一个图片的对象this.arr.push(item),这样页面就能通过v-for动态渲染,但使用后发现直接删除arr某个元素就只会删除集合最后一个元素. 这是由于列表的生成是通过绑定的arr数组来生成的，当arr删除掉一项时，列表的dom对象自然也会减少一项。但是由于v-for循环的是子组件，子组件内部显示数据并未绑定arr数组里的属性，因此子组件的显示数据并未按新数组重新渲染，体现出来的结果就是最后一个元素被删掉了 针对arr添加唯一性的索引就能解决这个问题,this.arr.push({ id: this.id, data: item });,将:key绑定到id 由于v-for循环的是子组件，子组件内部显示数据并未绑定fileList数组里的属性,子组件的显示数据并未按新数组重新渲染,体现出来的结果就是最后一个元素被删掉了。 4. 移动端拍照图片压缩上传\u0016移动端图片上传存在两个问题: 图片压缩 当前手机拍出来的照片像素高、尺寸大，而且使用 base64 编码的照片会比原照片大，用 canvas 来渲染这照片的速度会相对比较慢，那么上传的时候进行压缩就非常有必要的 图片压缩可以有两个阶段可以控制： 控制canvas画布大小 canvas转blob对象或base64,控制质量比例 Tips: 1.1 canvas转blob对象:canvas.toBlob(callback, type, radio) callback: 回调函数，可获得一个单独的Blob对象参数 type: 指定图片格式，默认格式为image/png radio: 当请求图片格式为image/jpeg或者image/webp时用来指定图片展示质量 Blob 对象相当于一个容器，可以用于存放二进制数据。它有两个属性，size 属性表示字节长度，type 属性表示 MIME 类型。 12345678910canvas.toBlob(function(blob) &#123; var url = URL.createObjectURL(blob); var newImg = new Image(); newImg.onload = function() &#123; URL.revokeObjectURL(url) // URL.revokeObjectURL():释放一个之前通过调用 URL.createObjectURL() 创建的已经存在的 URL 对象。当你结束使用某个 URL 对象时，应该通过调用这个方法来让浏览器知道不再需要保持这个文件的引用,避免消耗资源 &#125;; newImg.src=url;&#125;;//生成JPEG格式的图片canvas.toBlob(function(blob)&#123;...&#125;, \"image/jpeg\", 0.95); // JPEG at 95% quality canvas.toBlob方法在低版本的ios存在兼容性问题,需要添加一下代码实现兼容: 12345678910111213if (!HTMLCanvasElement.prototype.toBlob) &#123; Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', &#123; value: function (callback, type, quality) &#123; var binStr = atob( this.toDataURL(type, quality).split(',')[1] ),len = binStr.length,arr = new Uint8Array(len); for (var i=0; i&lt;len; i++ ) &#123; arr[i] = binStr.charCodeAt(i); &#125; callback( new Blob( [arr], &#123;type: type || 'image/png'&#125; ) ); &#125; &#125;);&#125; 1.2 canvas转base64:直接调用方法canvas.toDataURL(type, radio) type: 图片格式，默认为 image/png radio: 当请求图片格式为image/jpeg或者image/webp时用来指定图片展示质量 与转blob对象不同的是,canvas.toDataURL直接返回base64 的图片 12var newImg = new Image();newImg.src=canvas.toDataURL(\"image/png\",0.8); 上传进度展示 文件上传需要用到XMLHttpRequest:progress方法,在axios的api中提供了现成的onUploadProgress方法 12345678910this.$axios(&#123; url:'/upload' method: \"post\", data: data, onUploadProgress: function(event) &#123; if (event.lengthComputable) &#123; self.radio = (event.loaded / event.total) * 100; &#125; &#125;&#125;) 当上传存在跨域的时候,浏览器在跨域请求前会默认发个options请求来验证是否跨域,这是后端服务器需要处理options请求 OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。 | 请求 | OPTIONS*HTTP/1.1 || —- | ————————————————- || Host|www.zhongguo.com/upload || 响应 | HTTP/1.1 200 OK || Allow | GET, POST, HEAD, OPTIONS(返回服务器支持的方法) | 如果后端未对OPTIONS请求做处理,前端文件post上传文件会失败的 当后端对OPTIONS请求做出响应200时,前端才会继续发送post请求,这就是我们在调试时看到文件上传时会默认发OPTIONS和post两个请求的原因 拍照图片旋转 在手机上通过H5网页input标签拍照上传图片，有一些手机会出现图片旋转了90°的问题,这些手机竖着拍的时候才会出现这种问题，横拍出来的照片就正常显示。因此，可以通过获取手机拍照角度来对照片进行旋转，从而解决这个问题。 Orientation:通过这个参数可以识别图片的拍摄角度,手机拍出来的图片会带有这个参数 | 旋转角度 | 参数值 || :——-: | :—-: || 0° | 1 || 顺时针90° | 6 || 逆时针90° | 8 || 180° | 3 | 想要获取 Orientation 参数，可以通过 exif.js 库来操作 1234567// vue项目可直接安装npm i exif-js -D//在图片组件中直接引入import Exif from 'exif-js'Exif.getData(file, function() &#123; var Orientation = Exif.getTag(this, 'Orientation');&#125;); 在对图片进行canvas绘图时,就可以针对Orientation参数做判断处理: 12345678910111213141516171819202122232425if (Orientation &amp;&amp; Orientation != 1) &#123; switch (Orientation) &#123; case 6: // 旋转90度 canvas.width = imgHeight; canvas.height = imgWidth; ctx.rotate(Math.PI / 2); // (0,-imgHeight) 从旋转原理图那里获得的起始点 ctx.drawImage(img, 0, -imgHeight, imgWidth, imgHeight); break; case 3: // 旋转180度 ctx.rotate(Math.PI); ctx.drawImage(img, -imgWidth, -imgHeight, imgWidth, imgHeight); break; case 8: // 旋转-90度 canvas.width = imgHeight; canvas.height = imgWidth; ctx.rotate(3 * Math.PI / 2); ctx.drawImage(img, -imgWidth, 0, imgWidth, imgHeight); break; &#125;&#125;else&#123; canvas.width = imgWidth; canvas.height = imgHeight; ctx.drawImage(img, 0, 0, imgWidth, imgHeight)&#125; Demo: 图片上传与压缩 5. -webkit-overflow-scrolling的坑项目中有一个获取数据后纯展示的页面,在ios平台上滑动不流畅,经过查询才了解到在ios的safari浏览器和app内核浏览器中，当一个h5页面内容超出屏幕高度，我们手指去滑动屏幕的时候，只要手势一离开屏幕，滚动立刻结束,按照教程我按下面设置了: 123*&#123; -webkit-overflow-scrolling: touch;&#125; 结果在app中出现了fixed 定位元素失效","categories":[{"name":"Framework","slug":"Framework","permalink":"http://blog.haohome.top/categories/Framework/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blog.haohome.top/tags/JS/"},{"name":"vue","slug":"vue","permalink":"http://blog.haohome.top/tags/vue/"},{"name":"项目总结","slug":"项目总结","permalink":"http://blog.haohome.top/tags/项目总结/"}],"keywords":[{"name":"Framework","slug":"Framework","permalink":"http://blog.haohome.top/categories/Framework/"}]},{"title":"跨域问题解决方案汇总","slug":"Interview/跨域问题解决方案汇总","date":"2018-10-21T16:00:00.000Z","updated":"2018-10-22T01:17:24.000Z","comments":true,"path":"2018/10/22/Interview/跨域问题解决方案汇总/","link":"","permalink":"http://blog.haohome.top/2018/10/22/Interview/跨域问题解决方案汇总/","excerpt":"同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。但是有时候跨域请求资源是合理的需求，本文尝试从多篇文章中汇总至今存在的所有跨域请求解决方案。 跨域请求首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。而有关跨域请求受到限制的原因可以参考如下 MDN 文档片段： 跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如 Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。","text":"同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。但是有时候跨域请求资源是合理的需求，本文尝试从多篇文章中汇总至今存在的所有跨域请求解决方案。 跨域请求首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。而有关跨域请求受到限制的原因可以参考如下 MDN 文档片段： 跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如 Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。 解决方法汇总以下我们由简及深介绍各种存在的跨域请求解决方案，包括 document.domain, location.hash, window.name, window.postMessage, JSONP, WebSocket, CORS。 document.domaindocument.domain 的作用是用来获取/设置当前文档的原始域部分，例如： 1234// 对于文档 www.example.xxx/good.htmldocument.domain=\"www.example.xxx\"// 对于URI http://developer.mozilla.org/en/docs/DOM document.domain=\"developer.mozilla.org\" 如果当前文档的域无法识别，那么 domain 属性会返回 null。 在根域范围内，Mozilla允许你把domain属性的值设置为它的上一级域。例如，在 developer.mozilla.org 域内，可以把domain设置为 “mozilla.org” 但不能设置为 “mozilla.com” 或者”org”。 因此，若两个源所用协议、端口一致，主域相同而二级域名不同的话，可以借鉴该方法解决跨域请求。 比如若我们在 http://a.github.io 页面执行以下语句： 1document.domain = \"github.io\" 那么之后页面对 github.io 发起请求时页面则会成功通过对 github.io 的同源检测。比较直接的一个操作是，当我们在 a.github.io 页面中利用 iframe 去加载 github.io 时，通过如上的赋值后，我们可以在 a.github.io 页面中去操作 iframe 里的内容。 我们同时考虑另一种情况：存在两个子域名 a.github.io 以及 b.github.io， 其中前者域名下网页 a.html 通过 iframe 引入了后者域名下的 b.html，此时在 a.html 中是无法直接操作 b.html 的内容的。 同样利用 document.domain，我们在两个页面中均加入 1document.domain='github.io' 这样在以上的 a.html 中就可以操作通过 iframe 引入的 b.html 了。 document.domain 的优点在于解决了主语相同的跨域请求，但是其缺点也是很明显的：比如一个站点受到攻击后，另一个站点会因此引起安全漏洞；若一个页面中引入多个 iframe，想要操作所有的 iframe 则需要设置相同的 domain。 location.hashlocation.hash 是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）。例如： 12// 对于页面 http://example.com:1234/test.htm#part2location.hash = \"#part2\" 同时，由于我们知道改变 hash 并不会导致页面刷新，所以可以利用 hash 在不同源间传递数据。 假设 github.io 域名下 a.html 和 shaonian.eu 域名下 b.html 存在跨域请求，那么利用 location.hash 的一个解决方案如下： a.html 页面中创建一个隐藏的 iframe， src 指向 b.html，其中 src 中可以通过 hash 传入参数给 b.html b.html 页面在处理完传入的 hash 后通过修改 a.html 的 hash 值达到将数据传送给 a.html 的目的 a.html 页面添加一个定时器，每隔一定时间判断自身的 location.hash 是否变化，以此响应处理 以上步骤中需要注意第二点：如何在 iframe 页面中修改 父亲页面的 hash 值。由于在 IE 和 Chrome 下，两个不同域的页面是不允许 parent.location.hash 这样赋值的，所以对于这种情况，我们需要在父亲页面域名下添加另一个页面来实现跨域请求，具体如下： 假设 a.html 中 iframe 引入了 b.html, 数据需要在这两个页面之间传递，且 c.html 是一个与 a.html 同源的页面 a.html 通过 iframe 将数据通过 hash 传给 b.html b.html 通过 iframe 将数据通过 hash 传给 c.html c.html 通过 parent.parent.location.hash 设置 a.html 的 hash 达到传递数据的目的 location.bash 方法的优点在于可以解决域名完全不同的跨域请求，并且可以实现双向通讯；而缺点则包括以下几点： 利用这种方法传递的数据量受到 url 大小的限制，传递数据类型有限 由于数据直接暴露在 url 中则存在安全问题 若浏览器不支持 onhashchange 事件，则需要通过轮训来获知 url 的变化 有些浏览器会在 hash 变化时产生历史记录，因此可能影响用户体验 window.name该属性用于获取/设置窗口的名称。其特征在于：一个窗口的生命周期内，窗口载入的所有页面共享该值，且都具有对该属性的读写权限。这意味着如果不修改该值，那么在不同页面加载之后该值也不会变，且其支持长达 2MB 的存储量。 利用该特性我们可以将跨域请求用如下步骤解决： 在 a.github.io/a.html 中创建 iframe 指向 b.github.io/b.html (页面会将自身的 window.name 附在 iframe 上) 给 a.github.io/a.html 添加监听 iframe 的 onload 事件，在该事件中将 iframe 的 src 设置为本地域的代理文件（代理文件和a.html处于同一域下，可以相互通信），同时可以传出 iframe 的 name 值 获取数据后销毁 iframe，释放内存，同时也保证了安全 window.name 的优势在于巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 window.postMessageHTML5 为了解决这个问题，引入了一个全新的 API：跨文档通信 API（Cross-document messaging）。这个 API 为 window 对象新增了一个 window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。 API 的详细使用方法请见 MDN。 JSONPJSONP, 全称 JSON with Padding，是使用 AJAX 实现的请求不同源的跨域。其基本原理：网页通过添加一个 &lt;script&gt; 元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。 以下为一个例子，由于 test.js 返回的内容直接作为代码运行，所以只要 a.html 中定义了 callback 函数, 它就会立即被调用。 123456789101112// 当前页面 a.com/a.html&lt;script type=\"text/javascript\"&gt;//回调函数function callback(data) &#123; alert(data.message);&#125;&lt;/script&gt;&lt;script type=\"text/javascript\" src=\"http://b.com/test.js\"&gt;&lt;/script&gt;// test.js// 调用callback函数，并以json数据形式作为阐述传递，完成回调callback(&#123;message:\"success\"&#125;); 为了保证 script 的灵活，我们可以通过 JavaScript 动态创建 script 标签，并通过 HTTP 参数向服务器传入回调函数名，案例如下所示： 1234567891011121314151617181920&lt;script type=\"text/javascript\"&gt; // 添加&lt;script&gt;标签的方法 function addScriptTag(src)&#123; var script = document.createElement('script'); script.setAttribute(\"type\",\"text/javascript\"); script.src = src; document.body.appendChild(script); &#125; window.onload = function()&#123; // 搜索apple，将自定义的回调函数名result传入callback参数中 addScriptTag(\"http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=apple&amp;callback=result\"); &#125; // 自定义的回调函数result function result(data) &#123; // 我们就简单的获取apple搜索结果的第一条记录中url数据 alert(data.responseData.results[0].unescapedUrl); &#125;&lt;/script&gt; jQuery 有相应的 JSONP 的实现方法，见 API。 JSONP的优点在于简单适用，老式浏览器全部支持，服务器改造小。不需要XMLHttpRequest或ActiveX的支持；但缺点是只支持 GET 请求。 WebSocketWebSocket 协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 CORS CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。其需要服务端和客户端同时支持。 跨域资源共享标准（ cross-origin sharing standard ）允许在下列场景中使用跨域 HTTP 请求： 由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求 Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用 WebGL 贴图 使用 drawImage 将 Images/video 画面绘制到 canvas 样式表（使用 CSSOM） Scripts (未处理的异常) CORS 存在以下三种主要场景，分别是简单请求，预检请求和附带身份凭证的请求。 简单请求：若只使用 GET, HEAD 或者 POST 请求，且除 CORS 安全的首部字段集合外，无人为设置该集合之外的其他首部字段，同时 Content-Type 值属于下列之一，那么该请求则可以被视为简单请求： 123application/x-www-form-urlencodedmultipart/form-datatext/plain 此情况下，若服务端返回的 Access-Control-Allow-Origin: * ，则表明该资源可以被任意外域访问。若要指定仅允许来自某些域的访问，需要将 * 设定为该域，例如： 1Access-Control-Allow-Origin: http://foo.example 预检请求：与前述简单请求不同，该要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。当请求满足以下三个条件任意之一时，即应首先发送预检请求： 使用了 PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH 中任一的 HTTP 方法 人为设置了对 CORS 安全的首部字段集合之外的其他首部字段 Content-Type 的值不属于下列之一 123application/x-www-form-urlencodedmultipart/form-datatext/plain 预检请求完成之后（通过 OPTIONS 方法实现），才发送实际请求。一个示范 HTTP 请求如下所示： 1234567891011121314var invocation = new XMLHttpRequest();var url = 'http://bar.other/resources/post-here/';var body = '&lt;?xml version=\"1.0\"?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;'; function callOtherDomain()&#123; if(invocation) &#123; invocation.open('POST', url, true); invocation.setRequestHeader('X-PINGOTHER', 'pingpong'); invocation.setRequestHeader('Content-Type', 'application/xml'); invocation.onreadystatechange = handler; invocation.send(body); &#125;&#125; 附带身份凭证的请求：这种方式的特点在于能够在跨域请求时向服务器发送凭证请求，例如 Cookies (withCredentials 标志设置为 true)。 一般而言，对于跨域 XMLHttpRequest 或 Fetch 请求，浏览器不会发送身份凭证信息。如果要发送凭证信息，需要设置 XMLHttpRequest 的某个特殊标志位。但是需要注意的是，如果服务器端的响应中未携带 Access-Control-Allow-Credentials: true，浏览器将不会把响应内容返回给请求的发送者。 附带身份凭证的请求与通配符 对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为“*”。 这是因为请求的首部中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为“*”，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 http://foo.example，则请求将成功执行。 另外，响应首部中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。 MDN 引例如下： 1234567891011var invocation = new XMLHttpRequest();var url = 'http://bar.other/resources/credentialed-content/'; function callOtherDomain()&#123; if(invocation) &#123; invocation.open('GET', url, true); invocation.withCredentials = true; invocation.onreadystatechange = handler; invocation.send(); &#125;&#125; 其实由上我们知道，CORS 的优点也非常明显：CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案。 以上就是所有的跨域请求解决方案，根据实际生产环境，总有一款适合你。 参考 https://github.com/wengjq/Blog/issues/2 https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS http://www.cnblogs.com/zichi/p/4620656.html 参考 https://sites.google.com/site/amitsciscozone/home/security/ssl-connection-setup http://robertheaton.com/2014/03/27/how-does-https-actually-work/ http://www.cnblogs.com/lixiansen/p/5618541.html http://harttle.com/2016/01/22/doctype.html http://jerryzou.com/posts/cookie-and-web-storage/ https://www.zhihu.com/question/20653055/answer/17786008 https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes http://blog.csdn.net/NJUPT_T/article/details/50700209 http://web.jobbole.com/84826/ http://web.jobbole.com/85340/ 文章参考了以上资源，同时参照 https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers 的部分问题列表重新归纳了详细问题答案。","categories":[{"name":"Interview","slug":"Interview","permalink":"http://blog.haohome.top/categories/Interview/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blog.haohome.top/tags/JS/"}],"keywords":[{"name":"Interview","slug":"Interview","permalink":"http://blog.haohome.top/categories/Interview/"}]},{"title":"你不知道的JavaScript之this","slug":"JavaScript/你不知道的JavaScript之this","date":"2018-10-20T16:00:00.000Z","updated":"2018-10-21T15:42:41.000Z","comments":true,"path":"2018/10/21/JavaScript/你不知道的JavaScript之this/","link":"","permalink":"http://blog.haohome.top/2018/10/21/JavaScript/你不知道的JavaScript之this/","excerpt":"初识this1234567891011121314151617181920function identify() &#123; return this.name.toUpperCase();&#125;function speak() &#123; var greeting = \"Hello, I'm \" + identify.call( this ); console.log( greeting );&#125;var me = &#123; name: \"Kyle\"&#125;;var you = &#123; name: \"Reader\"&#125;;identify.call( me ); // KYLEidentify.call( you ); // READERspeak.call( me ); // Hello, I'm KYLEspeak.call( you ); // Hello, I'm READER 这个代码片段允许 identify() 和 speak() 函数对多个 环境 对象（me 和 you）进行复用，而不是针对每个对象定义函数的分离版本。","text":"初识this1234567891011121314151617181920function identify() &#123; return this.name.toUpperCase();&#125;function speak() &#123; var greeting = \"Hello, I'm \" + identify.call( this ); console.log( greeting );&#125;var me = &#123; name: \"Kyle\"&#125;;var you = &#123; name: \"Reader\"&#125;;identify.call( me ); // KYLEidentify.call( you ); // READERspeak.call( me ); // Hello, I'm KYLEspeak.call( you ); // Hello, I'm READER 这个代码片段允许 identify() 和 speak() 函数对多个 环境 对象（me 和 you）进行复用，而不是针对每个对象定义函数的分离版本。 如果不用this,也可以明确的将环境对象传递给 identify() 和 speak() 1234567891011function identify(context) &#123; return context.name.toUpperCase();&#125;function speak(context) &#123; var greeting = \"Hello, I'm \" + identify( context ); console.log( greeting );&#125;identify( you ); // READERspeak( me ); // Hello, I'm KYLE this 机制提供了更优雅的方式来隐含地“传递”一个对象引用，导致更加干净的API设计和更容易的复用。 将执行环境作为一个明确参数传递，通常比传递 this 执行环境要乱。 this可以自动引用执行环境对象 看下面这段代码,追踪foo被调用了几次: 123456789101112131415161718function foo(num) &#123; console.log( \"foo: \" + num );// 追踪 `foo` 被调用了多少次 this.count++;&#125;foo.count = 0;var i;for (i=0; i&lt;10; i++) &#123; if (i &gt; 5) &#123; foo( i ); &#125;&#125;// foo: 6// foo: 7// foo: 8// foo: 9// `foo` 被调用了多少次？console.log( foo.count ); // 0 -- 这他妈怎么回事……？ foo.count 依然 是 0, 即便四个 console.log 语句明明告诉我们 foo(..) 实际上被调用了四次。源于对于 this（在 this.count++ 中）的含义进行了 过于字面化 的解释。 当代码执行 foo.count = 0 时，它确实向函数对象 foo 添加了一个 count 属性。但是对于函数内部的 this.count 引用，this 其实 根本就不 指向那个函数对象，即便属性名称一样，但根对象也不同，因而产生了混淆。 创建另一个对象来持有 count 属性： 12345678910111213141516171819202122function foo(num) &#123; console.log( \"foo: \" + num ); // 追踪 `foo` 被调用了多少次 data.count++;&#125;var data = &#123; count: 0&#125;;var i;for (i=0; i&lt;10; i++) &#123; if (i &gt; 5) &#123; foo( i ); &#125;&#125;// foo: 6// foo: 7// foo: 8// foo: 9// `foo` 被调用了多少次？console.log( data.count ); // 4 看到这里,你应该知道this的指向，this指向了window，这涉及到了词法作用域 为了从函数对象内部引用它自己，一般来说通过 this 是不够的。你通常需要通过一个指向它的词法标识符（变量）得到函数对象的引用。 12345678910function foo() &#123; foo.count = 4; // `foo` 引用它自己&#125;setTimeout( function()&#123; // 匿名函数（没有名字）不能引用它自己&#125;, 10 );第一个函数，称为“命名函数”，foo 是一个引用，可以用于在它内部引用自己。而在第二个例子中,传递给 setTimeout(..) 的回调函数没有名称标识符（所以被称为“匿名函数”），所以没有合适的办法引用函数对象自己。 通过命名函数调用自己,每个地方都是用foo 标识符作为对函数的引用(完全依靠foo的词法作用域): 12345678910111213141516function foo(num) &#123; console.log( \"foo: \" + num ); foo.count++; // 追踪 `foo` 被调用了多少次&#125;foo.count = 0;var i;for (i=0; i&lt;10; i++) &#123; if (i &gt; 5) &#123; foo( i ); &#125;&#125;// foo: 6// foo: 7// foo: 8// foo: 9console.log( foo.count ); // 4 利用call强迫this指向foo 1234567891011121314151617function foo(num) &#123; console.log( \"foo: \" + num ); // 注意：由于 `foo` 的被调用方式（见下方），`this` 现在确实是 `foo` this.count++; // 追踪 `foo` 被调用了多少次&#125;foo.count = 0;var i;for (i=0; i&lt;10; i++) &#123; if (i &gt; 5) &#123; foo.call( foo, i );// 使用 `call(..)`，我们可以保证 `this` 指向函数对象(`foo`) &#125;&#125;// foo: 6// foo: 7// foo: 8// foo: 9console.log( foo.count ); // 4 解惑this调用点（Call-site）函数在代码中被调用的位置（不是被声明的位置） 调用栈（call-stack）: 使我们到达当前执行位置而被调用的所有方法的堆栈 123456789101112131415161718function baz() &#123; // 调用栈是: `baz` // 我们的调用点是 global scope（全局作用域） console.log( \"baz\" ); bar(); // &lt;-- `bar` 的调用点&#125;function bar() &#123; // 调用栈是: `baz` -&gt; `bar` // 我们的调用点位于 `baz` console.log( \"bar\" ); foo(); // &lt;-- `foo` 的 call-site&#125;function foo() &#123; // 调用栈是: `baz` -&gt; `bar` -&gt; `foo` // 我们的调用点位于 `bar` console.log( \"foo\" );&#125;baz(); // &lt;-- `baz` 的调用点 调用规则默认绑定（Default Binding)该规则源于函数调用最常见的情况:独立函数调用。可以认为这种 this 规则是在没有其他规则适用时的默认规则。 123456function foo() &#123; console.log( this.a );&#125;var a = 2;foo(); // 2 独立函数的调用,相当于window.foo(),对此方法调用的this实施了默认绑定,使this指向全局对象window 如果 strict mode 在这里生效，那么对于 默认绑定 来说全局对象是不合法的，所以 this 将被设置为 undefined。 123456function foo() &#123; \"use strict\"; console.log( this.a );&#125;var a = 2;foo(); // TypeError: `this` is `undefined` 有一个重要的细节: 即便所有的 this 绑定规则都是完全基于调用点的,如果foo()的内容没有在strict mode下执行,对于 默认绑定 来说全局对象是 唯一 合法的； 12345678function foo() &#123; console.log( this.a );&#125;var a = 2;(function()&#123; \"use strict\"; foo(); // 2&#125;)(); foo() 的调用点的 strict mode 状态与此无关。 隐含绑定（Implicit Binding)调用点是否有一个环境对象（context object） 12345678function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;obj.foo(); // 2 foo() 被声明然后作为引用属性添加到 obj 上，obj通过函数引用调用foo(),foo()内的this就指代调用对象obj; 可以这样理解:this是在函数执行时自动创建的一个关键词,会自动指向正在调用当前函数的对象 隐含丢失（Implicitly Lost）当一个 隐含绑定 丢失了它的绑定，这通常意味着它会退回到 默认绑定， 根据 strict mode 的状态，其结果不是全局对象就是 undefined。 12345678910function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2, foo: foo&#125;;var bar = obj.foo; // 函数引用！var a = \"oops, global\"; // `a` 也是一个全局对象的属性bar(); // \"oops, global\" 这里bar仅仅是对foo的一个应用而已,调用点是bar(),因此默认绑定适用这里; 12345678910111213function foo() &#123; console.log( this.a );&#125;function doFoo(fn) &#123; // `fn` 只不过 `foo` 的另一个引用 fn(); // &lt;-- 调用点!&#125;var obj = &#123; a: 2, foo: foo&#125;;var a = \"oops, global\"; // `a` 也是一个全局对象的属性doFoo( obj.foo ); // \"oops, global\" 看到这里,可以看出this的指向是由函数对象的调用点决定的 明确绑定（Explicit Binding）如果你想强制一个函数调用使用某个特定对象作为 this 绑定,通过call或apply方法,用于指定this 1234567function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2&#125;;foo.call( obj ); // 2 通过 foo.call(..) 使用 明确绑定 来调用 foo，允许我们强制函数的 this 指向 obj。 如果你传递一个简单基本类型值（string，boolean，或 number 类型）作为 this 绑定，那么这个基本类型值会被包装在它的对象类型中（分别是 new String(..)，new Boolean(..)，或 new Number(..)）。这通常称为“封箱（boxing）”。 硬绑定（Hard Binding） 1234567891011121314151617function foo() &#123; console.log( this.a );&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; foo.call( obj );&#125;;bar(); // 2setTimeout( bar, 100 ); // 2// `bar` 将 `foo` 的 `this` 硬绑定到 `obj`// 所以它不可以被覆盖bar.call( window ); // 2 我们创建了一个函数 bar()，在它的内部手动调用 foo.call(obj)，由此强制 this 绑定到 obj 并调用 foo。无论你过后怎样调用函数 bar，它总是手动使用 obj 调用 foo。这种绑定即明确又坚定，所以我们称之为 硬绑定（hard binding） 用 硬绑定 将一个函数包装起来的最典型的方法，是为所有传入的参数和传出的返回值创建一个通道： 12345678910111213function foo(something) &#123; console.log( this.a, something ); return this.a + something;&#125;var obj = &#123; a: 2&#125;;var bar = function() &#123; return foo.apply( obj, arguments );&#125;;var b = bar( 3 ); // 2 3console.log( b ); // 5 API 调用的“环境” 许多库中的函数，和许多在 JavaScript 语言以及宿主环境中的内建函数，都提供一个可选参数，通常称为“环境（context）”，这种设计作为一种替代方案来确保你的回调函数使用特定的 this 而不必非得使用 bind(..)。 12345678910function foo(el) &#123; console.log( el, this.id );&#125;var obj = &#123; id: \"awesome\"&#125;;// 使用 `obj` 作为 `this` 来调用 `foo(..)`[1, 2, 3].forEach( foo, obj ); // 1 awesome 2 awesome 3 awesome 从内部来说，几乎可以确定这种类型的函数是通过 call(..) 或 apply(..) 来使用 明确绑定 new 绑定（new Binding）当在函数前面被加入 new 调用时: 创建一个新的空对象 自动让新的子对象继承构造函数继承原型对象 调用构造函数，将构造函数中的this执行正在创建的新的空对象中强行添加新成员将新对象地址返回给变量 将新对象地址返回给变量保存 12345function foo(a) &#123; this.a = a;&#125;var bar = new foo( 2 );console.log( bar.a ); // 2 以上就是函数调用中的四种 this 绑定规则,通常需要找到调用点然后考察哪一种规则适用于它。但四种规则是有优先级的, 判定 this 函数是通过 new 被调用的吗（new 绑定）？如果是，this 就是新构建的对象。 var bar = new foo() 函数是通过 call 或 apply 被调用（明确绑定），甚至是隐藏在 bind 硬绑定 之中吗？如果是，this 就是那个被明确指定的对象。 var bar = foo.call( obj2 ) 函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（隐含绑定）？如果是，this 就是那个环境对象。 var bar = obj1.foo() 否则，使用默认的 this（默认绑定）。如果在 strict mode 下，就是 undefined，否则是 global 对象。 var bar = foo() 以上，就是理解对于普通的函数调用来说的 this 绑定规则 所需的全部。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blog.haohome.top/tags/JS/"},{"name":"YDKJS","slug":"YDKJS","permalink":"http://blog.haohome.top/tags/YDKJS/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"你不知道的JavaScript之词法作用域与动态作用域","slug":"JavaScript/你不知道的JavaScript之词法作用域与动态作用域","date":"2018-10-19T16:00:00.000Z","updated":"2018-10-21T15:38:43.000Z","comments":true,"path":"2018/10/20/JavaScript/你不知道的JavaScript之词法作用域与动态作用域/","link":"","permalink":"http://blog.haohome.top/2018/10/20/JavaScript/你不知道的JavaScript之词法作用域与动态作用域/","excerpt":"介绍在写代码的过程中,我们经常分不清作用域中变量的值指向什么,主要原因是我们分不清楚是应该按照函数的调用顺序还是按照函数位置的嵌套顺序查找变量.作用域有两种工作模式:词法作用域和动态作用域,词法作用域也叫静态作用域. 词法作用域关心函数在何处声明，作用域链基于作用域嵌套 动态作用域关心函数在何处调用，作用域链基于调用栈","text":"介绍在写代码的过程中,我们经常分不清作用域中变量的值指向什么,主要原因是我们分不清楚是应该按照函数的调用顺序还是按照函数位置的嵌套顺序查找变量.作用域有两种工作模式:词法作用域和动态作用域,词法作用域也叫静态作用域. 词法作用域关心函数在何处声明，作用域链基于作用域嵌套 动态作用域关心函数在何处调用，作用域链基于调用栈 词法作用域词法作用域是定义在词法阶段的作用域，是由写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变. 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定 123456789function foo()&#123; var a = 1; bar();&#125;function bar()&#123; console.log(a);&#125;var a = 100;foo(); // 100 因为bar函数是在全局声明的，所以是输出全局变量a的值 词法作用域中又分为函数作用域和块级作用域,JavaScript没有动态作用域,它是基于函数作用域的,但同时也有块级作用域,如with关键字、try-catch语句的catch子句、let关键字（ES6）、const关键字（ES6） 动态作用域我们经常会把词法作用域和this机制弄混淆,这是因为this机制从某种程度上与动态作用域类似. 动态作用域并不关心函数和作用域是如何声明以及在任何处声明的，只关心它们从何处调用 继续拿上面的例子,如果处于动态作用域,变量a应首先在bar()中查找,没有找到会顺着调用栈在调用bar()函数的地方也就是foo()函数中查找,找到赋值a为1,所以输出1 两种作用域的区别，简而言之，词法作用域是在定义时确定的，而动态作用域是在运行时确定的","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blog.haohome.top/tags/JS/"},{"name":"YDKJS","slug":"YDKJS","permalink":"http://blog.haohome.top/tags/YDKJS/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"你不知道的JavaScript之闭包","slug":"JavaScript/你不知道的JavaScript之闭包","date":"2018-10-17T16:00:00.000Z","updated":"2018-10-21T14:58:07.000Z","comments":true,"path":"2018/10/18/JavaScript/你不知道的JavaScript之闭包/","link":"","permalink":"http://blog.haohome.top/2018/10/18/JavaScript/你不知道的JavaScript之闭包/","excerpt":"1. 简介 闭包是函数和声明该函数的词法环境的组合。(来自:MDN) 另一种定义:是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另外一个函数。 12345678function init() &#123; var name = \"Mozilla\"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; displayName();&#125;init(); // 弹出Mozilla init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。 displayName() 内没有自己的局部变量，然而它可以访问到外部函数的变量name; 但是，如果有同名变量 name 在 displayName() 中被定义，则会优先使用 displayName() 中定义的 name 。 这个词法作用域的例子介绍了引擎是如何解析函数嵌套中的变量的","text":"1. 简介 闭包是函数和声明该函数的词法环境的组合。(来自:MDN) 另一种定义:是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另外一个函数。 12345678function init() &#123; var name = \"Mozilla\"; // name 是一个被 init 创建的局部变量 function displayName() &#123; // displayName() 是内部函数,一个闭包 alert(name); // 使用了父函数中声明的变量 &#125; displayName();&#125;init(); // 弹出Mozilla init() 创建了一个局部变量 name 和一个名为 displayName() 的函数。 displayName() 内没有自己的局部变量，然而它可以访问到外部函数的变量name; 但是，如果有同名变量 name 在 displayName() 中被定义，则会优先使用 displayName() 中定义的 name 。 这个词法作用域的例子介绍了引擎是如何解析函数嵌套中的变量的 闭包是由函数以及创建该函数的词法环境组合而成,这个环境包含了这个闭包创建时所能访问的所有局部变量。函数displayName()具有一个涵盖init()作用域的闭包 12345678910function makeFunc() &#123; var name = \"Mozilla\"; function displayName() &#123; alert(name); &#125; return displayName;&#125;var myFunc = makeFunc();myFunc(); myFunc 是执行 makeFunc 时创建的 displayName 函数实例的引用，而 displayName 实例仍可访问其词法作用域中的变量(闭包环境)，即可以访问到 name 。 当 myFunc 被调用时，name 仍可被访问，其值 Mozilla 就被传递到alert中。 再看一个例子: 1234567891011function makeAdder(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;var add5 = makeAdder(5);var add10 = makeAdder(10);console.log(add5(2)); // 7console.log(add10(4)); // 14 我们定义了 makeAdder(x) 函数，它接受一个参数 x ，并返回一个新的函数 返回的函数接受一个参数 y，并返回x+y的值 makeAdder 是一个函数工厂 ,其创建了两个新函数,新函数执行时其参数y与makeAdder形成的闭包环境中的参数x相加; 而add5 和 add10 都是闭包,它们共享相同的函数定义，但是保存了不同的词法环境。在 add5的环境中，x 为 5。而在 add10 中，x 则为 10。 这就是闭包: 它允许将函数与其所操作的某些数据（环境）关联起来,类似于面向对象,允许对象的属性与一个或多个方法关联 2. 一个常见的错误:循环和闭包 这是一道经典的面试题,setTimeout定时器是一个异步回调的方法,当执行定时器回调函数时,回调函数内部的i都通过词法作用域共享变量i,而此时for循环已经终止,i值为6,因此每个打印出来的都为6 而如果希望打印的是1,2,3,4,5,通过声明并立即执行一个函数来创建作用域,循环中的每个迭代都给自己捕获一个i的副本储存,结果就能实现,如: ES6语法中let会创建块级作用域,很简单就能实现 12345for (let i = 1; i &lt;= 5; i++) &#123; setTimeout(function timer() &#123; console.log(i); &#125;,i * 1000)&#125; 3.用闭包模拟私有方法(模块模式)在java的编程语言中,是支持方法声明为私有的,即他们只能被同一个类中的其他方法所调用,JavaScript不支持(typescript支持),但js是可以通过闭包的方式模拟私有方法; 私有化方法有利于限制对代码的访问,还提供了管理全局命名空间的能力,避免非核心方法影响了代码的公共接口部分 1234567891011121314151617181920212223242526function Counter() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125; &#125;;var count1= Counter()console.log(count1.value()); //0count1.increment();count1.increment();console.log(count1.value()); //2count1.decrement();count1.log(Counter.value()); //1var count2 = Counter()console.log(count2.value()) //0 Counter()形成了闭包环境(可认为是模块),返回三个对象方法:increment、decrement 和 value,这三个公共函数具有涵盖实例内部作用域的闭包,其本质也可看做是模块的公共API,通过它访问闭包环境内的私有属性和方法:privateCounter 的变量和名为 changeBy 的函数; 通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。 当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创造了可以观察和实践闭包的条件。 对于模块模式,需要具备两个必要条件: 必须有外部的封闭函数,形成私有作用域,该函数必须至少被调用一次(每次调用都会创建一个新的模块实例) 封闭函数必须返回至少一个内部函数,即模块的公共API,以访问或者修改私有的状态 上一个示例代码中有一个叫作Counter()的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实现单例模式： 采用匿名函数自调 123456789101112131415161718var counter = (function() &#123; var privateCounter = 0; function changeBy(val) &#123; privateCounter += val; &#125; return &#123; increment: function() &#123; changeBy(1); &#125;, decrement: function() &#123; changeBy(-1); &#125;, value: function() &#123; return privateCounter; &#125; &#125; &#125;)();console.log(count.value()); //0","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blog.haohome.top/tags/JS/"},{"name":"YDKJS","slug":"YDKJS","permalink":"http://blog.haohome.top/tags/YDKJS/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"iTerm终端设置代理","slug":"Mac&PC/iTerm 终端设置代理","date":"2018-10-09T16:00:00.000Z","updated":"2018-10-20T07:21:25.000Z","comments":true,"path":"2018/10/10/Mac&PC/iTerm 终端设置代理/","link":"","permalink":"http://blog.haohome.top/2018/10/10/Mac&PC/iTerm 终端设置代理/","excerpt":"","text":"某些站点必须爬墙才能访问，但在mac上设置的全局代理，对终端又不起作用，终端需要单独设置代理。在终端中执行： 1export ALL_PROXY=socks5://127.0.0.1:1086/ 如果是http的代理: 12export http_proxy=http://127.0.0.1:1087/export https_proxy=http://127.0.0.1:1087/ 如果需要开机自动设置，把上面的代码加到~/.bash_profile里 source ~/.bash_profile 使文件生效 测试当前终端标签/窗口是否走代理： 1curl ip.gs","categories":[{"name":"Mac&PC","slug":"Mac-PC","permalink":"http://blog.haohome.top/categories/Mac-PC/"}],"tags":[{"name":"电脑技巧","slug":"电脑技巧","permalink":"http://blog.haohome.top/tags/电脑技巧/"}],"keywords":[{"name":"Mac&PC","slug":"Mac-PC","permalink":"http://blog.haohome.top/categories/Mac-PC/"}]},{"title":"JavaScript设计模式之适配器模式","slug":"JavaScript/JavaScript设计模式之适配器模式","date":"2018-10-06T16:00:00.000Z","updated":"2018-10-07T06:52:42.000Z","comments":true,"path":"2018/10/07/JavaScript/JavaScript设计模式之适配器模式/","link":"","permalink":"http://blog.haohome.top/2018/10/07/JavaScript/JavaScript设计模式之适配器模式/","excerpt":"简介适配器模式的作用是解决两个软件实体间的接口不兼容的问题. 这在实际开发过程中会经常遇到,比如后端返回的数据api接口与前端实际需求有差异,我们就需要对数据api接口进行转换一下再使用,这就需要适配器;而在vue中最直接的提现就是computed属性 举个例子: 当向谷歌地图和百度地图都发出显示请求时,两个地图都以各自的方式展示 123456789101112131415161718192021class GoogleMap&#123; show()&#123; console.log( '开始渲染谷歌地图' ); &#125;&#125;class BaiduMap&#123; show()&#123; console.log( '开始渲染百度地图' ); &#125;&#125;;class RenderMap&#123; constructor(map)&#123; if ( map.show instanceof Function )&#123; map.show(); &#125; &#125;&#125;;let baiduMap = new BaiduMap()let baidu = new RenderMap(baiduMap)let googleMap = new GoogleMap()let google = new RenderMap(googleMap)","text":"简介适配器模式的作用是解决两个软件实体间的接口不兼容的问题. 这在实际开发过程中会经常遇到,比如后端返回的数据api接口与前端实际需求有差异,我们就需要对数据api接口进行转换一下再使用,这就需要适配器;而在vue中最直接的提现就是computed属性 举个例子: 当向谷歌地图和百度地图都发出显示请求时,两个地图都以各自的方式展示 123456789101112131415161718192021class GoogleMap&#123; show()&#123; console.log( '开始渲染谷歌地图' ); &#125;&#125;class BaiduMap&#123; show()&#123; console.log( '开始渲染百度地图' ); &#125;&#125;;class RenderMap&#123; constructor(map)&#123; if ( map.show instanceof Function )&#123; map.show(); &#125; &#125;&#125;;let baiduMap = new BaiduMap()let baidu = new RenderMap(baiduMap)let googleMap = new GoogleMap()let google = new RenderMap(googleMap) 这段程序正常运行的关键是,两个地图类都提供了show的方法,假如google提供的不是show而是display方法,那我们可通过增加新的适配器来解决: 12345678910111213141516class GoogleMap&#123; display()&#123; console.log( '开始渲染谷歌地图' ); &#125;&#125;class GoogleAdapter&#123; constructor(googleMap)&#123; this.googleMap = googleMap &#125; show()&#123; return this.googleMap.display() &#125;&#125;let g = new GoogleMap()let googleMap = new GoogleAdapter(g)let google = new RenderMap(googleMap) 适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blog.haohome.top/tags/JS/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.haohome.top/tags/设计模式/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"JavaScript设计模式之单例模式","slug":"JavaScript/JavaScript设计模式之单例模式","date":"2018-10-05T16:00:00.000Z","updated":"2018-10-07T06:50:46.000Z","comments":true,"path":"2018/10/06/JavaScript/JavaScript设计模式之单例模式/","link":"","permalink":"http://blog.haohome.top/2018/10/06/JavaScript/JavaScript设计模式之单例模式/","excerpt":"简介单例模式是保证一个类仅有一个实例，并提供一个访问它的全局访问点 实现方式:用一个变量来标志当前是否已经为某个类创建过对象,若是,则在下一次获取该类实例时,直接返回之前创建的对象 12345678910111213141516171819class SingleObject&#123; constructor(instance)&#123; this.instance = instance &#125; login()&#123; console.log('登录框弹窗') &#125;&#125;SingleObject.getInstance = function()&#123; if(!this.instance)&#123; this.instance = new SingleObject() &#125; return this.instance&#125;let obj1 = SingleObject.getInstance()obj1.login()let obj2 = SingleObject.getInstance()obj2.login()console.log('obj1===obj2',obj1===obj2) 通过SingleObject.getInstance来获取SingleObject类的唯一对象","text":"简介单例模式是保证一个类仅有一个实例，并提供一个访问它的全局访问点 实现方式:用一个变量来标志当前是否已经为某个类创建过对象,若是,则在下一次获取该类实例时,直接返回之前创建的对象 12345678910111213141516171819class SingleObject&#123; constructor(instance)&#123; this.instance = instance &#125; login()&#123; console.log('登录框弹窗') &#125;&#125;SingleObject.getInstance = function()&#123; if(!this.instance)&#123; this.instance = new SingleObject() &#125; return this.instance&#125;let obj1 = SingleObject.getInstance()obj1.login()let obj2 = SingleObject.getInstance()obj2.login()console.log('obj1===obj2',obj1===obj2) 通过SingleObject.getInstance来获取SingleObject类的唯一对象 应用场景: 网站的登录框通常只有一个实例 12345678910111213141516171819202122232425262728293031323334353637class LoginForm&#123; constructor()&#123; this.state = 'hide' // 默认隐藏 &#125; show()&#123; if(this.state === 'show')&#123; alert('已经显示') return &#125; this.state = 'show' console.log('登录框显示成功') &#125; hide()&#123; if(this.state === 'hide')&#123; alert('已经隐藏') return &#125; this.state = 'hide' console.log('登录框隐藏成功') &#125;&#125;LoginForm.getInstance = (function()&#123; let instance console.log('外部',instance) return function()&#123; console.log('内部',instance) if(!instance)&#123; instance = new LoginForm() &#125; return instance &#125;&#125;)()// testlet login1 = LoginForm.getInstance()login1.show()let login2 = LoginForm.getInstance()login2.show()","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JS","slug":"JS","permalink":"http://blog.haohome.top/tags/JS/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.haohome.top/tags/设计模式/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"Mac下使用iTerm2让SSH记录远程服务器账号和密码","slug":"Mac&PC/Mac下使用iTerm2让SSH记录远程服务器账号和密码","date":"2018-10-04T16:00:00.000Z","updated":"2018-11-14T14:23:08.000Z","comments":true,"path":"2018/10/05/Mac&PC/Mac下使用iTerm2让SSH记录远程服务器账号和密码/","link":"","permalink":"http://blog.haohome.top/2018/10/05/Mac&PC/Mac下使用iTerm2让SSH记录远程服务器账号和密码/","excerpt":"","text":"iTerm2和Macbook自带的Terminal差不多，但是功能更强大，强烈推荐使用。 下面说下，如何让iTerm2记住远程服务器SSH登录账号和密码。 第一步：打开Finder，在菜单栏找到『前往』→ 『前往文件夹…』，输入：~/.ssh/ 然后回车 第二步：新建一个文件，命名为example吧，里面写入内容： 123456789set user rootset host 114.114.114.114set password ******** spawn ssh $user@$hostexpect \"*assword:*\"send \"$password\\r\"interactexpect eof 第三步：到官方http://www.iterm2.com/下载并打开iTerm2，菜单栏找到『Profiles』→『Open Profiles…』,打开面板上，点击右下角『Edit Profiles…』 第四步：在打开面板，左边应该是选中默认default，右边找到Command，默认应该是Login shell，选中Command，里面输入：expect ~/.ssh/example 第五步，下次打开iTerm2，是不是默认就登录上服务器了？极大提升效率。 按照以上方法，可以配置profile,对应很多个服务器。这样每次启动可以选择默认操作，然后再profile下拉选中中执行对应的VPS profile，则可以实现自动登录！ Tips: 如果重新添加相同ip的实例,需要在~/.ssh/known_hosts 里删除该ip的ssh-rsa码","categories":[{"name":"Mac&PC","slug":"Mac-PC","permalink":"http://blog.haohome.top/categories/Mac-PC/"}],"tags":[{"name":"电脑技巧","slug":"电脑技巧","permalink":"http://blog.haohome.top/tags/电脑技巧/"}],"keywords":[{"name":"Mac&PC","slug":"Mac-PC","permalink":"http://blog.haohome.top/categories/Mac-PC/"}]},{"title":"图片上传与压缩","slug":"Program/图片上传与压缩","date":"2018-09-29T16:00:00.000Z","updated":"2018-09-30T15:20:24.000Z","comments":true,"path":"2018/09/30/Program/图片上传与压缩/","link":"","permalink":"http://blog.haohome.top/2018/09/30/Program/图片上传与压缩/","excerpt":"最近在做关于移动端图片上传方面,项目中主要需要实现图片的本地预览、压缩和上传 1. 图片选择和预览添加accept属性,控制选择文件的类型为拍照和图像文件,设置multiple支持图片文件多选,监听input的change事件获取选择对象文件,每个文件都是Blob类型","text":"最近在做关于移动端图片上传方面,项目中主要需要实现图片的本地预览、压缩和上传 1. 图片选择和预览添加accept属性,控制选择文件的类型为拍照和图像文件,设置multiple支持图片文件多选,监听input的change事件获取选择对象文件,每个文件都是Blob类型 123456789101112131415161718&lt;label for=\"file2\"&gt;多个图片上传&lt;/label&gt;&lt;input type=\"file\" accept=\"image/gif,image/jpeg,image/png\" multiple id='file2' /&gt; &lt;br&gt;&lt;div id=\"preview2\"&gt;&lt;/div&gt;&lt;script&gt;// 模拟jQueryvar $ = selector =&gt; document.querySelector(selector)// 多个图片var file2 = $(\"#file2\")var preview2 = $('#preview2')file2.onchange = function () &#123; var fileList = Array.prototype.slice.call(this.files) fileList.forEach((item, index) =&gt; &#123; var domImg = new Image(); domImg.src = URL.createObjectURL(item) preview2.appendChild(domImg) &#125;)&#125;&lt;/script&gt; 2. 图片的压缩当前手机拍照质量月来越高,带来的问题就是大小也越来越大,直接上传原图,上传速度会很低,甚至很可能上传失败,而且后续加载也影响速度 下面是封装了一个压缩图片的方法,实现的原理是,利用canvas将图片绘制出来,并导出canvas图片.主要通过图片的缩放和控制canvas导出图片质量来实现图片的体积压缩 1234567891011121314151617181920212223242526272829303132333435363738394041 /** * 压缩图片 * @param &#123;file&#125; 输入图片 * @param &#123;quality&#125; 图片质量 * @returns &#123;Promise&#125; resolved promise 返回压缩后的新图片 */function compressImg(file, quality) &#123; return new Promise((resolve, reject) =&gt; &#123; var img = new Image(); img.src = URL.createObjectURL(file) img.onerror = error =&gt; reject(error) img.onload = () =&gt; &#123; var canvas = document.createElement('canvas') var ctx = canvas.getContext('2d') var canvasWidth = document.documentElement.clientWidth * window.devicePixelRatio var canvasHeight = document.documentElement.clientHeight * window.devicePixelRatio // 水平方向想缩放比 var scaleX = canvasWidth / img.width var scaleY = canvasHeight / img.height // 取缩放比更小的比例 var scale = Math.min(scaleX, scaleY) // 画布上绘制的图片尺寸 const imageWidth = img.width * scale const imageHeight = img.height * scale canvas.width = imageWidth canvas.height = imageHeight ctx.drawImage(img, 0, 0, imageWidth, imageHeight) canvas.toBlob(file =&gt; resolve(file), \"image/jpeg\", quality); &#125; &#125;)&#125;file2.onchange = function () &#123; var fileList = Array.prototype.slice.call(this.files) fileList.forEach((item, index) =&gt; &#123; compressImg(imgfile, .5).then(blobFile =&gt; &#123; var domImg = new Image(); domImg.src = URL.createObjectURL(blobFile) preview2.appendChild(domImg) &#125;) &#125;)&#125; 3. 图片上传文件上传是通过FormData创建表单数据，并发起 ajax POST请求; 发送FormData数据时，浏览器会自动设置Content-Type为合适的值 123456789101112131415161718192021222324/** * 上传图片 * @param &#123;File&#125; file 待上传的文件 * @return &#123;Promise&#125; */ function uploadFile(file,url) &#123; return new Promise((resolve, reject) =&gt; &#123; // 准备表单数据 const formData = new FormData() formData.append('file', file) // 提交请求 const xhr = new XMLHttpRequest() xhr.open('POST', url) xhr.onreadystatechange = function () &#123; if (this.readyState === XMLHttpRequest.DONE &amp;&amp; this.status === 200) &#123; resolve(JSON.parse(this.responseText)) &#125; else &#123; reject(this.responseText) &#125; &#125; xhr.send(formData) &#125;) &#125; 最后奉上JSrun的demo:","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"Data类型的url简介","slug":"HTML5&CSS/Data类型的Url简介","date":"2018-09-27T16:00:00.000Z","updated":"2018-09-28T05:20:42.000Z","comments":true,"path":"2018/09/28/HTML5&CSS/Data类型的Url简介/","link":"","permalink":"http://blog.haohome.top/2018/09/28/HTML5&CSS/Data类型的Url简介/","excerpt":"1. 定义和语法Data URLs，即前缀为 data: 协议的的URL，其允许内容创建者向文档中嵌入小文件。(MDN) 这样的好处是减少外部资源的载入,减少http请求 Data URLs 由四个部分组成：前缀(data:)、指示数据类型的MIME类型、如果非文本则为可选的base64标记、数据本身： data:[&lt;mediatype&gt;][;base64],&lt;data&gt; mediatype是个 MIME 类型的字符串，例如 “image/jpeg“ 表示 JPEG 图像文件,如果被省略，则默认值为 text/plain;charset=US-ASCII 实例: data:,Hello%2C%20World!简单的 text/plain 类型数据 data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D上一条示例的 base64 编码版本 data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E一个HTML文档源代码 &lt;h1&gt;Hello, World&lt;/h1&gt; data:text/html,&lt;script&gt;alert(&#39;hi&#39;);&lt;/script&gt;一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。","text":"1. 定义和语法Data URLs，即前缀为 data: 协议的的URL，其允许内容创建者向文档中嵌入小文件。(MDN) 这样的好处是减少外部资源的载入,减少http请求 Data URLs 由四个部分组成：前缀(data:)、指示数据类型的MIME类型、如果非文本则为可选的base64标记、数据本身： data:[&lt;mediatype&gt;][;base64],&lt;data&gt; mediatype是个 MIME 类型的字符串，例如 “image/jpeg“ 表示 JPEG 图像文件,如果被省略，则默认值为 text/plain;charset=US-ASCII 实例: data:,Hello%2C%20World!简单的 text/plain 类型数据 data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D上一条示例的 base64 编码版本 data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E一个HTML文档源代码 &lt;h1&gt;Hello, World&lt;/h1&gt; data:text/html,&lt;script&gt;alert(&#39;hi&#39;);&lt;/script&gt;一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。 2. data url的优缺点优点: 当访问外部资源很麻烦或受限时(这个比较鸡肋) 当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时（场景较少） 当图片的体积太小，占用一个HTTP会话不是很值得时（雪碧图可以出场了） 缺点: Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3 Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次 3.在css中使用浏览器会css文件以提高访问效率,所以浏览器也可以缓存css中的data url数据, 1234567.box &#123; width: 100px; height: 100px; background-image: url(\"data:image/gif;b ase64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7\"); border: 1px solid gray; padding: 10px;&#125; 图片不是很大,而且不会是重复在css中使用,适合用data url形式展现 更多请阅读Data URI&amp;MHTML: 用还是不用？","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}],"tags":[{"name":"html5","slug":"html5","permalink":"http://blog.haohome.top/tags/html5/"},{"name":"wiki","slug":"wiki","permalink":"http://blog.haohome.top/tags/wiki/"}],"keywords":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}]},{"title":"浏览器兼容性","slug":"Program/浏览器兼容性总结","date":"2018-09-25T16:00:00.000Z","updated":"2018-09-28T01:28:45.000Z","comments":true,"path":"2018/09/26/Program/浏览器兼容性总结/","link":"","permalink":"http://blog.haohome.top/2018/09/26/Program/浏览器兼容性总结/","excerpt":"1. 视频截取第一帧 问题: 在加载h5 的视频时,PC端一半都会默认加载首帧显示,而在移动端就会显示空白或者一片黑 解决方案: 在上传本地视频时,监听视频加载事件,获取第一帧图片,利用canvas绘制出图片并存储,作为移动端视频video的poster onloadeddata事件: 浏览器加载声频、视频当前帧结束后触发的事件(与下一帧是否下载完成无关)在音频和视频加载过程中,能够触发的事件如下: 开始读入媒体数据时触发的事件(onloadstart) 更改声频、视频的时长时(ondurationchange) 浏览器已加载声频、视频的元数据时触发的事件(onloadedmetadata) 浏览器加载声频、视频当前帧结束后(onloadeddata) 浏览器正在下载媒体数据时(onprogress) 浏览器可以播放媒体数据时(oncanplay) 当浏览器可以在不因缓冲而停顿的情况下播放时(oncanplaythrough)","text":"1. 视频截取第一帧 问题: 在加载h5 的视频时,PC端一半都会默认加载首帧显示,而在移动端就会显示空白或者一片黑 解决方案: 在上传本地视频时,监听视频加载事件,获取第一帧图片,利用canvas绘制出图片并存储,作为移动端视频video的poster onloadeddata事件: 浏览器加载声频、视频当前帧结束后触发的事件(与下一帧是否下载完成无关)在音频和视频加载过程中,能够触发的事件如下: 开始读入媒体数据时触发的事件(onloadstart) 更改声频、视频的时长时(ondurationchange) 浏览器已加载声频、视频的元数据时触发的事件(onloadedmetadata) 浏览器加载声频、视频当前帧结束后(onloadeddata) 浏览器正在下载媒体数据时(onprogress) 浏览器可以播放媒体数据时(oncanplay) 当浏览器可以在不因缓冲而停顿的情况下播放时(oncanplaythrough) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;body&gt; &lt;h1&gt;视频获取第一帧&lt;/h1&gt; &lt;hr&gt; &lt;div&gt; &lt;p&gt;本地上传&lt;/p&gt; &lt;label for=\"file\"&gt;选择视频&lt;/label&gt; &lt;input type=\"file\" name=\"\" id=\"file\"\"&gt;&lt;br&gt; &lt;/div&gt; &lt;hr&gt; &lt;div&gt; &lt;p&gt;外链&lt;/p&gt; &lt;input type=\"text\" id='link'&gt;&lt;button id=\"btn\"&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;hr&gt; &lt;video id='video' preload=\"meta\" style='display:none' crossorigin=\"anonymous\"&gt;&lt;/video&gt; &lt;div&gt; &lt;h2&gt;首帧图片显示&lt;/h2&gt; &lt;img src=\"\" alt=\"\" id=\"img\"&gt; &lt;/div&gt; &lt;p&gt;外链视频: https://haohome.top/movie.mp4&lt;/p&gt; &lt;script&gt; var video = document.getElementById(\"video\") var file = document.getElementById(\"file\") var btn = document.getElementById(\"btn\") var link = document.getElementById(\"link\") file.addEventListener(\"change\",function()&#123; var file = this.files[0]; var src = URL.createObjectURL(file) var newFile = new FileReader(file) video.src = src &#125;) btn.onclick=function()&#123; video.src =link.value &#125; video.addEventListener(\"loadeddata\", function () &#123; var canvas = document.createElement(\"canvas\"); canvas.width = this.videoWidth; canvas.height = this.videoHeight; setTimeout(() =&gt; &#123; canvas.getContext('2d').drawImage(video, 0, 0, canvas.width, canvas.height); var imgSrc = ''; try &#123; imgSrc = canvas.toDataURL(\"image/png\"); img.src = imgSrc &#125; catch (e) &#123; document.write(\"只能截取当前域名视频图片! \", e); &#125; &#125;, 200) &#125;, false); &lt;/script&gt;&lt;/body&gt; 当采用链接视频时,会存在视频的跨域问题,需要在video上添加属性crossOrigin=’Anonymous’ 即可(IE由于安全性问题,会报SecurityError) Tips: 获取本地地址两种方法: URL.createObjectURL: 12&gt; var src = URL.createObjectURL(file)&gt; &gt; FileReader: 12345&gt; var fr=new FileReader();&gt; fr.onload=function (file) &#123;&gt; var src =this.result;&gt; &#125;&gt; 当前监听video视频获取首帧图片时,采用了延时200ms,是为了给视频加载以一定时间","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/tags/JavaScript/"},{"name":"兼容性","slug":"兼容性","permalink":"http://blog.haohome.top/tags/兼容性/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"hashchange事件","slug":"Program/hashchange事件","date":"2018-08-27T16:00:00.000Z","updated":"2018-08-28T09:28:17.000Z","comments":true,"path":"2018/08/28/Program/hashchange事件/","link":"","permalink":"http://blog.haohome.top/2018/08/28/Program/hashchange事件/","excerpt":"最近在写公司的后台管理系统，因为需求需要刷新后保持原来页面,原有的单页面组件跳转方式不能满足，所以在原有项目基础上增加了路由功能,目前比较简单的路由切换就是通过监听hash变化，实现不同页面的加载。 当 一个窗口地址的 hash （URL 中 # 后面的部分）改变时就会触发 hashchange 事件: 1234window.onhashchange = handleHashChange;window.addEventListener(\"hashchange\",function(event)&#123; //hash变化的处理逻辑&#125;)","text":"最近在写公司的后台管理系统，因为需求需要刷新后保持原来页面,原有的单页面组件跳转方式不能满足，所以在原有项目基础上增加了路由功能,目前比较简单的路由切换就是通过监听hash变化，实现不同页面的加载。 当 一个窗口地址的 hash （URL 中 # 后面的部分）改变时就会触发 hashchange 事件: 1234window.onhashchange = handleHashChange;window.addEventListener(\"hashchange\",function(event)&#123; //hash变化的处理逻辑&#125;) hashchange 事件回调函数对象主要有两个参数会用到: newURL: 当前页面新的URL oldURL: 当前页面旧的URL 但在IE浏览器里,这两个属性不被支持,需要在绑定hashchange事件前添加以下代码: 12345678if(!window.HashChangeEvent)(function()&#123; var lastURL=document.URL; window.addEventListener(\"hashchange\",function(event)&#123; Object.defineProperty(event,\"oldURL\",&#123;enumerable:true,configurable:true,value:lastURL&#125;); Object.defineProperty(event,\"newURL\",&#123;enumerable:true,configurable:true,value:document.URL&#125;); lastURL=document.URL; &#125;);&#125;());","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/tags/JavaScript/"},{"name":"hash","slug":"hash","permalink":"http://blog.haohome.top/tags/hash/"},{"name":"兼容性","slug":"兼容性","permalink":"http://blog.haohome.top/tags/兼容性/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"JS判断当前文本输入状态","slug":"Program/js判断当前文本输入状态","date":"2018-08-27T16:00:00.000Z","updated":"2018-08-28T09:28:25.000Z","comments":true,"path":"2018/08/28/Program/js判断当前文本输入状态/","link":"","permalink":"http://blog.haohome.top/2018/08/28/Program/js判断当前文本输入状态/","excerpt":"最近在重构我的网址导航页面,这是我认识前端网页的启蒙项目,网上找的模板,然后修改链接、微调样式，成为了最初的网页导航1.0。 在搜索的时候，我们需要按Enter键实现直接跳转搜索，因此添加了按键监听事件。但问题出现了: 绑定keyup事件会将输入法中的英文文字输入到文字框并直接触发搜索按钮 单纯按键监听，并没有判断中文输入状态","text":"最近在重构我的网址导航页面,这是我认识前端网页的启蒙项目,网上找的模板,然后修改链接、微调样式，成为了最初的网页导航1.0。 在搜索的时候，我们需要按Enter键实现直接跳转搜索，因此添加了按键监听事件。但问题出现了: 绑定keyup事件会将输入法中的英文文字输入到文字框并直接触发搜索按钮 单纯按键监听，并没有判断中文输入状态 网上查了一些资料： 键盘事件:当一个键盘被按下并松开时,每个浏览器都会触发三个事件:keydown、keypress、keyupkeydown事件发生在按键被按下的时候，接着触发keypress，松开按键的时候触发keyup事件 还有一个事件就是input:input事件能够检测用户的每一次输入 以上事件在英文状态下没有问题,但在中文状态下,依然捕获到的是英文,如下图: 中文输入法 firfox：输入触发keydown，回车确认输入触发keyupchrome：输入触发keydown、keyup，回车确认输入只触发keydownIE：输入触发keydown、keyup，回车确认输入触发keydown，keyupSafari：输入触发keydown、keyup，回车确认输入触发keydown，keyupopera：输入触发keydown、keyup，回车确认输入触发keydown，keyup在input、textarea中，中文输入法时：没有触发keypress事件keypress事件：对中文输入法支持不好，无法响应中文输入；无法响应系统功能键 解决方案: 利用change事件: 监听输入框最终内容变化识别,当文本输入状态完成,并且input失去焦点再触发enter事件 通常情况下,文本框中文输入状态时,按下回车会触发相应的按钮,此时input会失去焦点并触发change事件,此时将输入状态传给按钮事件,即可判断并执行相应事件 利用compositionstart和compositionend事件(事件不兼容旧浏览器) compositionstart:事件触发于一段文字的输入之前 compositionend事件:当文本段落的组成完成或取消时, compositionend事件将被激发 简单来说，非直接输入法如中文输入开始时，触发compositionstart事件，结束时触发compositionend事件 两类解决方案都可以监听到当前输入框的输入状态,结合input事件，就能对所有的输入进行实时的检测了 1234567891011121314151617var doing=false;var doSomething=function(e)&#123; //我要干点啥&#125;document.getElementById('testInput').addEventListener('compositionstart',function(e)&#123; doing=true;&#125;,false);document.getElementById('testInput').addEventListener('input',function(e)&#123; if(!doing)&#123; doSomething(); &#125;&#125;,false);document.getElementById('testInput').addEventListener('compositionend',function(e)&#123; doing=false; doSomething();&#125;,false);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/tags/JavaScript/"},{"name":"input","slug":"input","permalink":"http://blog.haohome.top/tags/input/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"垃圾回收机制与内存管理","slug":"JavaScript/垃圾回收机制与内存管理","date":"2018-07-10T16:00:00.000Z","updated":"2018-07-18T15:02:39.000Z","comments":true,"path":"2018/07/11/JavaScript/垃圾回收机制与内存管理/","link":"","permalink":"http://blog.haohome.top/2018/07/11/JavaScript/垃圾回收机制与内存管理/","excerpt":"1. 垃圾回收机制JavaScript是一门高级语言,具有自动垃圾回收机制(Garbage Collecatio), js创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放,其主要原理为: 垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 任何程序语言,内存生命周期都是一致的: 分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放/归还","text":"1. 垃圾回收机制JavaScript是一门高级语言,具有自动垃圾回收机制(Garbage Collecatio), js创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放,其主要原理为: 垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 任何程序语言,内存生命周期都是一致的: 分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放/归还 JavaScript的内存分配 在定义变量时就完成了内存分配: 123456var n = 123; // 给数值变量分配内存var s = \"hello\"; // 给字符串分配内存var o = &#123; a: 1, b: null&#125;; // 给对象及其包含的值分配内存 通过函数调用分配内存 12var d = new Date(); // 分配一个 Date 对象var e = document.createElement('div'); // 分配一个 DOM 元素 当内存不再需要使用时释放 不再使用的变量也就是内存生命周期的结束,只可能是局部变量,局部变量只在函数的执行过程中存在,全局变量的生命周期直至浏览器卸载页面才会结束。 1234567891011function fn1() &#123; var obj = &#123;name: 'hanzichi', age: 10&#125;;&#125;function fn2() &#123; var obj = &#123;name:'hanzichi', age: 10&#125;; return obj;&#125;var a = fn1();var b = fn2(); 上面定义了两个function，分别叫做fn1和fn2: 当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象{name: &#39;hanzichi&#39;, age: 10},当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放； 在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。 所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，垃圾回收算法主要依赖于引用的概念。 在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。 例如:一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。 1.1 标记清除这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”; 12345function test()&#123; var a = 10 ; //被标记 ，进入环境 var b = 20 ; //被标记 ，进入环境&#125;test(); //执行完毕 之后 a、b又被标离开环境，被回收。 1.2 引用计数引用计数的含义是跟踪记录每个值被引用的次数。 当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。 123456function test()&#123; var a = &#123;&#125; ; //a的引用次数为0 var b = a ; //a的引用次数加1，为1 var c =a; //a的引用次数再加1，为2 var b =&#123;&#125;; //a的引用次数减1，为1&#125; 引用计数这种方式在老式浏览器中采用,在循环引用是会出现内存泄露问题: 1234567function fn() &#123; var a = &#123;&#125;; var b = &#123;&#125;; a.pro = b; b.pro = a;&#125;fn(); 标记清除: fn()执行完毕后，两个对象都已经离开环境,内存回收; 引用计数: fn()执行完毕后,a和b的引用次数都是2,不会被垃圾回收器回收内存;如果fn函数被大量调用，就会造成内存泄露。(在IE7与IE8上，内存直线上升) IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。 1234window.onload=function outerFunction()&#123; var obj = document.getElementById(\"element\"); obj.onclick=function innerFunction()&#123;&#125;;&#125;; obj引用了document.getElementById(“element”)，而document.getElementById(“element”)的onclick方法会引用外部环境中德变量，自然也包括obj，是不是很隐蔽? 最简单的方式就是自己手工解除循环引用: 12345window.onload=function outerFunction()&#123; var obj = document.getElementById(\"element\"); obj.onclick=function innerFunction()&#123;&#125;; obj=null;&#125;; IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变 2. 内存管理2.1 合理的方案当前比较合理的方案是标记清除: 遍历所有可访问的对象; 回收已不可访问的对象 2.2 GC的缺陷和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"你不知道的JavaScript","slug":"你不知道的JavaScript","permalink":"http://blog.haohome.top/tags/你不知道的JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"点击事件重复请求","slug":"JavaScript/点击事件重复请求","date":"2018-05-28T16:00:00.000Z","updated":"2018-05-30T13:27:34.000Z","comments":true,"path":"2018/05/29/JavaScript/点击事件重复请求/","link":"","permalink":"http://blog.haohome.top/2018/05/29/JavaScript/点击事件重复请求/","excerpt":"引子当我们针对某个按钮绑定点击事件后，就可以随时通过点击鼠标来触发按钮的点击事件，如： 12345var num = 1;$('ele').on('click',function()&#123; num++; //执行的业务逻辑&#125;) 这样num值会不断增加，依赖于num值的业务逻辑就会出错；一般出现的场景有： ajax请求; 问卷答题 接下来我们根据这些场景来分析下;","text":"引子当我们针对某个按钮绑定点击事件后，就可以随时通过点击鼠标来触发按钮的点击事件，如： 12345var num = 1;$('ele').on('click',function()&#123; num++; //执行的业务逻辑&#125;) 这样num值会不断增加，依赖于num值的业务逻辑就会出错；一般出现的场景有： ajax请求; 问卷答题 接下来我们根据这些场景来分析下; 场景分析1. ajax提交 当用户短时间内重复点击登录按钮时,会触发多次的表单提交;解决方案: 当点击提交按钮后,给按钮添加disabled属性,事件完成后再removeAttr(&#39;disabled&#39;) 2. 问卷答题 当选择一个答案时,重复点击,机会造成num重复增加,可能会造成中间某些选题未答直接跳到后面的答题，而添加一个name数组判断是否重复就可以避免该问题; 总结解决重复点击问题可以归结为标记作用位点，有两种方法: 点击触发请求后，作用点设为disabled属性，请求（或者包括请求后具体的业务流程处理）后，移除disabled属性； 记录作用点，判断作用点是否重复，重复则直接return 其实ajax还有一个更好的方法来避免重复提交,我们知道js是单线程执行事件的,所以可以根据此原理定义事件序列，重新封装ajax方法来避免。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/tags/JavaScript/"},{"name":"event","slug":"event","permalink":"http://blog.haohome.top/tags/event/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"Vuex入门基础","slug":"JavaScript/Vuex入门基础","date":"2018-05-13T16:00:00.000Z","updated":"2018-05-15T13:58:59.000Z","comments":true,"path":"2018/05/14/JavaScript/Vuex入门基础/","link":"","permalink":"http://blog.haohome.top/2018/05/14/JavaScript/Vuex入门基础/","excerpt":"1. Vuex 概念Vuex 是一个状态管理模式,它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是 store(仓库)，在store中包含组件中的共享状态state和改变状态的方法mutations。 store仓库 12345678910111213import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 1) Vuex 的状态存储是响应式的2) 不能直接改变 store 中的状态,需显式地提交 (commit) mutation","text":"1. Vuex 概念Vuex 是一个状态管理模式,它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是 store(仓库)，在store中包含组件中的共享状态state和改变状态的方法mutations。 store仓库 12345678910111213import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 1) Vuex 的状态存储是响应式的2) 不能直接改变 store 中的状态,需显式地提交 (commit) mutation 2. State单一状态树用一个对象包含全部的应用层级状态 Vuex 通过 store 选项，将状态从根组件“注入”到每一个子组件中,子组件需调用 Vue.use(Vuex)： 根组件: 123456//根组件:const app = new Vue(&#123; el: '#app', store, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 components: &#123; Counter &#125;,&#125;) 子组件: 通过computed(计算属性)返回this.$store.state.count来获取相应数据 1234567const Counter = &#123; computed: &#123; count () &#123; return this.$store.state.count //获取根组件的state &#125; &#125;&#125; mapState 辅助函数简化生成计算属性 1234567import &#123; mapState &#125; from 'vuex';export default &#123; computed: mapState (&#123; count: state =&gt; state.count, countAlias: 'count', // 别名 `count` 等价于 state =&gt; state.count &#125;)&#125; 还可以更简化: 1234computed: mapState([ // 映射 this.count 为 store.state.count 'count']) 3. Getter 从 store 中的 state 派生出状态如果我们需要对state对象进行做处理计算，如对列表进行过滤并计数: 12345computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; 如果多个组件都要进行这样的处理，那么就要在多个组件中复制该函数,这样效率低下。 Vuex中getters对象，可以方便我们在store中做集中的处理,Getters接受state作为第一个参数：: 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) Getter 会暴露为 store.getters 对象，可以以属性的形式访问这些值： 1store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125;] Getter 也可以接受其他 getter 作为第二个参数： 123456getters: &#123; doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125;store.getters.doneTodosCount // -&gt; 1 mapGetters辅助函数与mapState类似，都能达到简化代码的效果mapGetters辅助函数仅仅是将store中的getters映射到局部计算属性： 12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getters 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; 也可写作: 12345computed: mapGetters([ 'doneTodosCount', 'anotherGetter', // ...]) 所以在Vue的computed计算属性中会存在两种辅助函数： 123456789import &#123; mapState, mapGetters &#125; from 'vuex';export default &#123; // ... computed: &#123; mapState(&#123; ... &#125;), mapGetter(&#123; ... &#125;) &#125;&#125; 4. Mutation 更改 Vuex 的 store 中的状态每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler) 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; //type:'increment' // 变更状态 state.count++ &#125; &#125;&#125;) 要唤醒一个 mutation handler，你需要调用 store.commit 方法调用mutation type: store.commit(&#39;increment&#39;) 提交载荷（Payload） 向 store.commit 传入第二个参数,也就是mutation的payload: 123456mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125;store.commit('increment', 10) 单单传入一个n，可能并不能满足我们的业务需要，这时候我们可以选择传入一个payload对象： 12345mutation: &#123; increment (state, payload) &#123; state.totalPrice += payload.price + payload.count; &#125;&#125; 对象风格的提交方式提交 mutation 的另一种方式是直接使用包含 type 属性的对象： 1234store.commit(&#123; type: 'increment', amount: 10&#125;) mapMutations函数使用mapMutations辅助函数将组件中的methods映射为store.commit调用。 12345678910111213import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment' // 映射 this.increment() 为 this.$store.commit('increment') ]), ...mapMutations(&#123; add: 'increment' // 映射 this.add() 为 this.$store.commit('increment') &#125;) &#125;&#125; 5.Action Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 在vuex中,mutation是同步事件:store.commit(&#39;increment&#39;) 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 分发ActionAction 通过 store.dispatch 方法触发：store.dispatch(&#39;increment&#39;); Actions 支持同样的载荷方式和对象方式进行分发： 12345678910// 以载荷形式分发store.dispatch('incrementAsync', &#123; amount: 10&#125;)// 以对象形式分发store.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) 在组件中分发Action在组件中使用 this.$store.dispatch(&#39;xxx&#39;) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用 123456789101112131415import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125; 组合 ActionAction 通常是异步的，如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise： 12345678910actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125; 这样就可以: 123store.dispatch('actionA').then(() =&gt; &#123; // ...&#125;) 在另外一个 action 中也可以： 12345678actions: &#123; // ... actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125; 如果我们利用 async / await，我们可以如下组合 action： 1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) &#125;&#125; 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/tags/JavaScript/"},{"name":"vue","slug":"vue","permalink":"http://blog.haohome.top/tags/vue/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"Node.js的web服务器路由重构","slug":"JavaScript/Node.js的web服务器路由重构","date":"2018-05-02T15:32:00.000Z","updated":"2018-05-04T13:38:57.000Z","comments":true,"path":"2018/05/02/JavaScript/Node.js的web服务器路由重构/","link":"","permalink":"http://blog.haohome.top/2018/05/02/JavaScript/Node.js的web服务器路由重构/","excerpt":"Node使JavaScript操作服务器成为可能，同时其带来了强大的文件操作方法。我们在创建一个服务器时，会遇到路由切换的问题，当前express等库是可以识别不同路由并执行不同操作的，最近在回顾Node.js的一些用法，这里就尝试采用原生的方法重构一个路由功能。 原始路由方法： 12345678910111213141516171819const http=require('http');const fs=require('fs');let server=http.createServer(function(req,res)&#123; if(req.url=='/index')&#123; res.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是首页&lt;/h1&gt;') &#125;else if(req.url=='/products')&#123; res.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是产品页&lt;/h1&gt;') &#125;else if(req.url=='/detail')&#123; res.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是详情页&lt;/h1&gt;') &#125;else&#123; res.writeHead(404, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是404页&lt;/h1&gt;') res.end('欢迎来到NodeJs');&#125;)server.listen(3000);console.log('开始监听3000端口')","text":"Node使JavaScript操作服务器成为可能，同时其带来了强大的文件操作方法。我们在创建一个服务器时，会遇到路由切换的问题，当前express等库是可以识别不同路由并执行不同操作的，最近在回顾Node.js的一些用法，这里就尝试采用原生的方法重构一个路由功能。 原始路由方法： 12345678910111213141516171819const http=require('http');const fs=require('fs');let server=http.createServer(function(req,res)&#123; if(req.url=='/index')&#123; res.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是首页&lt;/h1&gt;') &#125;else if(req.url=='/products')&#123; res.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是产品页&lt;/h1&gt;') &#125;else if(req.url=='/detail')&#123; res.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是详情页&lt;/h1&gt;') &#125;else&#123; res.writeHead(404, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是404页&lt;/h1&gt;') res.end('欢迎来到NodeJs');&#125;)server.listen(3000);console.log('开始监听3000端口') 这样的路由方法看似结构清晰，但实际情况比这复杂的多，有大量的路由和相应的页面响应方法，就会显得臃肿了。 其实，我们可以采用ES6的模块语法，使创建服务器、路由控制、地址处理方法执行分别处于不同模块，最终在一个入口文件中引入： 服务器模块: 123456789101112131415const http=require('http');//1.http创建服务器并监听端口方法function startServer(route,handle)&#123; var onRequest=function(req,resp)&#123; //路由处理 route(handle,req.url,resp); &#125; //http创建服务器 var server= http.createServer(onRequest) //服务器监听3000端口 server.listen(3000,'127.0.0.1'); console.log('运行在3000端口');&#125;//2.导出路由模块module.exports.startServer = startServer; 地址处理方法: 123456789101112131415161718192021222324const fs=require('fs');//网站默认图标function favicon(resp)&#123; fs.createReadStream(__dirname +'/favicon.ico').pipe(resp);&#125;//首页function index(resp)&#123; fs.createReadStream(__dirname +'/index.html','utf8').pipe(resp);&#125;//产品页function products(resp)&#123; fs.createReadStream(__dirname +'/products.html','utf8').pipe(resp);&#125;//详情页function detail(resp)&#123; fs.createReadStream(__dirname +'/detail.html','utf8').pipe(resp);&#125;//将不同页面的方法导出module.exports=&#123; index:index, products:products, detail:detail, favicon:favicon&#125; 路由模块: 123456789101112const fs=require('fs');//1.路由处理方法function route(handle,url,resp)&#123; if(typeof handle[url] ==='function')&#123; resp.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); handle[url](resp); &#125;else&#123; resp.writeHead(404, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); fs.createReadStream(__dirname+'/404.html','utf8').pipe(resp); &#125;&#125;module.exports.route=route; 入口app.js 1234567891011121314var server=require('./server');var router=require('./router')var handler = require('./handler');//1.匹配url地址,var handle = &#123;&#125;;handle[\"/\"] = handler.index;handle['/index'] = handler.index;handle['/products'] = handler.products;handle['/detail'] = handler.detail;handle['/favicon.ico'] = handler.favicon;//2.启动服务器server.startServer(router.route,handle) 这样如果增加路由页面，只需在相应的位置依次增加即可，结构清晰！ 当使用GET或POST请求时，需要对服务器模块做一些更改: 请求为GET时,解析路由地址’?’后面的query语句; 请求为POST时,监听数据流并解析; 123456789101112131415161718192021222324252627282930const http=require('http');const url=require('url');const queryString=require('querystring');function startServer(route,handle)&#123; var onRequest=function(req,resp)&#123; //url路径 var pathName=url.parse(req.url).pathname; //请求为POST时,监听数据流 if(req.method==\"POST\")&#123; var data=\"\"; req.on('error',function(err)&#123; console.log(err); &#125;).on('data',function(chunk)&#123; data+=chunk; &#125;).on('end',function()&#123; var params=queryString.parse(data); route(handle,pathName,resp,params); &#125;) &#125; //请求为GET时,解析路由query else&#123; var params=url.parse(req.url,true).query; route(handle,pathName,resp,params); &#125; &#125; var server= http.createServer(onRequest) server.listen(3000,'127.0.0.1'); console.log('运行在3000端口');&#125;module.exports.startServer = startServer; 相应的，增加router和handler的传参。 详细代码：Demo-web","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"node","slug":"node","permalink":"http://blog.haohome.top/tags/node/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/tags/JavaScript/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"模拟jQuery的ajax方法封装","slug":"JavaScript/模拟jQuery的ajax方法封装","date":"2018-04-14T08:19:00.000Z","updated":"2018-04-15T05:55:55.000Z","comments":true,"path":"2018/04/14/JavaScript/模拟jQuery的ajax方法封装/","link":"","permalink":"http://blog.haohome.top/2018/04/14/JavaScript/模拟jQuery的ajax方法封装/","excerpt":"ajax在我们的前后端交互占据着重要的位置,前段时间在自己的小项目里模仿jQuery的模式封装了ajax请求的方法,但似乎没有达到满意的效果,同步异步实现并不是很满意,而且有一些局限性。感觉还是要单独拿出来记录，深入的去剖析ajax的原生封装更为妥当！ jQuery的常规ajax实现：123456789101112$.ajax(&#123; url:\"http://....\", method:\"GET\", data:&#123;&#125;, dataType:'json', success:function(resp,status)&#123; console.log(resp) &#125;, error:function(err)&#123; console.log(err) &#125;&#125;) 可以看到jQuery的ajax方法是$.ajax()传了一个对象参数。","text":"ajax在我们的前后端交互占据着重要的位置,前段时间在自己的小项目里模仿jQuery的模式封装了ajax请求的方法,但似乎没有达到满意的效果,同步异步实现并不是很满意,而且有一些局限性。感觉还是要单独拿出来记录，深入的去剖析ajax的原生封装更为妥当！ jQuery的常规ajax实现：123456789101112$.ajax(&#123; url:\"http://....\", method:\"GET\", data:&#123;&#125;, dataType:'json', success:function(resp,status)&#123; console.log(resp) &#125;, error:function(err)&#123; console.log(err) &#125;&#125;) 可以看到jQuery的ajax方法是$.ajax()传了一个对象参数。 ajax交互的四个基本步骤: 创建对象 创建请求xhr.open; 设置onreadystatechange，判断readyState以及status并接受响应 发送请求：xhr.send() 创建的对象obj需要包含url、method、data、dataType、success、error等属性 获得xhr对象: 判断请求方法是get还是post data参数处理 ajax请求状态判断,要考虑重定向的情况 获得响应数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var $=&#123; /*get方法传入data,返回一个拼接好的字符串uname=min&amp;age=12*/ params:function(data)&#123; var arr=[]; for(var key in data)&#123; arr.push(key+\"=\"+data[key])//将对象键值对以字符串形式存入数组中 &#125; var str=arr.join(\"&amp;\"); return str; &#125;, /*该方法发送http请求*/ ajax:function(obj)&#123; var url=obj.url; var type=obj.method || obj.type;//支持方法属性为method或type; var async=obj.async == undefined ? true : obj.async; var data = obj.data == undefined ? &#123;&#125; : obj.data; var success=obj.success; var error=obj.error; //创建一个XMLHttpRequest 对象 var xhr; if(window.XMLHttpRequest)&#123; xhr=new XMLHttpRequest(); &#125;else&#123; //微软IE浏览器的xhr对象 xhr=new ActiveXObject(\"MicroSoft.XMLHttp\") &#125;; //判断请求类型是\"get\"还是\"post\" if(type.toLowerCase()===\"get\")&#123; //get类型的url参数为拼接字符串 url=url+\"?\"+this.params(data); data=null; &#125;else&#123; //post类型要给服务器端一个请求头 xhr.setRequestHeader('Content-Type',\"application/x-www-form-urlencoded\") &#125; //创建请求 xhr.open(type,url,async); //当xhr的readyState发生改变时，要自动激发的操作 xhr.onreadystatechange=function()&#123; //返回的状态可能为200成功,也可能是304重定向 if(xhr.readyState==4 &amp;&amp; xhr.status==200 || xhr.status==304)&#123; var respData=xhr.responseText; success(data);// &#125;else&#123; error(); &#125; &#125; //xhr.send()方法要放在后面,这样xhr.onreadystatechange方法提前绑定监听xhr.readyState,同步请求才能拿到数据 xhr.send(data); //get类型data为null &#125;&#125; 以上有一点需要注意,就是xhr.send()方法一定要放在最后,这样xhr.onreadystatechange才能监听xhr的readyState变化,否则同步发送请求时不能监听xhr的readyState变化","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"ajax","slug":"ajax","permalink":"http://blog.haohome.top/tags/ajax/"},{"name":"jQuery","slug":"jQuery","permalink":"http://blog.haohome.top/tags/jQuery/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"跨域请求的jsonp处理","slug":"JavaScript/跨域请求的jsonp处理","date":"2018-04-06T16:00:00.000Z","updated":"2018-10-22T01:11:26.000Z","comments":true,"path":"2018/04/07/JavaScript/跨域请求的jsonp处理/","link":"","permalink":"http://blog.haohome.top/2018/04/07/JavaScript/跨域请求的jsonp处理/","excerpt":"跨域简介跨域是指不用域之间相互请求资源,只要协议，主机名，端口号，二级域名等不同都算跨域。 浏览器认为多数由js程序发起的跨域请求都是不合法的，主要为xhr，但不由js发起的跨域是允许的，包括：img，link，script，iframe；","text":"跨域简介跨域是指不用域之间相互请求资源,只要协议，主机名，端口号，二级域名等不同都算跨域。 浏览器认为多数由js程序发起的跨域请求都是不合法的，主要为xhr，但不由js发起的跨域是允许的，包括：img，link，script，iframe； JSONP JSON with Padding 填充式 json 正常的ajax请求是不允许跨域请求的，只能用允许跨域请求的元素script代替 处理步骤 客户端定义一个专门处理相应的有名函数doResponse(处理函数中仅接受并处理服务端json数据,不用xhr对象，更不用判断状态) 服务器端php: 接受请求数据并处理,返回一条js语句echo ‘doResponse($json)’; 动态创建一个script元素,设置src指向服务器端的php地址 客户端js: 12345678910function doResponse(resp)&#123; console.log(resp); for(var i in resp)&#123; console.log(i); &#125; &#125;$(\"#btn\").click(function() &#123; /*动态追加script元素*/ $(\"body\").append(`&lt;script src=\"http://127.0.0.1/jsonp.php?callback=doResponse\"&gt;&lt;\\/script&gt;`); &#125;); 也可以采用ajax获得返回数据 1234567891011$.getJSON(\"https://www.haohome.top/demo/jsonp.php?callback=doResponse\",data=&gt;&#123; console.log(data);&#125;);$.ajax(&#123; type:\"GET\", url:\"https://www.haohome.top/demo/jsonp.php?callback=doResponse\", success:data=&gt;&#123; console.log(\"返回数据\",data); &#125;, dataType:\"jsonp\"&#125;) 服务器端php: 1234header(\"Content-type:application/javascript;charset:utf-8\");$getData=$_GET['callback'];$hello=json_encode([1,2,3,4]);echo $getData.\"('$hello')\"; ​","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"http","slug":"http","permalink":"http://blog.haohome.top/tags/http/"},{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"},{"name":"web","slug":"web","permalink":"http://blog.haohome.top/tags/web/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"创建对象的Object.create与new","slug":"JavaScript/创建对象的Object.create与new","date":"2018-04-06T16:00:00.000Z","updated":"2018-04-10T05:53:47.000Z","comments":true,"path":"2018/04/07/JavaScript/创建对象的Object.create与new/","link":"","permalink":"http://blog.haohome.top/2018/04/07/JavaScript/创建对象的Object.create与new/","excerpt":"创建对象有几种方式: 直接量: 123var obj1=&#123;name:\"xiaowang\"&#125;;var obj2=new Object(&#123;name:\"xiaowang\"&#125;);console.log(obj1,obj2); 构造函数: 123var M=function(name)&#123;this.name=name&#125;;var obj3=new M('xiaowang');console.log(obj3); Object.create 123var p=&#123;name:'xiaowang'&#125;;var obj4=Object.create(p);console.log(obj4); 对应的输出结果为:","text":"创建对象有几种方式: 直接量: 123var obj1=&#123;name:\"xiaowang\"&#125;;var obj2=new Object(&#123;name:\"xiaowang\"&#125;);console.log(obj1,obj2); 构造函数: 123var M=function(name)&#123;this.name=name&#125;;var obj3=new M('xiaowang');console.log(obj3); Object.create 123var p=&#123;name:'xiaowang'&#125;;var obj4=Object.create(p);console.log(obj4); 对应的输出结果为: 可以看到,Object.create方法得到的对象是空对象，再输出各自对象的name属性看看: console.log(obj2.name,obj3.name,obj4.name) 得到的结果为xiaowang xiaowang xiaowang 这是为什么??? Object.create 的实现方式: 1234567var obj1 = Object.create(null);console.log(obj1); // &#123;&#125;obj1.name = 'jian';var obj2 = Object.create(obj1);console.log(obj2); // &#123;&#125;console.log(obj2.name); // 'jian', conosle.log(obj2.__proto__===obj1.prototype) //true obj2是空对象,但obj2.name输出了’jian’,obj2继承自obj1的原型对象 由此可以总结Object.create()做了： ​ 1. 创建空对象{} ​ 2. 指定空对象{}继承自参数的原型对象,即空对象的 __proto__ 指向Object.create()参数的原型对象。 var obj1=new M({name:&#39;xiaowang&#39;}) 的实现方式: 123456789101112//定义构造函数Person var Person = function (name) &#123; this.name = firstName;&#125;;//定义Person原型对象的新方法Person.prototype.sayHello = function() &#123; console.log(\"Hello, I'm \" + this.name);&#125;;//实例化对象var person1 = new Person(\"Alice\");//对象调用methodperson1.sayHello(); // logs \"Hello, I'm Alice\" 由此可以总结new做了： 创建实例对象person1 调用构造函数(Person)初始化person1成员变量（name)。 指定实例对象的继承自Person.prototype对象。即person1.__proto__指向构造函数的原型对象Person.prototype。 对比 Object.create new 创建对象 创建空对象 创建实例对象,并将参数初始化赋值 继承 空对象继承自参数对象的原型对象,本身为空对象 实例对象继承自构造函数的原型对象 总结:Object.create得到的对象未实例化,本身为空对象,可继承对象,而new得到的对象是实例化的对象","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"},{"name":"对象","slug":"对象","permalink":"http://blog.haohome.top/tags/对象/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"浏览器缓存问题","slug":"HTML5&CSS/浏览器缓存问题","date":"2018-03-28T16:06:25.000Z","updated":"2018-10-22T01:13:14.000Z","comments":true,"path":"2018/03/29/HTML5&CSS/浏览器缓存问题/","link":"","permalink":"http://blog.haohome.top/2018/03/29/HTML5&CSS/浏览器缓存问题/","excerpt":"请求缓存的路线图: 两个概念 强缓存用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。 协商缓存用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源。 共同点: 客户端获得的数据最后都是从客户端缓存中获得 区别: 强缓存不与服务器交互，而协商缓存则需要与服务器交互。","text":"请求缓存的路线图: 两个概念 强缓存用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。 协商缓存用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源。 共同点: 客户端获得的数据最后都是从客户端缓存中获得 区别: 强缓存不与服务器交互，而协商缓存则需要与服务器交互。 四个过程详解（a）浏览器判定是否有缓存所谓“客户端缓存”就是指用户设备中本地资源。不同浏览器缓存文件的地址也不尽相同。 对于一个html页面，缓存分3部分，一个是页面内容，一个是css样式，一个是JS文件 我们以chrome为例来查看下浏览器缓存文件的地址，1）首先在chrome中输入：chrome://chrome-urls/，看到一堆列表,里面隐藏了许多浏览器的奥秘，有兴趣的可以自己深扒。2）找到 chrome://cache（当然也可以直接输入这个地址） （b）缓存是否过期 expires Http1.0 中的标准，表明过期时间，注意此处的时间都是指的是服务器的时间。 存在的问题：服务器时间与客户端时间的不一致，就会导致缓存跟期待效果出现偏差。 Cache-ControlHttp1.1 中的标准，可以看成是 expires 的补充。使用的是相对时间的概念。Cache-Control的属性: 1）max-age: 设置缓存的最大的有效时间，单位为秒（s）。max-age会覆盖掉Expires 2) s-maxage: 只用于共享缓存，比如CDN缓存（s -&gt; share）。与max-age 的区别是：max-age用于普通缓存，而s-maxage用于代理缓存。如果存在s-maxage,则会覆盖max-age 和 Expires. 3) public：响应会被缓存，并且在多用户间共享。默认是public。 4) private: 响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。 5）no-cache: 指定不缓存响应，表明资源不进行缓存。但是设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。 6）no-store: 绝对禁止缓存。 7）must-revalidate: 如果页面过期，则去服务器进行获取。 所以判断缓存是否过期步骤是：1） 查看是否有cache-control 的max-age / s-maxage , 如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期2）查看是否有cache-control 的max-age / s-maxage，则用expires 作为过期时间比较 总结：（b）过程执行完后，如果判定为未过期，则使用客户端缓存。那么就是属于“强缓存”。 （c）跟服务器协商是否使用缓存 到这一步的时候，浏览器会向服务器发送请求，同时如果上一次的缓存中有Last-modified 和 Etag 字段，浏览器将在request header 中加入If-Modified-Since（对应于Last-modified）， 和If-None-Match（对应于Etag）。 Last-modified: 表明请求的资源上次的修改时间。 If-Modified-Since：客户端保留的资源上次的修改时间。 Etag：资源的内容标识。（不唯一，通常为文件的md5或者一段hash值，只要保证写入和验证时的方法一致即可） If-None-Match： 客户端保留的资源内容标识。 1） 分布式系统尽量关闭Etag，因为每台机器生成的Etag都不一样。2）分布式系统里多台机器间文件的Last-Modified必须一致，以免负载均衡不同导致对比失败。 通常情况下，如果同时发送 If-None-Match 、If-Modified-Since字段，服务器只要比较etag 的内容即可，当然具体处理方式，看服务器的约定规则。 （d）协商缓存在这个阶段，服务器一般会将Cache-control、expires 、last-modified、date、etag 等字段在response header 中返回，便于下次缓存。当然具体的场景，也是看服务器的约定规则设定。 缓存的不同来源from disk cache从磁盘中获取缓存资源，等待下次访问时不需要重新下载资源，而直接从磁盘中获取。它的直接操作对象为CurlCacheManager。 from memory cache从内存中获取资源，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。目前Webkit资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类： MainResourceLoader和SubresourceLoader。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，JS等），以及解码过的图片数据。 区别当退出进程时，内存中的数据会被清空，而磁盘的数据不会，所以，当下次再进入该进程时，该进程仍可以从diskCache中获得数据，而memoryCache则不行。 相似diskCache与memoryCache相似之处就是也只能存储一些派生类资源文件。它的存储形式为一个index.dat文件，记录存储数据的url，然后再分别存储该url的response信息和content内容。Response信息最大作用就是用于判断服务器上该url的content内容是否被修改。 用户行为 解决方案:1、页面内容 2、CSS和JS文件 改成 就是只要在每次修改后改一下版本号即可 这样每次修改后都要改，有没有自动加版本号的东西，估计有，如果是JSP和php可以通过脚本自动生成，如果是纯html也可以通过document.write，或者用动态加载JS的框架啥的。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}],"tags":[{"name":"http","slug":"http","permalink":"http://blog.haohome.top/tags/http/"}],"keywords":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}]},{"title":"通俗易懂的原型与原型链","slug":"JavaScript/通俗易懂的原型与原型链","date":"2018-03-11T13:23:00.000Z","updated":"2018-04-10T05:53:47.000Z","comments":true,"path":"2018/03/11/JavaScript/通俗易懂的原型与原型链/","link":"","permalink":"http://blog.haohome.top/2018/03/11/JavaScript/通俗易懂的原型与原型链/","excerpt":"普通对象与函数对象123456789101112131415var o1 = &#123;&#125;; var o2 =new Object();var o3 = new f1();function f1()&#123;&#125;; var f2 = function()&#123;&#125;;var f3 = new Function('str','console.log(str)');console.log(typeof Object); //function console.log(typeof Function); //function console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function console.log(typeof o1); //object console.log(typeof o2); //object console.log(typeof o3); //object 上面的例子中: o1、o2、o3都是普通对象object，而f1、f2、f3是函数对象function 凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1、f2归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。","text":"普通对象与函数对象123456789101112131415var o1 = &#123;&#125;; var o2 =new Object();var o3 = new f1();function f1()&#123;&#125;; var f2 = function()&#123;&#125;;var f3 = new Function('str','console.log(str)');console.log(typeof Object); //function console.log(typeof Function); //function console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function console.log(typeof o1); //object console.log(typeof o2); //object console.log(typeof o3); //object 上面的例子中: o1、o2、o3都是普通对象object，而f1、f2、f3是函数对象function 凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1、f2归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。 构造函数12345678function Student(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.intr = function() &#123; console.log(this.name+\"年龄是\"+this.age) &#125; &#125;var lilei = new Student('lilei', 28, 'Software Engineer');var hmm = new Student('hmm', 23, 'Doctor'); 这个例子中lilei、hmm都是构造函数Student的实例 原型对象JavaScript中,每定义一个对象,对象中都会包含一些预定义的属性,每个普通对象和函数对象都包含__proto__ ，而每个函数对象都会有prototype 属性，指向函数的原型对象; 看一个简单示意图: 例子中,Student 是构造函数(昵称”妈”),其prototype(原型对象)就是Student.prototype (昵称”爹”)，原型对象(爹)的构造函数属性(妈)是构造函数，而lilei和hmm都是构造函数Student(妈)的实例(儿子/女儿)，儿子/女儿都继承(__proto__)了爹，遗传了爹的方法和属性，用公式表示即： 12Student===Student.prototype.constructor; //truelilei.__proto__===Student.prototype; //true 构造函数具有prototype 属性，指向原型对象 原型对象具有constructor 属性，指向构造函数 实例对象具有__protot__ 属性，指向原型对象 从 ECMAScript 6 开始，[[Prototype]] 可以通过Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 __proto__。 原型对象其实就是普通对象，但Function.prototype除外，它是函数对象，且没有prototype属性(前面说函数对象具有prototype属性) 123456function Student()&#123;&#125;; console.log(Student.prototype) //Student&#123;&#125; 空对象,具有constructor属性 console.log(typeof Student.prototype) //object console.log(typeof Function.prototype) // function，这个特殊 console.log(typeof Object.prototype) // object console.log(typeof Function.prototype.prototype) //undefined 原型对象的应用原型对象的应用主要就是继承 12345678910var Student = function(name)&#123; this.name = name; // tip: 当函数执行时这个 this 指该构造函数的实例 &#125;;/*给Student添加getName方法*/ Student.prototype.getName = function()&#123; return this.name; // tip: 当函数执行时这个 this 指该构造函数的实例 &#125; var lilei = new Student('lilei'); console.log(lilei.name); //'lilei' 此时 lilei 已经有 name 这个属性了 console.log(lilei.getName()); //lilei 原型链 12345lilei.__proto__ 是Student.prototypeStudent.__proto__ 是Function.prototypeStudent.prototype.__proto__ 是Object.prototypeObject.__proto__ 是Function.prototype,Object也是构造函数Object.prototype__proto__ 是null 函数对象所有的函数对象的__proto__ 都指向Function.prototype ,它是一个空函数 12345678910111213141516171819202122232425Number.__proto__ === Function.prototype // trueNumber.constructor == Function //trueBoolean.__proto__ === Function.prototype // trueBoolean.constructor == Function //trueString.__proto__ === Function.prototype // trueString.constructor == Function //true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Object.__proto__ === Function.prototype // trueObject.constructor == Function // true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Function.__proto__ === Function.prototype // trueFunction.constructor == Function //trueArray.__proto__ === Function.prototype // trueArray.constructor == Function //trueRegExp.__proto__ === Function.prototype // trueRegExp.constructor == Function //trueError.__proto__ === Function.prototype // trueError.constructor == Function //trueDate.__proto__ === Function.prototype // true JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的__proto__ 是Object.prototype。如下 12345Math.__proto__ === Object.prototype // trueMath.construrctor == Object // trueJSON.__proto__ === Object.prototype // trueJSON.construrctor == Object //true 本文借鉴了 Yi罐可乐: 最详尽的 JS 原型与原型链终极详解，没有「可能是」","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"},{"name":"原型","slug":"原型","permalink":"http://blog.haohome.top/tags/原型/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"原生JS实现瀑布流效果","slug":"JavaScript/原生js实现瀑布流效果","date":"2018-03-09T16:00:00.000Z","updated":"2019-01-28T06:35:05.704Z","comments":true,"path":"2018/03/10/JavaScript/原生js实现瀑布流效果/","link":"","permalink":"http://blog.haohome.top/2018/03/10/JavaScript/原生js实现瀑布流效果/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @name:瀑布流 * @param:parent(容器元素) * @param:oneGap(只有一列时元素的间距,其他列数自适应) * @description:自适应瀑布流,多列间距自适应 */ waterFall: function (parent, oneGap = 0, padding = 0) &#123; /**容器的宽度(包含内边距、边框) */ var width = parent.offsetWidth - padding; /**容器内盒子元素的宽度(包含内边距、边框) */ var items = parent.children; var itemWidth = items[0].offsetWidth; /* 所有空隙的宽度和*/ var gap = (width - parseInt(width / itemWidth) * itemWidth); /**计算每列放的盒子元素个数 */ var columns = parseInt(width / (itemWidth + gap / 2)); /**定义一个空数组,用来储存每列元素的高度 */ var arr = []; for (var i = 0; i &lt; items.length; i++) &#123; /**1.将第一行元素的高度都存到arr中 */ if (i &lt; columns) &#123; items[i].style.top = padding + 'px'; items[i].style.left = (itemWidth + gap) * i + padding - padding * (i % 2) + 'px'; arr.push(items[i].offsetHeight); &#125; else &#123; /**2.找到每一行的最小高度 */ var minHeight = arr[0]; var index = 0; for (var j = 0; j &lt; arr.length; j++) &#123; if (minHeight &gt; arr[j]) &#123; minHeight = arr[j]; //获得当前行最小高度 index = j; //记下当前列下标 &#125; &#125; /**3.设置下一行第一个盒子的位置, * top值就是最小高度值+gap * left值就是最小列距离左边的距离 */ if (gap != 0) &#123; items[i].style.top = arr[index] + oneGap + padding + 'px'; items[i].style.left = items[index].offsetLeft + 'px'; /**4.修改最小列的高度 * 最小列的高度 = 当前自己的高度 + 拼接过来的高度 + 间隙的高度 */ arr[index] = arr[index] + items[i].offsetHeight + oneGap; &#125; else &#123; items[i].style.top = arr[index] + oneGap + padding + 'px'; items[i].style.left = padding + 'px'; arr[index] = arr[index] + items[i].offsetHeight + oneGap; &#125; &#125; if (columns === 1) &#123; parent.style.height = arr[0] + oneGap + 'px' &#125; else &#123; var height = arr[0] &gt; arr[1] ? arr[0] : arr[1] if (i &lt; items.length - 1) &#123; parent.style.height = height + oneGap + padding + 'px' &#125; else &#123; parent.style.height = height + padding * 2 + 'px' &#125; &#125; &#125; &#125;,","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"利用H5画随机色圆","slug":"HTML5&CSS/利用H5画随机色圆","date":"2018-03-06T14:42:54.000Z","updated":"2018-04-10T05:53:46.000Z","comments":true,"path":"2018/03/06/HTML5&CSS/利用H5画随机色圆/","link":"","permalink":"http://blog.haohome.top/2018/03/06/HTML5&CSS/利用H5画随机色圆/","excerpt":"忽然想到曾经遇到的一个案例： ​ 在页面上绘制随机数量的圆并填充随机色，但鼠标点击圆时该圆逐渐放大，同时透明度降低，直至消失。 在这里用代码重现下，首先分析下需求： 绘制页面： 生成随机数，根据随机数生成随机颜色 利用svg绘图技术在页面绘制随机数量的圆 将圆填充随机色 JS事件： 为每个圆绑定单击事件 创建定时器","text":"忽然想到曾经遇到的一个案例： ​ 在页面上绘制随机数量的圆并填充随机色，但鼠标点击圆时该圆逐渐放大，同时透明度降低，直至消失。 在这里用代码重现下，首先分析下需求： 绘制页面： 生成随机数，根据随机数生成随机颜色 利用svg绘图技术在页面绘制随机数量的圆 将圆填充随机色 JS事件： 为每个圆绑定单击事件 创建定时器 代码： 生成随机数和随机颜色方法 12345678910111213/*获取指定范围内的随机数字*/function randomNum(min,max)&#123; var n=Math.random()*(max-min)+min; return Math.floor(n)&#125;/*生成随机色*/function randomColor(min,max)&#123; var r=randomNum(min,max); var g=randomNum(min,max); var b=randomNum(min,max); var a=Math.random(); return `rgba($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;,$&#123;a&#125;)`;&#125; 利用svg绘图 html: 1&lt;svg id=\"svg\" width=\"1000px\" height=\"500px\"&gt;&lt;/svg&gt; JavaScript: 123456789101112131415161718192021222324252627282930var svg=document.getElementById(\"svg\"); for(var i=0;i&lt;50;i++)&#123; //创建圆元素 var c=document.createElementNS(\"http://www.w3.org/2000/svg\",\"circle\"); c.setAttribute(\"r\",randomNum(10,80)); c.setAttribute(\"cx\",randomNum(0,800)); c.setAttribute(\"cy\",randomNum(0,400)); c.setAttribute(\"fill\",randomColor(0,255)); c.setAttribute(\"fill-opacity\",Math.random()); svg.appendChild(c) //绑定单击事件 c.onclick=function()&#123; var that=this; //设置循环定时器 var timer=setInterval(function()&#123; var r=that.getAttribute(\"r\"); r*=1.05; that.setAttribute(\"r\",r); var fillOpac=that.getAttribute(\"fill-opacity\"); fillOpac*=0.9; that.setAttribute(\"fill-opacity\",fillOpac); //设置循环定时器停止条件 if(fillOpac&lt;0.001)&#123; clearInterval(timer); timer=null; svg.removeChild(that); &#125; &#125;,20)() &#125;&#125; 附上codePen链接 效果图:","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/tags/HTML5/"},{"name":"css3","slug":"css3","permalink":"http://blog.haohome.top/tags/css3/"}],"keywords":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}]},{"title":"一道简单的setTimeout面试题","slug":"JavaScript/一道简单的JavaScript面试题","date":"2018-03-05T15:48:00.000Z","updated":"2018-10-22T01:12:12.000Z","comments":true,"path":"2018/03/05/JavaScript/一道简单的JavaScript面试题/","link":"","permalink":"http://blog.haohome.top/2018/03/05/JavaScript/一道简单的JavaScript面试题/","excerpt":"这是一道很入门的js面试题，考察JavaScript的单线程事件执行机制: 12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(i) //10*10 &#125;, 10 * i)&#125; 不理解原因的可能会认为输出0,1,2,3,4,5,6,7,8,9。事实并不是这样，原因很简单： 先看下JavaScript的单线程和异步： JS是单线程语言，浏览器只分配给JS一个主线程用来执行任务（函数）； 任务一次只能一次，任务会形成队列排队执行； 浏览器会为setTimeout（定时器，异步）单独开一个线程，异步任务完成后会触发回调函数，这时就把回调函数放到主线程任务队列等待执行","text":"这是一道很入门的js面试题，考察JavaScript的单线程事件执行机制: 12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(i) //10*10 &#125;, 10 * i)&#125; 不理解原因的可能会认为输出0,1,2,3,4,5,6,7,8,9。事实并不是这样，原因很简单： 先看下JavaScript的单线程和异步： JS是单线程语言，浏览器只分配给JS一个主线程用来执行任务（函数）； 任务一次只能一次，任务会形成队列排队执行； 浏览器会为setTimeout（定时器，异步）单独开一个线程，异步任务完成后会触发回调函数，这时就把回调函数放到主线程任务队列等待执行 具体到例子： js没有块级作用域，for循环中i提升为全局变量； setTimeout是异步执行，而for循环为同步执行，每执行一次for循环，setTimeout执行一次，触发一次回调函数； for循环已经执行完时setTimeout内部回调函数开始，i值为10，故最后连续输出10个10 如果需要输出连续数字，则需要采用闭包或ES6语法中的let 123456789101112131415// 闭包for (var i = 0; i &lt; 10; i++) &#123; void function (j) &#123; setTimeout(function () &#123; console.log(j) &#125;, 10 * j) &#125;(i)&#125;// letfor (let i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 10 * i)&#125; 闭包： JavaScript的函数会形成作用域，闭包就是记住变量不受污染 i作为参数传入匿名函数被记住 let： 在{ }内形成块级作用域； 生成不同的i实例，形成一个匿名函数自调，类似于闭包","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"面试","slug":"面试","permalink":"http://blog.haohome.top/tags/面试/"},{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"},{"name":"events","slug":"events","permalink":"http://blog.haohome.top/tags/events/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"闭包与模块","slug":"JavaScript/闭包与模块","date":"2018-03-01T03:30:00.000Z","updated":"2018-04-06T18:25:12.000Z","comments":true,"path":"2018/03/01/JavaScript/闭包与模块/","link":"","permalink":"http://blog.haohome.top/2018/03/01/JavaScript/闭包与模块/","excerpt":"什么是闭包闭包是有重用机制，同时保护变量不被污染的一种机制 变量类型 优点 缺点 全局变量 可重用 污染/随处可用 局部变量 仅作用域内部可用,不会污染不可重用全局 不可重用 闭包在需要重用一个变量，又需要保护变量不被污染的情况时使用 即使函数已经完成了运行，它依然可以“记住”并持续访问函数的作用域。","text":"什么是闭包闭包是有重用机制，同时保护变量不被污染的一种机制 变量类型 优点 缺点 全局变量 可重用 污染/随处可用 局部变量 仅作用域内部可用,不会污染不可重用全局 不可重用 闭包在需要重用一个变量，又需要保护变量不被污染的情况时使用 即使函数已经完成了运行，它依然可以“记住”并持续访问函数的作用域。 123456function makeAdder(x) &#123; // 参数x是一个内部变量 function add(y) &#123; // 内部函数add()使用x，所以它对x拥有一个“闭包” return y + x; &#125;; return add;&#125; 每次调用makeAdder(...) 所对应的add(...) 函数引用都会记住被传入makeAdder() 的参数X 12345var plusOne = makeAdder( 1 ); //plusOne得到一个指向内部函数add(..)的引用,add()函数拥有对外部makeAdder(..)的参数x的闭包,相当于add()中x=2var plusTen = makeAdder( 10 ); //相当于add()中x=10plusOne( 3 ); //调用add()方法,y=3,返回值为4plusOne( 41 ); //调用add()方法,y=41,返回值为42plusTen( 13 ); //x=10,调用add()方法,y=13,返回值为23 这段代码的工作机制: 当调用makeAdder(1)时,会得到返回的内部函数add(),该函数引用了参数x为1并记住了1; 将调用返回的函数引用为plusOne; 当调用plusOne(3)时,它会在传入参数y为3的基础上加上记住的x为1，结果为4； 实现闭包的三个步骤： 用外层函数包裹要保护的变量和操作变量的函数 外层函数将内层函数的对象返回到外部 使用者调用外层函数,获得内层函数对象 闭包形成原因：外层函数的作用域对象(AO)无法释放,被内层函数对象引用着 模块模块是闭包中最常见的用法，模块让你定义对外面世界不可见的私有实现细节（变量，函数），和暴露给外面可访问的公有API。 12345678910111213function User()&#123; var username, password; function doLogin(user,pw) &#123; //登录的方法 username = user; password = pw; &#125; var publicAPI = &#123; //需要暴露给外面的API login: doLogin &#125;; return publicAPI; //将API暴露出来&#125;var fred = User(); // 创建一个 `User` 模块的实例fred.login( \"fred\", \"12Battery34!\" ); 工作机制: 接口 publicAPI是一个带有一个属性/方法的对象，login是一个指向内部doLogin()函数的引用 方法User() 内部包含两个局部作用域变量username和password，私有的doLogin()方法接受从API传入的两个参数值,并赋值给相应的username和password 执行User()创建了User模块的一个 实例 —— 一个全新的作用域会被创建，而每个内部变量/函数因此被创建新的副本。将这个实例赋值给fred 如果再次运行User() ，将会得到一个与fred完全分离的新实例； 当User() 函数执行完，username 和password 这样的内部变量不会消失，因为login() 函数里有一个闭包保护变量","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"},{"name":"function","slug":"function","permalink":"http://blog.haohome.top/tags/function/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"flex弹性布局","slug":"HTML5&CSS/Flex布局","date":"2018-02-25T12:30:54.000Z","updated":"2018-10-22T01:13:47.000Z","comments":true,"path":"2018/02/25/HTML5&CSS/Flex布局/","link":"","permalink":"http://blog.haohome.top/2018/02/25/HTML5&CSS/Flex布局/","excerpt":"flex布局是什么Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为flex布局,包括行内元素 123456.box&#123; display: flex;&#125;.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。","text":"flex布局是什么Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为flex布局,包括行内元素 123456.box&#123; display: flex;&#125;.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 基础概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性有六个属性设置在容器上: flex-direction flex-wrap flex-flow : flex-direction和flex-wrap的简写 .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;} 默认值为row nowrap justify-content align-items align-content 1. flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 2. flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap wrap wrap-reverse 3. justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 4. align-items属性align-items属性定义项目在交叉轴上对齐方式。 可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 5. align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 可能取6个值: flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 1234&gt; .box &#123;&gt; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&gt; &#125;&gt; 项目的属性6个属性设置在项目上(子元素); order flex-grow flex-shrink flex-basis flex: 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self 1. order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; 2. flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3. flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 4. flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本身大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它也可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 5. align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 1234.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch; /*除了auto，其他都与align-items属性完全一致*/&#125; 应用实例骰子","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.haohome.top/tags/css/"},{"name":"flex","slug":"flex","permalink":"http://blog.haohome.top/tags/flex/"}],"keywords":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}]},{"title":"JS数组以及对象的深拷贝","slug":"JavaScript/javascript 数组以及对象的深拷贝","date":"2018-02-21T16:00:00.000Z","updated":"2018-04-10T08:27:10.000Z","comments":true,"path":"2018/02/22/JavaScript/javascript 数组以及对象的深拷贝/","link":"","permalink":"http://blog.haohome.top/2018/02/22/JavaScript/javascript 数组以及对象的深拷贝/","excerpt":"转载自 csdn博客 FengCms FungLeo 博客:原文链接 前言在js中，数组和对象的复制如果使用=号来进行复制，那只是浅拷贝。如下图演示：如上，arr的修改，会影响arr2的值，这显然在绝大多数情况下，并不是我们所需要的结果。因此，数组以及对象的深拷贝就是javascript的一个基本功了。 数组的深拷贝条条大道通罗马，实现数组的深拷贝，是有好几种方法的。举例如下：","text":"转载自 csdn博客 FengCms FungLeo 博客:原文链接 前言在js中，数组和对象的复制如果使用=号来进行复制，那只是浅拷贝。如下图演示：如上，arr的修改，会影响arr2的值，这显然在绝大多数情况下，并不是我们所需要的结果。因此，数组以及对象的深拷贝就是javascript的一个基本功了。 数组的深拷贝条条大道通罗马，实现数组的深拷贝，是有好几种方法的。举例如下： for 循环实现数组的深拷贝for循环是非常好用的。如果不知道高级方法，通过for循环能够完成我们大多数的需求。 123456789var arr = [1,2,3,4,5]var arr2 = copyArr(arr)function copyArr(arr) &#123; let res = [] for (let i = 0; i &lt; arr.length; i++) &#123; res.push(arr[i]) &#125; return res&#125; 如上，通过对数组的for循环，即可实现对数组的深拷贝了。 slice 方法实现数组的深拷贝这个代码实现非常简单。原理也比较好理解，他是将原数组中抽离部分出来形成一个新数组。我们只要设置为抽离全部，即可完成数组的深拷贝。代码如下： 12345var arr = [1,2,3,4,5]var arr2 = arr.slice(0)arr[2] = 5console.log(arr)console.log(arr2) 运行结果如下：更多 slice 内容请访问 w3school JavaScript slice 方法 concat 方法实现数组的深拷贝这个代码也非常简单，原理更加粗暴。它是用于连接多个数组组成一个新的数组的方法。那么，我们只要连接它自己，即可完成数组的深拷贝。代码如下： 12345var arr = [1,2,3,4,5]var arr2 = arr.concat()arr[2] = 5console.log(arr)console.log(arr2)//12345 运行结果如下：更多 concat 内容请访问 w3school JavaScript concat 方法 2017年10月31日补充：ES6扩展运算符实现数组的深拷贝OK，以上之前讲的方法全部过时了，用下面的方法实现数组的深拷贝是最简单的。 12345var arr = [1,2,3,4,5]var [ ...arr2 ] = arrarr[2] = 5console.log(arr)console.log(arr2)12345 运行结果如下： 对象的深拷贝对象的深拷贝相比数组也没有困难许多，列举两个方法。 万能的for循环实现对象的深拷贝在很多时候，for循环能够解决大问题。 12345678910111213var obj = &#123; name: 'FungLeo', sex: 'man', old: '18'&#125;var obj2 = copyObj(obj)function copyObj(obj) &#123; let res = &#123;&#125; for (var key in obj) &#123; res[key] = obj[key] &#125; return res&#125; 转换成json再转换成对象实现对象的深拷贝上面的代码实在是比较长，所以，用一个更暴力的方法吧！代码如下： 123456var obj = &#123; name: 'FungLeo', sex: 'man', old: '18'&#125;var obj2 = JSON.parse(JSON.stringify(obj)) 这个原理没什么好解释的，实在是够简单粗暴的啦！ 2017年10月31日补充： 扩展运算符实现对象的深拷贝123456789var obj = &#123; name: 'FungLeo', sex: 'man', old: '18'&#125;var &#123; ...obj2 &#125; = objobj.old = '22'console.log(obj)console.log(obj2) 运行结果如下： 小结数组和对象的深拷贝是js中最常见的应用。理解各种方法是必须的。希望对大家有所帮助。本文中并没有对异常进行处理，主要在讲原理。更多的数组以及对象的操作方法，可以参考lodash的源码，查看它的源码可以让你的js基础变得非常牢固。我也在学习中。 2017年10月31日补充，使用es6提供的扩展运算符的方法实现深拷贝，简单，高效。并且，对象的深拷贝不会像使用 JSON 方法深拷贝一样，丢失函数等信息，只能用来深拷贝 JSON 数据格式的对象。推荐大家使用。 补充一个数组去重的方法12345function dedupe(array) &#123; return [...new Set(array)]&#125;var arr = [1,2,2,3,3,4,4,5,5]console.log(dedupe(arr)) //[1, 2, 3, 4, 5]","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"},{"name":"数组","slug":"数组","permalink":"http://blog.haohome.top/tags/数组/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"Viewport剖析","slug":"HTML5&CSS/viewports剖析","date":"2018-02-20T08:00:00.000Z","updated":"2018-10-22T01:13:50.000Z","comments":true,"path":"2018/02/20/HTML5&CSS/viewports剖析/","link":"","permalink":"http://blog.haohome.top/2018/02/20/HTML5&CSS/viewports剖析/","excerpt":"转载自W3CPlus创始人 大漠 博客:原文链接 1. 桌面（pc）浏览器1.1 设备的pixels和CSS的pixelspixels决定了你工作所用的那些设备上正式的分辨率。在大多数情况下，能够从screen.width/height上取出具体值 如果用户缩放（zoom）了浏览器，当然必须改变计算方式。 现代浏览器上的缩放，是基于“伸展”pixels。结果是，html元素上的宽度并没有因为缩放200%而由128pix变成256px，而是真实的pixels的被计算成了双倍。html元素在形式上依然是128CSS的pixels，即便它占用了256设备的pixels 。","text":"转载自W3CPlus创始人 大漠 博客:原文链接 1. 桌面（pc）浏览器1.1 设备的pixels和CSS的pixelspixels决定了你工作所用的那些设备上正式的分辨率。在大多数情况下，能够从screen.width/height上取出具体值 如果用户缩放（zoom）了浏览器，当然必须改变计算方式。 现代浏览器上的缩放，是基于“伸展”pixels。结果是，html元素上的宽度并没有因为缩放200%而由128pix变成256px，而是真实的pixels的被计算成了双倍。html元素在形式上依然是128CSS的pixels，即便它占用了256设备的pixels 。 有4个1像素，缩放为100%的html元素，CSS的pixels完整的和设备的pixels重叠: 当我们缩小浏览器时，CSS的pixels开始收缩，导致1单位的设备的pixels上重叠了多个CSS的pixels 同理，放大浏览器时，相反的事情发生了，CSS的pixels开始扩大，导致1单位的CSS的pixels上重叠了多个设备的pixels 你只需要关注CSS的pixels，这些pixels指定你的样式被如何渲染. 1.2 100% 缩放在缩放级别为100%时，1单位的CSS的pixel是严格相等于1单位的设备pixel，通常会在100%缩放级别下测试网站 1.2.1 屏幕尺寸 Screen size 含义：用户的屏幕的完整大小。这两个属性包含了用户屏幕的完整宽度/高度,尺寸使用设备的pixels来定义，他们的值不会因为缩放而改变(显示器的特征，而不是浏览器) 度量：设备的pixels,screen.width/height (基本无用) 兼容性问题：IE8里，不管使用IE7模式还是IE8模式，都以CSS的pixels来度量 1.2.2 浏览器尺寸 Window size 含义：包含滚动条尺寸的浏览器完整尺寸; 想要知道的浏览器的内部尺寸。它定义了当前用户有多大区域，可供你的CSS布局占用度量：CSS的pixels, window.innerWidth/Height兼容性问题：IE不支持，Opera用设备pixels来度量 1.2.3 滚动移位 Scrolling offset 含义：页面的移位 , 定义了页面(document)的相对于窗口原点的水平、垂直位移。因此你能够定位用户滚动了多少的滚动条距离。 度量：CSS的pixels, window.pageX/YOffset 兼容性问题：pageXOffset 和 pageYOffset 在 IE 8 及之前版本的IE不支持, 使用”document.body.scrollLeft” and “document.body.scrollTop” 来取代 1.2.4 视窗 viewportviewport的功能在于控制你网站的最高块状（block）容器：&lt;html&gt; 元素。viewport是严格的等于浏览器的窗口,viewport不是一个HTML的概念，不能通过CSS修改它。 举个例子~假设你定义了一个可变尺寸的布局（liquid layout），且你定义一个侧边栏的宽度为width: 10%。当你改变浏览器窗口大小时，该侧边栏会自动扩张和收缩。 原理是侧边栏的宽度为它父元素宽度的10% 一个块级元素占有起父元素的100%的宽度（这里有异常情况，暂时忽略）。所以&lt;body&gt;的宽度就是其父元素&lt;html&gt;的宽度。 那么&lt;html&gt;元素到底有多宽？因为它的宽度恰好为浏览器的宽度。所以你的侧边栏宽度width: 10%会占用10%的浏览器宽度。所以的web开发人员都直观的知道和使用该特性了。 但是你也许不知道原理。在原理上，&lt;html&gt;的宽度受viewport所限制，&lt;html&gt;元素为viewport宽度的100%。 1.2.5 页面宽度 document width 度量viewport 尺寸 : 含义：viewport的尺寸 度量：CSS的pixels, document. documentElement. clientWidth/Height 兼容性问题：无 document.documentElement实际上就是·&lt;html&gt;元素：HTML文档的根元素，然而viewport是比&lt;html&gt;更高级别的元素，打个比喻，它是容纳&lt;html&gt;元素的元素。 document. documentElement. clientWidth/Height只会给出viewport的尺寸，而不管&lt;html&gt;元素尺寸如何改变 度量&lt;html&gt; 元素 含义：&lt;html&gt;的尺寸 度量：CSS的pixels, document. documentElement. offsetWidth/Height 兼容性问题：IE用这个值标示viewport的尺寸而非&lt;html&gt; 如果clientWidth/Height一直用以标示viewport的尺寸，我们该如何去获取&lt;html&gt;元素的尺寸呢？答案是：document.documentElement.offsetWidth/Height。 这个特性对真实的让你访问块级元素&lt;html&gt;元素，如果你为&lt;html&gt;元素赋值了宽度，offsetWidth会真实的反应出来 1.3 几种尺寸区别 window.innerWidth/Height 包含滚动条 document. documentElement. clientWidth/Height: 不包含滚动条 viewport尺寸 document. documentElement. offsetWidth：html尺寸 1.4 事件坐标 pageX/Y：从&lt;html&gt;原点到事件触发点的CSS的 pixels (使用概率:90%) clientX/Y：从viewport原点（浏览器窗口）到事件触发点的CSS的 pixels (使用概率:10%) screenX/Y：从用户显示器窗口原点到事件触发点的设备 的 pixels。(使用概率:0%) 兼容性问题：IE不支持pageX/Y,IE使用CSSpixels来度量screanX/Y 1.5 Media查询 含义：可以根据页面的特定宽度来定义特殊的CSS规则。 度量：width/height 和 device-width/device-heigh 兼容性问题：IE不支持. 12345div.sidebar &#123; width: 300px; &#125; @media all and (max-width: 400px) &#123; div.sidebar &#123; width: 100px; &#125; &#125;/*如果宽度大于400px，那么sidebar宽度为300px。反之，sidebar宽度为100px*/ device-width/height: 使用screen.width/height来做为的判定值。该值以设备的pixels来度量 width/height: 使用documentElement.clientWidth/Height即viewport的值。该值以CSS的pixels来度量 2. 移动端浏览器2.1 一些概念2.1.1 视窗 viewport简单的理解，viewport是严格等于浏览器的窗口。在桌面浏览器中，viewport就是浏览器窗口的宽度高度。但在移动端设备上就有点复杂。 移动端的viewport太窄，为了能更好为CSS布局服务，所以提供了两个viewport：虚拟的viewportvisualviewport和布局的viewportlayoutviewport。 2.1.2 物理像素(physical pixel)又称为设备像素 设备独立像素(density-independent pixel) 设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。 CSS像素 CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs。 屏幕密度 屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。 设备像素比(device pixel ratio) 设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到： 1设备像素比 ＝ 物理像素 / 设备独立像素 在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。 在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。 iPhone6的设备宽度和高度为375pt * 667pt,可以理解为设备的独立像素；而其dpr为2，根据上面公式，我们可以很轻松得知其物理像素为750pt * 1334pt。 在不同的屏幕上，CSS像素所呈现的物理尺寸是一致的，而不同的是CSS像素所对应的物理像素具数是不一致的。在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素对应的却是4个物理像素。 在移动端时代屏幕适配除了Layout之外，还要考虑到图片的适配，因为其直接影响到页面显示质量 meta标签 viewport的meta标签，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大。 在开发移动端页面，我们需要设置meta标签如下： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1\"&gt; 代码以显示网页的屏幕宽度定义了视窗宽度。网页的比例和最大比例被设置为100%。 CSS单位rem 在W3C规范中是这样描述rem的: font size of the root element 简单的理解，rem就是相对于根元素&lt;html&gt; 的font-size来做计算。 2.2 适配方案在移动端布局，我们需要面对两个最为重要的问题： 各终端下的适配问题 Retina屏的细节处理 2.2.1 适配终端以前的Flexible方案是通过JavaScript来模拟vw的特性，如今vw已经得到了众多浏览器的支持，也就是说，可以直接考虑将vw单位运用于我们的适配布局中。 vw 是基于Viewport视窗的长度单位，这里的视窗（Viewport）指的就是浏览器可视化的区域，而这个可视区域是window.innerWidth/window.innerHeight的大小。用下图简单的来示意一下： 在CSS Values and Units Module Level 3中和Viewport相关的单位有四个，分别为vw、vh、vmin和vmax。 vw：是Viewport’s width的简写,1vw等于window.innerWidth的1% vh：和vw类似，是Viewport’s height的简写，1vh等于window.innerHeihgt的1% vmin：vmin的值是当前vw和vh中较小的值 vmax：vmax的值是当前vw和vh中较大的值 vmin和vmax是根据Viewport中长度偏大的那个维度值计算出来的，如果window.innerHeight &gt; window.innerWidth则vmin取百分之一的window.innerWidth，vmax取百分之一的window.innerHeight计算。 这个方案中大胆的使用vw来替代以前Flexible中的rem缩放方案 目前出视觉设计稿，我们都是使用750px宽度的，从上面的原理来看，那么100vw = 750px，即1vw = 7.5px。那么我们可以根据设计图上的px值直接转换成对应的vw值。看到这里，很多同学开始感到崩溃，又要计算，能不能简便一点，能不能再简单一点，其实是可以的，我们可以使用PostCSS的插件postcss-px-to-viewport，让我们可以直接在代码中写px，比如： 1234567891011[w-369]&#123; width: 369px; &#125; [w-369] h2 span &#123; background: #FF5000; color: #fff; display: inline-block; border-radius: 4px; font-size: 20px; text-shadow: 0 2px 2px #FF5000; padding: 2px 5px; margin-right: 5px; &#125; PostCSS编译之后就是我们所需要的带vw代码： 12345678910111213[w-369] &#123; width: 49.2vw; &#125; [w-369] h2 span &#123; background: #ff5000; color: #fff; display: inline-block; border-radius: .53333vw; text-shadow: 0 0.26667vw 0.26667vw #ff5000; padding: .26667vw .66667vw; &#125; [w-369] h2 span, [w-369] i &#123; font-size: 2.66667vw; margin-right: .66667vw; &#125; 在实际使用的时候，你可以对该插件进行相关的参数配置： 123456789\"postcss-px-to-viewport\": &#123; viewportWidth: 750, viewportHeight: 1334, unitPrecision: 5, viewportUnit: 'vw', selectorBlackList: [], minPixelValue: 1, mediaQuery: false&#125; 假设你的设计稿不是750px而是1125px，那么你就可以修改vewportWidth的值。有关于该插件的详细介绍，可以阅读其官方使用文档。 在哪些地方可以使用vw来适配我们的页面。根据相关的测试： 容器适配，可以使用vw 文本的适配，可以使用vw 大于1px的边框、圆角、阴影都可以使用vw 内距和外距，可以使用vw 另外有一个细节需要特别的提出，比如我们有一个这样的设计： 如果我们直接使用： 123456[w-188-246] &#123; width: 188px;&#125;[w-187-246]&#123; width: 187px&#125; 最终的效果会造成[w-187-246]容器的高度小于[w-188-246]容器的高度。这个时候我们就需要考虑到容器的长宽比缩放。这方面的方案很多，但我还是推荐工具化来处理，这里推荐@一丝 姐姐写的一个PostCSS插件postcss-aspect-ratio-mini。这个插件使用很简单，不需要做任何的配置，你只需要本地安装一下就OK。使用的时候如下： 12345678910111213141516171819202122[aspectratio] &#123; position: relative;&#125;[aspectratio]::before &#123; content: ''; display: block; width: 1px; margin-left: -1px; height: 0;&#125;[aspectratio-content] &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%;&#125;[aspectratio][aspect-ratio=\"188/246\"]&#123; aspect-ratio: '188:246';&#125; 编译出来： 123[aspectratio][aspect-ratio=\"188/246\"]:before &#123; padding-top: 130.85106382978725%;&#125; 这样就可以完美的实现长宽比的效果。","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.haohome.top/tags/css/"}],"keywords":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}]},{"title":"前端网摘","slug":"Interview/前端网摘","date":"2018-02-20T07:00:00.000Z","updated":"2018-10-22T01:29:12.000Z","comments":true,"path":"2018/02/20/Interview/前端网摘/","link":"","permalink":"http://blog.haohome.top/2018/02/20/Interview/前端网摘/","excerpt":"","text":"1. 移动端网摘 viewports剖析 使用Flexible实现手淘H5页面的终端适配 再聊移动端适配 如何在Vue项目中使用vw实现移动端适配 谷歌device列表 最新Android &amp; iOS设计尺寸规范——2015 px、pt、ppi、dpi、dp、sp之间的关系","categories":[{"name":"Interview","slug":"Interview","permalink":"http://blog.haohome.top/categories/Interview/"}],"tags":[{"name":"网摘","slug":"网摘","permalink":"http://blog.haohome.top/tags/网摘/"}],"keywords":[{"name":"Interview","slug":"Interview","permalink":"http://blog.haohome.top/categories/Interview/"}]},{"title":"DOM通用事件绑定","slug":"JavaScript/DOM通用事件绑定","date":"2018-02-17T16:00:00.000Z","updated":"2018-04-10T05:53:46.000Z","comments":true,"path":"2018/02/18/JavaScript/DOM通用事件绑定/","link":"","permalink":"http://blog.haohome.top/2018/02/18/JavaScript/DOM通用事件绑定/","excerpt":"1. 认识DOMDOM(Document Object Model),即文档对象模型,是为了以编程的方法操作HTML和XML文档内容制定的标准,主要有三种: 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 这里主要认识HTML DOM HTML DOM: 关于如何获取、修改、添加或删除 HTML 元素的标准","text":"1. 认识DOMDOM(Document Object Model),即文档对象模型,是为了以编程的方法操作HTML和XML文档内容制定的标准,主要有三种: 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 这里主要认识HTML DOM HTML DOM: 关于如何获取、修改、添加或删除 HTML 元素的标准 在DOM中,HTML 文档中的所有内容都是节点,通过HTML DOM,树中的所有节点均可通过Js进行增删改查(操作DOM); 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM 教程&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;DOM 第一课&lt;/h1&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;button id=\"btn\"&gt;点击&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 12345var p = document.querySelector(\"p\");//根据选择器标签查找DOM元素var btn=document.getElementById(\"btn\");//根据ID查找DOM元素btn.onclick=function()&#123; //通过操作DOM事件绑定事件 console.log(\"你点击了我\")&#125; 事件的绑定有一个通用的方法: 123btn.addEventListener('click',function()&#123; console.log(\"绑定了点击事件\")&#125;) 2. DOM事件绑定上面讲了两种点击事件绑定的方法，addEventListener是一个通用的事件绑定API，但单词太多，最好自己封装一个绑定方法： 1234567function bindEvent(elem,type,fn)&#123; event.addEventListener(type,fn)&#125;//给按钮btn绑定点击事件bindEvent(btn,click,function()&#123; console.log(\"绑定了点击事件\")&#125;) 重写的bindEvent是一个通用事件绑定,结合事件冒泡情况,可以更完善: 123456&lt;div id=\"div1\"&gt; &lt;p id=\"p1\"&gt;激活1&lt;/p&gt; &lt;p id=\"p2\"&gt;激活2&lt;/p&gt; &lt;p id=\"p3\"&gt;激活3&lt;/p&gt; &lt;p id=\"p4\"&gt;激活4&lt;/p&gt;&lt;/div&gt; 按之前的事件绑定方式,给每个p元素绑定事件,打印输出对应的innerHTML值 12345678var p1=document.getElementById('p1');bindEvent(p1,'click',function(e)&#123; console.log(e.target.innerHTML)&#125;)var body=document.body;bindEvent(body,'click',function(e)&#123; console.log(e.target.innerHTML)&#125;) 运行后发现,点击p1元素会输出两次,说明该元素绑定了两次单击事件,这是由于给p1元素绑定单击事件时冒泡到父元素div1上; 1234bindEvent(p1,'click',function(e)&#123; e.stopPropagation(); console.log(e.target.innerHTML)&#125;) 那么这样通用事件绑定方法就不通用,需要进行改造: 123456789101112131415161718192021function bindEvent(elem,type,selector,fn)&#123; if(fn==null)&#123; //如果没有第四个参数 fn=selector; selector=null; &#125; elem.addEventListener(type,function(e)&#123; if(selector)&#123; var target=e.target if(target.matches(selector))&#123; fn.call(this,e) &#125; &#125;else&#123; fn(e) &#125; &#125;)&#125;var div1=document.getElementById('div1');bindEvent(div1,'click','p',function(e)&#123; // e.stopPropagation(); console.log(e.target.innerHTML)&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"},{"name":"DOM","slug":"DOM","permalink":"http://blog.haohome.top/tags/DOM/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"Vue的点赞效果","slug":"JavaScript/Vue的点赞效果","date":"2018-02-14T12:45:00.000Z","updated":"2018-04-10T05:53:47.000Z","comments":true,"path":"2018/02/14/JavaScript/Vue的点赞效果/","link":"","permalink":"http://blog.haohome.top/2018/02/14/JavaScript/Vue的点赞效果/","excerpt":"1. 原生: 利用CSS3 Animation 实现animation的动画效果通常是连贯性的，简单的说就是线性渐变的动画。但有些效果不需要连贯性，只需要关键帧之间的跳跃，这时应该使用steps 过渡方式，称之为帧动画。 比较知名的Twitter点赞功能就是采用steps方式： HTML 1&lt;i class=\"heart\"&gt;&lt;/i&gt; CSS123456789101112.heart &#123; display: inline-block; width: 5rem; height: 5rem; background: url(heart.png); background-size: auto 5rem; background-position: 0 0;&#125;.heart:active &#123; /*当鼠标点击激活时执行动画效果*/ transition: background 1s steps(28); background-position: -140rem 0; &#125;","text":"1. 原生: 利用CSS3 Animation 实现animation的动画效果通常是连贯性的，简单的说就是线性渐变的动画。但有些效果不需要连贯性，只需要关键帧之间的跳跃，这时应该使用steps 过渡方式，称之为帧动画。 比较知名的Twitter点赞功能就是采用steps方式： HTML 1&lt;i class=\"heart\"&gt;&lt;/i&gt; CSS123456789101112.heart &#123; display: inline-block; width: 5rem; height: 5rem; background: url(heart.png); background-size: auto 5rem; background-position: 0 0;&#125;.heart:active &#123; /*当鼠标点击激活时执行动画效果*/ transition: background 1s steps(28); background-position: -140rem 0; &#125; transition的简写方式为: transition: property duration timing-function delay 属性 描述 transition-property 设置过渡效果的 CSS 属性的名称。 transition-duration 完成过渡效果需要多少秒或毫秒。 transition-timing-function 速度效果的速度曲线。 transition-delay 定义过渡效果何时开始。 上面的CSS动画效果等同于: 12345678.heart:active&#123; animation : heartBlast 1s 1; animation-timing-function:steps(28);&#125;@keyframes heartBlast &#123; 0% &#123;background-position: left;&#125; 100% &#123;background-position: right;&#125;&#125; 逐帧播放红心背景图片达到实现效果 2. Vue的实现方法与原生DOM不同的是,vue是一个以数据驱动的框架,可以直接在html上直接绑定相关事件或属性 template 12&lt;i class=&quot;heart&quot; :style=&quot;star&quot; :class=&quot;&#123;hover:parseInt(item.isHover)&#125;&quot; @click=&quot;heart(item)&quot;&gt;&lt;/i&gt;&lt;!--item是v-for循环中的某个子项,有pid/isHover/count等属性--&gt; 通过绑定设置元素背景图片,双向绑定css类hover,通过点击事件heart控制hover类显示以及点赞数量count变化 script 123456789101112131415161718192021222324252627282930313233343536373839export default &#123; name:'MainBox', data()&#123; return &#123; star:&#123; backgroundImage:'url(' + require('../../assets/img/web_heart_animation.png') + ')' &#125;, isHover:false &#125; &#125;, methods:&#123; updateCount(pid,count)&#123; this.$axios(&#123; url:'/updateCarrousel.php', baseURL: 'http://www.haohome.top/yx/data', methods:'post', params:&#123;pid:pid,count:count&#125;, //pid:当前id,count:当前id已点赞数量 responseType: 'json', transformResponse:function(data)&#123; var code=data.code; if(code)&#123; console.log(\"点赞成功\"); &#125;else&#123; console.log(\"点赞失败\"); &#125; &#125;, &#125;) &#125;, heart(item)&#123; if(item.isHover==\"0\")&#123; item.isHover=\"1\", //点赞动画class:hover绑定 item.count++; &#125;else&#123; item.isHover=\"0\" item.count--; &#125; this.updateCount(item.pid,item.count) &#125; &#125; style 1234567891011.heart&#123; display: inline-block; width: 5rem; height: 5rem; background-size: auto 5rem; background-position: 0 0;&#125;.heart.hover &#123; transition: background 1s steps(28); background-position: -140rem 0; &#125;","categories":[{"name":"Framework","slug":"Framework","permalink":"http://blog.haohome.top/categories/Framework/"}],"tags":[{"name":"css3","slug":"css3","permalink":"http://blog.haohome.top/tags/css3/"},{"name":"vue","slug":"vue","permalink":"http://blog.haohome.top/tags/vue/"}],"keywords":[{"name":"Framework","slug":"Framework","permalink":"http://blog.haohome.top/categories/Framework/"}]},{"title":"Vue的CSS作用域问题","slug":"JavaScript/Vue的CSS作用域问题","date":"2018-02-12T08:48:00.000Z","updated":"2018-04-06T18:05:23.000Z","comments":true,"path":"2018/02/12/JavaScript/Vue的CSS作用域问题/","link":"","permalink":"http://blog.haohome.top/2018/02/12/JavaScript/Vue的CSS作用域问题/","excerpt":"1. CSS 作用域问题1.1 style标签增加scoped属性CSS 只作用于当前组件中的元素,类似于 Shadow DOM 中的样式封装。 原理: 通过使用 PostCSS 来实现转换 123456789&lt;style scoped&gt;.example &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class=\"example\"&gt;hi&lt;/div&gt;&lt;/template&gt; 转换结果: 123456789&lt;style&gt;.example[data-v-f3f3eg9] &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class=\"example\" data-v-f3f3eg9&gt;hi&lt;/div&gt;&lt;/template&gt;","text":"1. CSS 作用域问题1.1 style标签增加scoped属性CSS 只作用于当前组件中的元素,类似于 Shadow DOM 中的样式封装。 原理: 通过使用 PostCSS 来实现转换 123456789&lt;style scoped&gt;.example &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class=\"example\"&gt;hi&lt;/div&gt;&lt;/template&gt; 转换结果: 123456789&lt;style&gt;.example[data-v-f3f3eg9] &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class=\"example\" data-v-f3f3eg9&gt;hi&lt;/div&gt;&lt;/template&gt; 1.2 混用本地和全局样式Vue中可以在一个组件中同时使用有作用域和无作用域的样式: 1234567&lt;style&gt;/* 全局样式 */&lt;/style&gt;&lt;style scoped&gt;/* 本地样式 */&lt;/style&gt; 1.3 子组件的根元素子组件使用了scoped后,父组件的样式不会渗透到子组件中,不过子组件的根节点会同时受到父组件和子组件的css影响 设计目的：为了父组件可以从布局角度出发,调整其子组件根元素的样式 1.4深度作用选择器如果希望scoped样式中的某个样式作用的更深,如影响子组件,可以使用&gt;&gt;&gt;操作符: 1234&lt;style scoped&gt;.a &gt;&gt;&gt; .b &#123; /* ... */ &#125;&lt;/style&gt;&lt;!-- 解析成: .a[data-v-f3f3eg9] .b &#123; /* ... */ &#125; --&gt; 有些像 SASS 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用 /deep/ 操作符取而代之——这是一个 &gt;&gt;&gt;的别名，同样可以正常工作。 1.5动态生成的内容通过 v-html 创建的 DOM 内容不受作用域内的样式影响，但仍然可以通过深度作用选择器来为他们设置样式。 2. CSS Modules2.1 使用CSS Modules是一个用于模块化和组合 CSS 的流行系统。 在&lt;style&gt; 上添加 module 属性： 12345678&lt;style module&gt;.red &#123; color: red;&#125;.bold &#123; font-weight: bold;&#125;&lt;/style&gt; 这将为 css-loader 打开 CSS Modules 模式，生成的 CSS 对象将为组件注入一个名叫 $style 的计算属性，可以在模块中使用动态 class 绑定： 12345&lt;template&gt; &lt;p :class=\"$style.red\"&gt; This should be red &lt;/p&gt;&lt;/template&gt; 由于具有computed属性,也适用于:class 的 object/array 语法： 12345678910&lt;template&gt; &lt;div&gt; &lt;p :class=\"&#123; [$style.red]: isRed &#125;\"&gt; Am I red? &lt;/p&gt; &lt;p :class=\"[$style.red, $style.bold]\"&gt; Red and bold &lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 可以在 JavaScript 访问它： 123456789&lt;script&gt;export default &#123; created () &#123; console.log(this.$style.red) // -&gt; \"_1VyoJ-uZOjlOxP7jWUy19_0\" // an identifier generated based on filename and className. &#125;&#125;&lt;/script&gt; 2.2 自定义注入名称在 .vue 中你可以定义不止一个 &lt;style&gt;，为了避免被覆盖，可以通过设置 module 属性来为它们定义注入后计算属性的名称。 1234567&lt;style module=\"a\"&gt; /* identifiers injected as a */&lt;/style&gt;&lt;style module=\"b\"&gt; /* identifiers injected as b */&lt;/style&gt;","categories":[{"name":"Framework","slug":"Framework","permalink":"http://blog.haohome.top/categories/Framework/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.haohome.top/tags/css/"},{"name":"vue","slug":"vue","permalink":"http://blog.haohome.top/tags/vue/"}],"keywords":[{"name":"Framework","slug":"Framework","permalink":"http://blog.haohome.top/categories/Framework/"}]},{"title":"Webpack入门","slug":"JavaScript/webpack入门","date":"2018-01-28T15:58:00.000Z","updated":"2018-01-28T16:11:01.000Z","comments":true,"path":"2018/01/28/JavaScript/webpack入门/","link":"","permalink":"http://blog.haohome.top/2018/01/28/JavaScript/webpack入门/","excerpt":"1.概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 1.1 入口(entry )入口起点指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。 每个依赖项随即被处理，最后输出到称之为 bundles 的文件中 可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点）","text":"1.概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 1.1 入口(entry )入口起点指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。 每个依赖项随即被处理，最后输出到称之为 bundles 的文件中 可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点） 123module.exports = &#123; entry: './file.js'&#125;; 1.2 出口(output)output属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 output 属性告诉 webpack 在哪里(path)输出它所创建的 bundles，以及如何命名这些文件。 12345678const path = require('path');module.exports = &#123; entry: './file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].bundle.js' //输出的文件名将为file.bundle.js,在当前文件夹dist目录下 &#125;&#125;; output.filename 决定了每个输出 bundle 的名称 模板 描述 [hash] 模块标识符(module identifier)的 hash [chunkhash] chunk 内容的 hash [name] 模块名称 [id] 模块标识符(module identifier) [query] 模块的 query，例如，文件名 ? 后面的字符串 1.3 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块. 本质: webpack loader 将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块。 webpack 的配置中 loader 有两个目标: 1.识别出应该被对应的 loader 进行转换的那些文件。(使用 test 属性) 2.转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）(use 属性) 12345678910111213const path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; ] //当webpack打包require()/import 语句中被解析为'.txt'的路径时,先使用raw-loader转换一下 &#125;&#125;; 1.4 插件(plugins)插件的执行范围比较广,包括从打包优化和压缩,一直到重新定义环境中的变量 使用步骤：先require（），再添加到plugins数组中 tips： ①多数插件可以通过选项options自定义 ②多次使用同一个插件时，可以通过new 创建实例 12345678910111213141516171819const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const path = require('path');module.exports = &#123; entry: './file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;)//使用html模板 ]&#125;; 1.5 配置(Configuration) webpack 的配置文件，是导出一个对象的 JavaScript 文件(module.exports) webpack 配置是标准的 Node.js CommonJS 模块: 通过 require(...) 导入其他文件 通过 require(...) 使用 npm 的工具函数 使用 JavaScript 控制流表达式，例如 ?: 操作符 对常用值使用常量或变量 编写并执行函数来生成部分配置 配置类型(可略过) 在开发和生产构建之间，消除 webpack.config.js 的差异,（至少）有两种选项: 导出一个函数,包含两个参数: 12345678910module.exports = function(env, argv) &#123;//env:environment,argv:一个选项 map 对象 return &#123; devtool: env.production ? 'source-maps' : 'eval', plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: argv['optimize-minimize'] // 只有传入 -p 或 --optimize-minimize &#125;) ] &#125;;&#125;; 导出一个 Promise webpack 将运行由配置文件导出的函数，并且等待 Promise 返回。便于需要异步地加载所需的配置变量。 123456789module.exports = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; entry: './app.js', &#125;) &#125;, 5000) &#125;)&#125; 导出多个配置对象 12345678910111213module.exports = [&#123; output: &#123; filename: './dist-amd.js', libraryTarget: 'amd' &#125;, entry: './app.js',&#125;, &#123; output: &#123; filename: './dist-commonjs.js', libraryTarget: 'commonjs' &#125;, entry: './app.js',&#125;] 1.6 模块(Modules)对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系,如: ES2015 import 语句 CommonJS require() 语句 AMD define 和 require 语句 css/sass/less 文件中的 @import 语句。 样式(url(…))或 HTML 文件(&lt;img src=...&gt;)中的图片链接(image url) webpack 通过 loader 可以支持各种语言和预处理器编写模块。 1.7 模块解析(Module Resolution)一个模块可以作为另一个模块的依赖模块，然后被后者引用 123import foo from 'path/to/module'// 或者require('path/to/module') 1.8 构建目标(Targets)多个 Target: 12345678910111213141516171819var path = require('path');var serverConfig = &#123; target: 'node', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' &#125; //…&#125;;var clientConfig = &#123; target: 'web', // &lt;=== 默认是 'web'，可省略 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.js' &#125; //…&#125;;module.exports = [ serverConfig, clientConfig ];//将在dist 文件夹下创建 lib.js 和 lib.node.js 文件。 1.9 Manifest runtime:在模块交互时，连接模块所需的加载和解析逻辑 manifest:当编译器(compiler)开始执行、解析和映射应用程序时，保留的所有模块详细要点的数据集合 通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。 1.10 模块热替换(Hot Module Replacement)在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 2.安装12npm install --save-dev webpacknpm install --save-dev webpack@&lt;version&gt; 3.配置在webpack.config.js文件中进行配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; // string | object | array app: './src/index.js', print: './src/print.js' &#125;, output: &#123; // webpack 如何输出结果的相关选项, 必须是绝对路径 filename: '[name].bundle.js',//文件名模板 path: path.resolve(__dirname, 'dist'), publicPath: '/' // 输出解析文件的目录，url 相对于 HTML 页面 &#125;, devtool: 'inline-source-map',//追踪到错误和警告在源代码中的原始位置 devServer: &#123; //提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading) contentBase: path.join(__dirname, \"./dist\"), //服务器的位置 port: 3000 &#125;, plugins: [ new CleanWebpackPlugin(['dist']),//每次build都会清理dist文件夹 new HtmlWebpackPlugin(&#123; //指定模板输出,自动生成新的index,所有的bundle 会自动添加到 html 中 filename: 'index.html', template: 'src/assets/test.html'//模板文件路径 &#125;) ], module: &#123; //加载对应资源 rules: [ &#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125;, &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125;, &#123; test: /\\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, &#123; test: /\\.xml$/, use: [ 'xml-loader' ] &#125; ] &#125; &#125;; 4.环境构建4.1 配置 开发环境(development)：需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server； 生产环境(production)：我们的目标转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间； 由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置，但会保留”通用”配置。 通过工具webpack-merge ,将”通用”配置合并在一起: 1npm install --save-dev webpack-merge project项目结构 123456789webpack-demo |- package.json |- config |- webpack.common.js |- webpack.dev.js |- webpack.prod.js |-src |-index.js |- index.html webpack.common.js公共配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const webpack = require('webpack');module.exports = &#123; entry: &#123; index: path.resolve(__dirname,'../src/index.js'), &#125;, resolve: &#123; alias: &#123; //别名,引入第三方库jQuery之后起的别名 jquery: path.resolve(__dirname,'../libs/jquery-3.2.1.js') &#125; &#125;, plugins: [ new CleanWebpackPlugin(//清理文件夹 ['*.js','*.map','*.png','*.css','*.html'], //匹配删除的文件,若为*则全部删除 &#123; root: path.resolve(__dirname,'../dist'), verbose: true, //开启在控制台输出信息 &#125;), new HtmlWebpackPlugin(&#123; //指定模板输出 filename: 'index.html', template: './index.html' &#125;), new webpack.ProvidePlugin(&#123; //自动生成全局变量,一旦引用,就会打包 $:\"jquery\", jQuery:\"jquery\", 'window.jQuery':\"jquery\", 'window.$':\"jquery\" &#125;), ], module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: [\"env\"] &#125; &#125; &#125; ] &#125;, output: &#123; //打包输出配置路径 filename: '[name]-[hash].bundle.js', path: path.resolve(__dirname, '../dist'), publicPath: '' //上线的绝对地址 可以为http://www.haohome.top/ &#125;, &#125;; webpack.dev.js 开发配置 123456789const path = require('path');const merge = require('webpack-merge');const common = require('./webpack.common.js');module.exports = merge(common, &#123; //与公共配置合并 devtool: 'inline-source-map',//追踪错误和警告 devServer: &#123; //提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading) contentBase:path.resolve(__dirname, \"../\"), //服务器的位置 &#125;,&#125;); webpack.prod.js 生产配置 123456789101112const merge = require('webpack-merge');const UglifyJSPlugin = require('uglifyjs-webpack-plugin');//代码压缩工具const common = require('./webpack.common.js');module.exports = merge(common, &#123; devtool: 'source-map', //调试源码(debug)和运行基准测试(benchmark tests)很有用 plugins: [ new UglifyJSPlugin(&#123; sourceMap: true //如果配置了devtool则加改选项 &#125;) ],&#125;);/ 避免在生产中使用 inline-*** 和 eval-***，因为它们可以增加 bundle 大小，并降低整体性能。 package.json配置NPM Scripts: 把 scripts 重新指向到新配置。我们将 npm start 定义为开发环境脚本，并在其中使用 webpack-dev-server，将 npm run build 定义为生产环境脚本: 1234\"scripts\": &#123; \"start\": \"webpack-dev-server --progress --colors --open --config webpack.dev.js\", \"build\": \"webpack --progress --colors --config webpack.prod.js\"&#125; 4.2 指定环境许多 library 将通过与 process.env.NODE_ENV 环境变量关联，以决定 library 中应该引用哪些内容。当使用 process.env.NODE_ENV === &#39;production&#39; 时，一些 library 可能针对具体用户的环境进行代码优化，从而删除或添加一些重要代码。 可以使用 webpack 内置的 DefinePlugin为所有的依赖定义这个变量 webpack.prod.js 12345678910111213141516+ const webpack = require('webpack');//引入webpack const merge = require('webpack-merge'); const UglifyJSPlugin = require('uglifyjs-webpack-plugin'); const common = require('./webpack.common.js'); module.exports = merge(common, &#123; devtool: 'source-map', plugins: [ new UglifyJSPlugin(&#123; sourceMap: true &#125;),+ new webpack.DefinePlugin(&#123;+ 'process.env.NODE_ENV': JSON.stringify('production')//指定为生产环境+ &#125;) ] &#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.haohome.top/tags/webpack/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"webpack入门","slug":"JavaScript/webpack笔记","date":"2018-01-28T15:58:00.000Z","updated":"2018-06-23T16:40:00.000Z","comments":true,"path":"2018/01/28/JavaScript/webpack笔记/","link":"","permalink":"http://blog.haohome.top/2018/01/28/JavaScript/webpack笔记/","excerpt":"背景ES6 的模块系统: import 和export 12345export default custom = &#123; // 对象&#125;/*****************/import custom from '.....' Common.js 1234567let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let fs = require('fs');let stat = fs.stat;let exists = fs.exists;let readfile = fs.readfile; 没有模块加载和打包工具前,需要要么手工合并文件，要么使用一堆&lt;script&gt;标签,带来一些问题 必须保证文件加载的顺序没错，包括知道哪些文件依赖另外一些文件，以及不包含不需要的文件。 多个&lt;script&gt;标签意味着对服务器发送多次请求，性能会受影响。 模块文件使用很方便,通过npm安装相应插件模块,直接import引入即可","text":"背景ES6 的模块系统: import 和export 12345export default custom = &#123; // 对象&#125;/*****************/import custom from '.....' Common.js 1234567let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let fs = require('fs');let stat = fs.stat;let exists = fs.exists;let readfile = fs.readfile; 没有模块加载和打包工具前,需要要么手工合并文件，要么使用一堆&lt;script&gt;标签,带来一些问题 必须保证文件加载的顺序没错，包括知道哪些文件依赖另外一些文件，以及不包含不需要的文件。 多个&lt;script&gt;标签意味着对服务器发送多次请求，性能会受影响。 模块文件使用很方便,通过npm安装相应插件模块,直接import引入即可 1.概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 认识webpack,需了解四个核心概念: 入口(entry) 输出(output) loader 插件(plugins) 1.1 入口(entry )入口起点指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。 每个依赖项随即被处理，最后输出到称之为 bundles 的文件中 可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点） 123module.exports = &#123; entry: './index.js'&#125;; 当工程是多页面应用程序: 1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; 1.2 出口(output)output属性指在哪里输出它所创建的 bundles，包括以下两点： filename 用于输出文件的文件名。 path指输出 的绝对路径。 属性告诉 webpack 在**哪里(path)输出它所创建的 bundles**，以及如何命名这些文件。1234567891011```JavaScriptconst path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].bundle.js&apos;, //输出的文件名将为file.bundle.js,在当前文件夹dist目录下 publicPath: &apos;/dist/&apos; &#125;&#125;; 决定了每个输出 bundle 的名称123456789101112131415161718192021222324252627282930313233343536| 模板 | 描述 || ----------- | ------------------------------ || [hash] | 模块标识符(module identifier)的 hash || [chunkhash] | chunk 内容的 hash || [name] | 模块名称 || [id] | 模块标识符(module identifier) || [query] | 模块的 query，例如，文件名 `?` 后面的字符串 |#### 1.3 [loader](https://doc.webpack-china.org/concepts/loaders)*loader* 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效[模块](https://doc.webpack-china.org/concepts/modules).&gt; 本质: webpack loader 将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块。 webpack 的配置中 **loader** 有两个属性:- `test` :识别出应该被对应的 loader 进行转换的那些文件;- `use`:转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）当编译时碰到 `require()`/`import` 语句中被解析为路径时,打包前将执行loader进行转换```JavaScriptconst path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: &apos;css-loader&apos; &#125; ] &#125;&#125;; 1.4 插件(plugins)插件的执行范围比较广,包括从打包优化和压缩,一直到重新定义环境中的变量 使用步骤：先require（），再添加到plugins数组中 tips： ①多数插件可以通过选项options自定义 ②多次使用同一个插件时，可以通过new 创建实例 12345678910111213141516171819const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const path = require('path');module.exports = &#123; entry: './file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\\.css$/, use: 'css-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) //使用html模板 ]&#125;; 1.5 配置(Configuration) webpack 的配置文件，是导出一个对象的 JavaScript 文件(module.exports) webpack 配置是标准的 CommonJS``` 模块:1234567891011121314151617181920212223- 通过 `require(...)` 导入其他文件- 通过 `require(...)` 使用 npm 的工具函数- 使用 JavaScript 控制流表达式，例如 `?:` 操作符- 对常用值使用常量或变量- 编写并执行函数来生成部分配置导出多个配置对象```JavaScriptmodule.exports = [&#123; output: &#123; filename: &apos;./dist-amd.js&apos;, libraryTarget: &apos;amd&apos; &#125;, entry: &apos;./app.js&apos;,&#125;, &#123; output: &#123; filename: &apos;./dist-commonjs.js&apos;, libraryTarget: &apos;commonjs&apos; &#125;, entry: &apos;./app.js&apos;,&#125;] 1.6 模块(Modules)对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系,如: ES2015 import 语句 CommonJS require() 语句 AMD define 和 require 语句 css/sass/less 文件中的 @import 语句。 样式(url(…))或 HTML 文件()中的图片链接(image url) webpack 通过 loader 可以支持各种语言和预处理器编写模块。 1.7 模块解析(Module Resolution)一个模块可以作为另一个模块的依赖模块，然后被后者引用 123import foo from 'path/to/module'// 或者require('path/to/module') 1.8 构建目标(Targets)多个 Target: 12345678910111213141516171819var path = require('path');var serverConfig = &#123; target: 'node', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' &#125; //…&#125;;var clientConfig = &#123; target: 'web', // &lt;=== 默认是 'web'，可省略 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.js' &#125; //…&#125;;module.exports = [ serverConfig, clientConfig ];//将在dist 文件夹下创建 lib.js 和 lib.node.js 文件。 1.9 Manifest runtime:在模块交互时，连接模块所需的加载和解析逻辑 manifest:当编译器(compiler)开始执行、解析和映射应用程序时，保留的所有模块详细要点的数据集合 通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。 1.10 模块热替换(Hot Module Replacement)在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 2.安装12npm install --save-dev webpacknpm install --save-dev webpack@&lt;version&gt; 3.配置在webpack.config.js文件中进行配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; // string | object | array app: './src/index.js', print: './src/print.js' &#125;, output: &#123; // webpack 如何输出结果的相关选项, 必须是绝对路径 filename: '[name].bundle.js',//文件名模板 path: path.resolve(__dirname, 'dist'), publicPath: '/' // 输出解析文件的目录，url 相对于 HTML 页面 &#125;, devtool: 'inline-source-map',//追踪到错误和警告在源代码中的原始位置 devServer: &#123; //提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading) contentBase: path.join(__dirname, \"./dist\"), //服务器的位置 port: 3000 &#125;, plugins: [ new CleanWebpackPlugin(['dist']),//每次build都会清理dist文件夹 new HtmlWebpackPlugin(&#123; //指定模板输出,自动生成新的index,所有的bundle 会自动添加到 html 中 filename: 'index.html', template: 'src/assets/test.html'//模板文件路径 &#125;) ], module: &#123; //加载对应资源 rules: [ &#123; test: /\\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, &#123; test: /\\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125;, &#123; test: /\\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125;, &#123; test: /\\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, &#123; test: /\\.xml$/, use: [ 'xml-loader' ] &#125; ] &#125; &#125;; loader PostCSS PostCSS是一个利用JS插件来对CSS进行转换的工具，这些插件非常强大，强大到无所不能。其中，Autoprefixer就是众多PostCSS插件中最流行的一个。 安装方法: npm i --save-dev postcss 一般postcss会结合autoprefixer一起使用,autoprefixer是css的后处理器,可为css添加浏览器前缀,使兼容不同浏览器,安装方法: npm install --save-dev autoprefixer 配置1: 123456 &#123; test: /\\.less$/, exclude: /node_modules/, use: ExtractTextPlugin.extract(&#123;fallback: \"style-loader\",use: 'css-loader!postcss-loader!less-loader'&#125;) &#125;/*可以处理less或sass*/ 这种方式需要在项目根目录下添加psotcss-config.js文件,里面添加 12345module.exports = &#123; plugins: [ require('autoprefixer')(&#123;browsers: ['last 5 versions']&#125;) ] &#125; 配置2: 1234567891011121314&#123; test: /\\.less$/, exclude: /node_modules/, use: ExtractTextPlugin.extract(&#123; fallback: \"style-loader\", use: [ &#123;loader: 'css-loader'&#125;, &#123;loader: 'postcss-loader', options: &#123;plugins: [require('autoprefixer')(&#123;browsers: ['last 5 versions']&#125;) ]&#125; &#125;, &#123;loader: 'less-loader'&#125;] )&#125;&#125; 这种配置是将postcss配置依赖直接放在里面了 babel 安装npm install --save-dev babel-loader babel-core 安装: npm install babel-preset-env --save-dev 在根目录下新建.babelrc 文件,添加 123&#123; \"presets\": [\"env\"]&#125; 123456789&#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; // presets: [\"env\"] //如果有.babellrc文件这个配置可省略 &#125; // &#125;&#125;, 4.环境构建4.1 配置 开发环境(development)：需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server； 生产环境(production)：我们的目标转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间； 由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置，但会保留”通用”配置。 通过工具,将\"通用\"配置合并在一起:123```JavaScriptnpm install --save-dev webpack-merge project项目结构 123456789webpack-demo |- package.json |- config |- webpack.common.js |- webpack.dev.js |- webpack.prod.js |-src |-index.js |- index.html webpack.common.js公共配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const webpack = require('webpack');module.exports = &#123; entry: &#123; index: path.resolve(__dirname,'../src/index.js'), &#125;, resolve: &#123; alias: &#123; //别名,引入第三方库jQuery之后起的别名 jquery: path.resolve(__dirname,'../libs/jquery-3.2.1.js') &#125; &#125;, plugins: [ new CleanWebpackPlugin(//清理文件夹 ['*.js','*.map','*.png','*.css','*.html'], //匹配删除的文件,若为*则全部删除 &#123; root: path.resolve(__dirname,'../dist'), verbose: true, //开启在控制台输出信息 &#125;), new HtmlWebpackPlugin(&#123; //指定模板输出 filename: 'index.html', template: './index.html' &#125;), new webpack.ProvidePlugin(&#123; //自动生成全局变量,一旦引用,就会打包 $:\"jquery\", jQuery:\"jquery\", 'window.jQuery':\"jquery\", 'window.$':\"jquery\" &#125;), ], module: &#123; rules: [ &#123; test: /\\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: [\"env\"] &#125; &#125; &#125; ] &#125;, output: &#123; //打包输出配置路径 filename: '[name]-[hash].bundle.js', path: path.resolve(__dirname, '../dist'), publicPath: '' //上线的绝对地址 可以为http://www.haohome.top/ &#125;, &#125;; webpack.dev.js 开发配置 123456789const path = require('path');const merge = require('webpack-merge');const common = require('./webpack.common.js');module.exports = merge(common, &#123; //与公共配置合并 devtool: 'inline-source-map',//追踪错误和警告 devServer: &#123; //提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading) contentBase:path.resolve(__dirname, \"../\"), //服务器的位置 &#125;,&#125;); webpack.prod.js 生产配置 123456789101112const merge = require('webpack-merge');const UglifyJSPlugin = require('uglifyjs-webpack-plugin');//代码压缩工具const common = require('./webpack.common.js');module.exports = merge(common, &#123; devtool: 'source-map', //调试源码(debug)和运行基准测试(benchmark tests)很有用 plugins: [ new UglifyJSPlugin(&#123; sourceMap: true //如果配置了devtool则加改选项 &#125;) ],&#125;);/ 避免在生产中使用 inline-*** 和 eval-***，因为它们可以增加 bundle 大小，并降低整体性能。 package.json配置NPM Scripts: 把 scripts 重新指向到新配置。我们将 npm start 定义为开发环境脚本，并在其中使用 webpack-dev-server，将 npm run build 定义为生产环境脚本: 1234\"scripts\": &#123; \"start\": \"webpack-dev-server --progress --colors --open --config webpack.dev.js\", \"build\": \"webpack --progress --colors --config webpack.prod.js\"&#125; 4.2 指定环境许多 library 将通过与 process.env.NODE_ENV 环境变量关联，以决定 library 中应该引用哪些内容。当使用 process.env.NODE_ENV === &#39;production&#39; 时，一些 library 可能针对具体用户的环境进行代码优化，从而删除或添加一些重要代码。 可以使用 webpack 内置的 DefinePlugin为所有的依赖定义这个变量 webpack.prod.js 12345678910111213141516+ const webpack = require('webpack');//引入webpack const merge = require('webpack-merge'); const UglifyJSPlugin = require('uglifyjs-webpack-plugin'); const common = require('./webpack.common.js'); module.exports = merge(common, &#123; devtool: 'source-map', plugins: [ new UglifyJSPlugin(&#123; sourceMap: true &#125;),+ new webpack.DefinePlugin(&#123;+ 'process.env.NODE_ENV': JSON.stringify('production')//指定为生产环境+ &#125;) ] &#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.haohome.top/tags/webpack/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"Vue实现简单分页功能","slug":"JavaScript/Vue实现简单分页功能","date":"2018-01-21T13:30:00.000Z","updated":"2018-04-06T18:04:09.000Z","comments":true,"path":"2018/01/21/JavaScript/Vue实现简单分页功能/","link":"","permalink":"http://blog.haohome.top/2018/01/21/JavaScript/Vue实现简单分页功能/","excerpt":"分页功能在列表查询中是一个比较重要的组成部分,按结构划分可分为页码与上一页/下一页: 页码:通过点击数字,并将页码数字传递到后台查询获取相应的页码内容 上一页/下一页:可以共用一个方法,利用不同参数识别,查询数据逻辑与页码类似; 页面显示页码:可以采用计算属性computed获得 下面的案例是我从自己的vue项目中摘取出来:","text":"分页功能在列表查询中是一个比较重要的组成部分,按结构划分可分为页码与上一页/下一页: 页码:通过点击数字,并将页码数字传递到后台查询获取相应的页码内容 上一页/下一页:可以共用一个方法,利用不同参数识别,查询数据逻辑与页码类似; 页面显示页码:可以采用计算属性computed获得 下面的案例是我从自己的vue项目中摘取出来: 实现分页的CSS部分 1234567891011121314151617181920212223242526272829.pages &#123; text-align: center;&#125;.pages a &#123; color:#999; box-sizing: border-box; height: 20px; min-width: 20px; border-radius: 2px; display: inline-block; border:1px solid #ddd; margin: 0 2px; padding: 0 4px; line-height: 18px;&#125;.pages a:hover &#123; border-color:#f8b551; color:#f8b551;&#125;.pages a.cur &#123; border-color:#f8b551; background: #f8b551; color: #fff;&#125;.pages a.default &#123; border-color: #ddd; color:#ddd; cursor: default;&#125; 实现分页的template 123456&lt;div class=\"pages\"&gt; &lt;a href=\"\" @click.self.prevent=\"togglePage(-1)\" :class=\"&#123;default:pno&lt;=1&#125;\"&gt;上一页&lt;/a&gt; &lt;a v-for=\"(temp,key) in realPage\" :key=key :class=\"&#123;cur:pno==temp&#125;\" href=\"\" @click.self.prevent=\"changePage(temp)\"&gt;&#123;&#123;temp&#125;&#125;&lt;/a&gt; &lt;a href=\"\" @click.self.prevent=\"togglePage(1)\" :class=\"&#123;default:pno&gt;=pageCount&#125;\"&gt;下一页 &lt;/a&gt;&lt;/div&gt;&lt;!--利用事件修饰符 @click.self.prevent阻止对元素自身的点击。--&gt; 实现分页的Js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 data ()&#123; return &#123; newsList:[], pno:1, pageCount:0 &#125; &#125;, mounted()&#123; this.getList() //挂载的时候获取新闻列表 &#125;, methods: &#123; getList()&#123; var self=this; self.$axios(&#123; method: 'get', baseURL:'http://127.0.0.1:3000/', url: '/news/list/'+self.pno, withCredentials: true, responseType: 'json', transformResponse:function(response)&#123; self.newsList=response.data; self.pageCount=response.pageCount; &#125;, &#125;); &#125;, // 点击页面切换 changePage(index)&#123; var self=this; self.pno=index; self.$axios(&#123; method: 'get', baseURL:'http://127.0.0.1:3000/', url: '/news/list/'+self.pno, withCredentials: true, responseType: 'json', transformResponse:function(response)&#123; self.newsList=response.data; self.pageCount=response.pageCount; &#125;, &#125;); &#125;, //点击上一页/下一页事件 togglePage(index)&#123;//通过对index赋值来识别按钮 var self=this; if(index&gt;0)&#123; if(self.pno&gt;=self.pageCount)return; self.pno++; &#125;else&#123; if(self.pno&lt;=1)return self.pno--; &#125; self.$axios(&#123; method: 'get', baseURL:'http://127.0.0.1:3000/', url: '/news/list/'+self.pno, withCredentials: true, responseType: 'json', transformResponse:function(response)&#123; self.newsList=response.data; self.pageCount=response.pageCount; &#125;, &#125;); &#125; &#125;, computed :&#123; //vue内置的计算属性,可以直接使用realPage,相当于java的getter方法 realPage:function()&#123; let left=1; let right=this.pageCount; var realCount=[];//当前可显示的页码数组,如[4,5,6] if(right&gt;=3)&#123;//控制最多显示3页 if(this.pno&gt;1 &amp;&amp; this.pno+1&lt;this.pageCount)&#123; left=this.pno-1; right=this.pno+1; &#125;else &#123; if(this.pno&lt;=3)&#123; left=1; right=3; &#125;else&#123; left=this.pageCount-2; right=this.pageCount; &#125; &#125; &#125; while(left&lt;=right)&#123; //通过循环将当前可显示的页码存到realCount数组中 realCount.push(left); left++; &#125; return realCount; &#125; &#125;&#125; 当页面发生变化,如果需要通知其他组件做出相应变化,可以再增加watch监听页面变化 12345watch: &#123; pno: function(newValue,oldValue)&#123; console.log(arguments); &#125;&#125; ​","categories":[{"name":"Framework","slug":"Framework","permalink":"http://blog.haohome.top/categories/Framework/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://blog.haohome.top/tags/vue/"}],"keywords":[{"name":"Framework","slug":"Framework","permalink":"http://blog.haohome.top/categories/Framework/"}]},{"title":"Node基础","slug":"JavaScript/Node_基础","date":"2018-01-20T16:00:00.000Z","updated":"2018-04-10T05:53:47.000Z","comments":true,"path":"2018/01/21/JavaScript/Node_基础/","link":"","permalink":"http://blog.haohome.top/2018/01/21/JavaScript/Node_基础/","excerpt":"1.HTTP模块 http模块是创建HTTP协议的服务器端应用(代替Apache和php)——接受客户端请求,解析并处理请求,返回响应消息. http模块还用于创建HTTP协议的客户端应用(模拟浏览器功能)——向其他的服务器发起请求，等待返回响应消息. Node.js中使用http模块创建服务器端应用： 123456const http=require('http');let server=http.createServer(function(req,res)&#123; //客户端请求消息 req.method/url/headers //服务器响应消息 res.write()/writeHead()/end&#125;)server.listen(3000);//监听3000端口","text":"1.HTTP模块 http模块是创建HTTP协议的服务器端应用(代替Apache和php)——接受客户端请求,解析并处理请求,返回响应消息. http模块还用于创建HTTP协议的客户端应用(模拟浏览器功能)——向其他的服务器发起请求，等待返回响应消息. Node.js中使用http模块创建服务器端应用： 123456const http=require('http');let server=http.createServer(function(req,res)&#123; //客户端请求消息 req.method/url/headers //服务器响应消息 res.write()/writeHead()/end&#125;)server.listen(3000);//监听3000端口 eg:http模块请求不同url,响应不同消息主体 12345678910111213const http=require('http');let server=http.createServer(function(req,res)&#123; res.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); if(req.url=='/index')&#123; res.write('&lt;h1&gt;这是首页&lt;/h1&gt;') &#125;else if(req.url=='/user/login')&#123; res.write('&lt;h1&gt;这是登录页&lt;/h1&gt;') &#125;else if(req.url=='/user/register')&#123; res.write('&lt;h1&gt;这是注册页&lt;/h1&gt;') &#125; res.end('欢迎来到NodeJs');&#125;)server.listen(3000);//监听3000端口 2.fs模块 fs模块提供了文件的读写、更名、删除、遍历目录等操作。 fs模块中大多方法都带有同步和异步两种操作模式 1)异步方法的最后一个参数都是一个回调函数2)传给回调函数的参数取决于具体方法,但回调函数的第一个参数是error异常,如果有异常,会静默失败,需要手动处理;3)同步方法中任何异常都会被立即抛出,可以使用 try/catch 来处理异常，或让异常向上冒泡。 123456//异步方法const fs = require('fs');fs.unlink('/tmp/hello', (err) =&gt; &#123; if (err) throw err;//有异常则抛出异常 console.log('成功删除 /tmp/hello');&#125;); 1234//同步方法 方法名后+Syncconst fs = require('fs');fs.unlinkSync('/tmp/hello');console.log('成功删除 /tmp/hello'); 2.1 判断文件是否存在fs.stat方法:fs.stat(path, callback(err,stats))第一个参数是path(路径),第二个参数是回调函数(第一个参数是异常error,第二个是统计信息描述对象)1234567fs.stat('data.txt', (err, stats) =&gt; &#123; if (err) &#123; console.log(err.code); throw err; &#125; console.log(stats);&#125;); 2.2 文件路径转换fs.realpath方法:fs.realpath(path[, options], callback(err,realpath)),将相对路径转为绝对路径 在express中提供文件路径时用到12345678fs.realpath('./data.txt',function(err,resolvedPath)&#123; //如果转换失败,则err中有值,否则为null if(err)&#123; console.error(err); &#125;else&#123; console.log(resolvedPath);// e:\\Github\\Node\\data.txt &#125;&#125;) 2.3 文件重命名fs.rename方法:fs.rename(oldPath, newPath, callback(err)) 2.4 文件读写fs.readFile方法:fs.readFile(path[, options], callback(err,data))fs.writeFile方法:fs.writeFile(file, data[, options], callback(err)) options encoding | 默认 = ‘utf8’如果 data 是一个 buffer，则忽略 encoding 选项。它默认为 ‘utf8’. mode 默认 = 0o666 flag 默认 = ‘w’,表示”写”,flag==”a”,则为追加append 12345fs.writeFile('data.txt', 'Hello Node.js', (err) =&gt; &#123; if (err) throw err; console.log('The file has been saved!');&#125;);fs.writeFile('message.txt', 'Hello Node.js', 'utf8', callback); 多次对同一文件使用 fs.writeFile 且不等待回调，是不安全的。 对于这种情况，强烈推荐使用 fs.createWriteStream。 2.5 读写流 读取流 123456789101112var rs=fs.createReadStream('./data.txt');var temp=\"\";rs.on('data',function(chunk)&#123; //每读取64kb执行data方法 console.log(chunk); //看字符串 // console.log(chunk.toString()); temp+=chunk;//拼接所有的数据&#125;)//读取流完毕后执行endrs.on('end',function()&#123; console.log(temp);&#125;) 写入流 12345var rs=fs.createReadStream('./data.txt');var ws=fs.createWriteStream('./data_bak.txt');rs.on('data',function(chunk)&#123; ws.write(chunk);&#125;) pipe方法写入数据时,会等当前读出的数据全部写入后,才进行下一次的读取操作,内存利用充分,当时读取时间比较长 123var rs=fs.createReadStream('./data.txt');var ws=fs.createWriteStream('./data_bak.txt');rs.pipe(ws) 3.http第三方模块express 使用步骤： 1.安装 2.使用http模块创建Web服务器，运行express，让其承担请求监听器的任务12var app = express();http.createServer( app ).listen(80); 3.为app对象添加特定URL的请求处理12345678910app.get('/user', function(req, res)&#123; //接收请求消息中的数据 req.query //获取查询字符串中的数据&#123; &#125; req.params //获取请求参数(手册自学) req.on('data', function(buf)&#123;&#125;) //获取请求主体中的数据 //发送响应消息 res.send(HTML文本); res.sendFile(任意类型的文件); res.json(对象/数组数据);&#125;) 3.1 路由路由，针对客户端的某个请求方法所请求的特定URL，如何给出响应消息的过程，称为“路由”路由 = 请求方法 + 请求URL + 处理函数一个典型的路由形如：1234567891011app.get('/user', function(req, res)&#123; //接收请求消息中的数据 req.query //获取查询字符串中的数据&#123; &#125; req.params //获取请求参数(手册自学) req.on('data', function(buf)&#123;&#125;) //获取请求主体中的数据 //发送响应消息 res.send(HTML文本); res.sendFile(任意类型的文件); res.json(对象/数组数据);&#125;) express.Router 在 app 目录下创建名为 birds.js 的文件，内容如下： 1234567891011121314151617 var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);// 定义网站主页的路由router.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// 定义 about 页面的路由router.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 然后在应用中加载路由模块：123var birds = require('./birds');...app.use('/birds', birds); 应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。 3.2 中间件中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。功能:(1)执行任何代码。(2)修改请求和响应对象。(3)终结请求-响应循环。(4)调用堆栈中的下一个中间件。 如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。 应用级中间件应用级中间件绑定到app对象使用app.use()和app.METHOD(),其中，METHOD是需要处理的HTTP请求的方法，例如GET,PUT,POST等等全部小写。123456789101112131415var app = express();// 没有挂载路径的中间件，应用的每个请求都会执行该中间件app.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它app.use('/user/:id', function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; res.send('USER');&#125;); 3.2.1 在一个挂载点装载一组中间件12345678// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息app.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;); 3.2.2 下例为指向 /user/:id 的 GET 请求定义了两个路由,但第一个路由终止了请求-响应循环,第二个路由不会被执行1234567891011// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; console.log('ID:', req.params.id); next();&#125;, function (req, res, next) &#123; res.send('User Info');&#125;);// 处理 /user/:id， 打印出用户 idapp.get('/user/:id', function (req, res, next) &#123; res.end(req.params.id);&#125;); 3.2.3 如果需要在中间件栈中跳过剩余中间件，调用next(‘route’)方法将控制权交给下一个路由 注意：next(‘route’)只对使用app.VERB()或router.VERB()加载的中间件有效。123456789101112131415// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next('route'); // 否则将控制权交给栈中下一个中间件 else next(); //&#125;, function (req, res, next) &#123; // 渲染常规页面 res.render('regular');&#125;);// 处理 /user/:id， 渲染一个特殊页面app.get('/user/:id', function (req, res, next) &#123; res.render('special');&#125;); 路由级中间件 使用方法与应用级中间件类似 var router = express.Router(); 错误处理中间件 错误处理中间件有4个参数，定义错误处理中间件时必须使用这4个参数。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;); 项目中常用的中间件 (1)向客户端返回指定目录下的所有静态资源文件 1234567- (2)将客户端POST请求主体中的数据封装到req.body中 ```JavaScript npm i body-parser const bodyParser = require(&apos;body-parser&apos;); app.use( bodyParser.urlencoded(&#123;extended: false&#125;)); (3)将请求头部中的Cookie数据封装到req.cookies中 123npm i cookie-parserconst cookieParser = require('cookie-parser');app.use(cookieParser()); (4)解决跨域问题cors 1234app.use( cors(&#123; origin: [\"http://127.0.0.1\", \"http://localhost:8080\"], credentials: true&#125;) ); 配置cors: 12345678910111213var express = require('express')var cors = require('cors')var app = express()var corsOptions = &#123; //配置跨域选项 origin: 'http://example.com', optionsSuccessStatus: 200 // some legacy browsers (IE11, various SmartTVs) choke on 204 &#125; app.get('/products/:id', cors(corsOptions), function (req, res, next) &#123; res.json(&#123;msg: '跨域仅限域名:example.com.'&#125;)&#125;) app.listen(80, function () &#123; console.log('80端口服务器可以跨域')&#125;)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"node","slug":"node","permalink":"http://blog.haohome.top/tags/node/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"跨域资源共享CORS","slug":"JavaScript/跨域资源共享 CORS","date":"2018-01-13T16:00:00.000Z","updated":"2018-10-22T01:11:51.000Z","comments":true,"path":"2018/01/14/JavaScript/跨域资源共享 CORS/","link":"","permalink":"http://blog.haohome.top/2018/01/14/JavaScript/跨域资源共享 CORS/","excerpt":"CORS是一个W3C标准,全称是”跨域资源共享”(Cross-origin resource sharing)。它允许浏览器向夸源服务器发出XMLHttpRequest请求，克服Ajax只能同源使用的限制。 一、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。","text":"CORS是一个W3C标准,全称是”跨域资源共享”(Cross-origin resource sharing)。它允许浏览器向夸源服务器发出XMLHttpRequest请求，克服Ajax只能同源使用的限制。 一、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 二、两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 2.1简单请求简单请求满足一下两大条件(1)请求方法时一下三种方法之一 HEAD GET POST (2)HTTP的头信息不超出一下几种字段: Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 2.1.1 基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个12345678910 &gt; 下面的例子,浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个```Origin```字段。 ```JavaScriptGET /cors HTTP/1.1Origin: &apos;http://api.bob.com&apos;Host: &apos;api.alice.com&apos;Accept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...//上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果1234567891011 &gt; 这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200 - 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。```JavaScript//浏览器响应头resAccess-Control-Allow-Origin: &apos;http://api.bob.com&apos;Access-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8//上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 (1)Access-Control-Allow-Origin(必须)该字段是必须的。受任意域名的请求。 (2)Access-Control-Allow-Credentials(可选)它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 (3)Access-Control-Expose-Headers(可选)CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 2.1.2 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定12```JavaScriptAccess-Control-Allow-Credentials: true 同时开发者必须在AJAX请求中打开1234```JavaScriptvar xhr = new XMLHttpRequest();xhr.withCredentials = true; 这样就能向服务器发送Cookie,服务器才能获得SessionId;否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理,这时服务器会新建一个新的Cookie的Id号。 但是，有时即使省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 注意:如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 2.2非简单请求 2.2.1预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 123456var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send();//上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。 下面是这个”预检”请求的HTTP头信息。 12345678OPTIONS /cors HTTP/1.1Origin: 'http://api.bob.com'Access-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 (1)Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 (2)Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 转载自阮一峰的网络日志","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"http://blog.haohome.top/tags/学习记录/"},{"name":"Http","slug":"Http","permalink":"http://blog.haohome.top/tags/Http/"},{"name":"Ajax","slug":"Ajax","permalink":"http://blog.haohome.top/tags/Ajax/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"字符串操作slice、substr、sbustring比较","slug":"JavaScript/字符串操作slice、substr、substring比较","date":"2018-01-12T16:00:00.000Z","updated":"2018-04-06T18:06:29.000Z","comments":true,"path":"2018/01/13/JavaScript/字符串操作slice、substr、substring比较/","link":"","permalink":"http://blog.haohome.top/2018/01/13/JavaScript/字符串操作slice、substr、substring比较/","excerpt":"在截取字符串时常常会用到substr()、substring()、slice()截取数组或字符串的方法,几个方法之间有时易混淆. slice() 可接受一个或者两个参数 两个参数:slice(start,end),start指截取字符串开始的位置,end指截取字符串结束的位置(不包含) 一个参数:slice(start),指截取从start位置到结束位置(字符串长度为结束位置) 1.传递参数为正值,end表示结束的位置123var str=\"HelloWorld\";console.log(str.slice(3));//\"loworld\" console.log(str.slice(3,7)); //'loWo'","text":"在截取字符串时常常会用到substr()、substring()、slice()截取数组或字符串的方法,几个方法之间有时易混淆. slice() 可接受一个或者两个参数 两个参数:slice(start,end),start指截取字符串开始的位置,end指截取字符串结束的位置(不包含) 一个参数:slice(start),指截取从start位置到结束位置(字符串长度为结束位置) 1.传递参数为正值,end表示结束的位置123var str=\"HelloWorld\";console.log(str.slice(3));//\"loworld\" console.log(str.slice(3,7)); //'loWo' 2.传递参数为负值slice()将传入的负值与字符串长度相加 123var str='Helloworld';console.log(str.slice(-3));//'rld' 一个参数,与字符串长度相加即为slice(7);console.log(str.slice(3,-4));//'low' 两个参数,字符串长度相加即为slice(3,6); 3.第二个参数比第一个参数小,则返回空字符串 4.IE兼容性:在IE8浏览器测试下,没有兼容性问题 slice与substring、substr区别 传递参数为正值:1) substring与slice方法行为类似,但substring会将较小的数作为开始位置,较大的数作为结束位置(substring(3,0) 与substring(0,3)是一样效果);2) substr第二个参数表示返回字符的个数,如果没有第二参数,则字符串的长度作为结束位置 传递参数为负值:1) substring()会把所有负值参数转换为0;2) substr()方法会将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。 123var str =\"helloWorld\";console.log(str.substr(-3,5));//\"rld\" 即为：substr(7,5) ，从位置7开始向后截取5个字符console.log(str.substr(3,-2));//substr(3,0)，即从位置3截取0个字符串，则返回空 IE兼容性: slice() 和 substring ()在IE8都正常,substr()方法传递负值的情况下会存在问题，会返回原始的字符串。IE9修复了此问题。 总结 在传递正值参数情况下，slice() 和 substring () 行为是一致的，substr()方法在第二个参数上会容易混淆 在传递负值参数情况下，slice() 方法是通过字符串长度相加，符合一般思维，substring()第二个参数转换为0会容易出问题，起始位置会容易变更， substr() 方法负值情况下会出现IE兼容性问题。综上，一般推荐使用slice()方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"},{"name":"String","slug":"String","permalink":"http://blog.haohome.top/tags/String/"},{"name":"Array","slug":"Array","permalink":"http://blog.haohome.top/tags/Array/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"Java中的接口","slug":"Java/Java中的接口","date":"2018-01-06T16:00:00.000Z","updated":"2018-01-07T07:28:41.000Z","comments":true,"path":"2018/01/07/Java/Java中的接口/","link":"","permalink":"http://blog.haohome.top/2018/01/07/Java/Java中的接口/","excerpt":"","text":"1.接口的概念接口定义了某一批类所需要遵守的规范,接口不关心这些类的内部数据,也不关心这些类里方法的实现细节,它只规定这些类里必须提供某些方法; 2.接口定义定义接口不再使用class关键字,而使用interface关键字 2.1 基本语法12345[修饰符public] [abstract] interface 接口名 [extends 父接口1,父接口2...]&#123; 零个到多个常量定义... 零个到多个抽象方法的定义...&#125; 接口是开放的（被继承、被实现），修饰符使用public，不能使用private和protected 常量接口中的属性是常量,即使定义时不添加public static final修饰符,系统也会自动加上 方法接口中的方法只能是抽象方法,总是使用,即使定义时不添加public abstract修饰符,系统也会自动加上3.使用接口一个类可以实现一个或多个接口,实现接口使用implements关键字 阶层父类实现接口的语法: 1234[修饰符] class 类名 extends 父类 implements 接口1,接口2...&#123; 类体部分 //如果继承了抽象类,需要实现继承的抽象方法;要实现接口中的抽象方法&#125; 如果要继承父类,继承父类必须在实现接口之前 补充:接口使用过程中,还经常与匿名内部类配合使用 匿名内部类就是没有名字的内部类,多用于关注实现而不关注实现类的名称语法格式 123456Interface i=new Interface()&#123; public void method()&#123; System.out.println(\"匿名内部类实现接口的方式\"); &#125;&#125;i.method();//直接调用","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/tags/Java/"},{"name":"学习记录","slug":"学习记录","permalink":"http://blog.haohome.top/tags/学习记录/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}]},{"title":"Java中的多态","slug":"Java/Java中的多态","date":"2017-12-31T16:00:00.000Z","updated":"2018-01-07T07:28:49.000Z","comments":true,"path":"2018/01/01/Java/Java中的多态/","link":"","permalink":"http://blog.haohome.top/2018/01/01/Java/Java中的多态/","excerpt":"","text":"多态1.引用多态 父类的引用可以指向本类的对象 父类的引用可以指向子类的对象2.方法多态 创建本类对象时,调用的方法为本类方法 创建子类对象时,调用的方法为子类重写的方法或者继承的方法3.引用类型转换 向上类型转换(隐式/自动类型转换),是小类型向大类型转换 向下类型转换(强制类型转换),是大类型到小类型转换(存在数据溢出风险) instanceof运算符:避免类型转换出现的安全问题12345678Dog dog=new Dog();Animal animal=dog;//(向上类型转换)if (animal instanceof Dog) &#123; Dog dog2=(Dog)animal;&#125;else&#123; System.out.println(\"无法进行类型转换\");&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/tags/Java/"},{"name":"学习记录","slug":"学习记录","permalink":"http://blog.haohome.top/tags/学习记录/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}]},{"title":"Java中的抽象类","slug":"Java/Java中的抽象类","date":"2017-12-31T16:00:00.000Z","updated":"2018-01-07T07:28:46.000Z","comments":true,"path":"2018/01/01/Java/Java中的抽象类/","link":"","permalink":"http://blog.haohome.top/2018/01/01/Java/Java中的抽象类/","excerpt":"","text":"1.语法定义抽象类前使用abstract关键字修饰,则该类为抽象类 2.应用场景 父类只知道子类应该包含哪些方法,但不知道子类如何实现这些方法 从多个具有相同特征的类中抽象出一个抽象类,以这个抽象类作为子类额模板,避免子类设计的随意性3.作用抽象类是约束子类必须有哪些方法,而并不关注子类如何实现这些方法4.使用规则(步骤) 1)abstract定义抽象类 2)abstract定义抽象方法,只有声明,不需要实现(就是定义一个方法名,让子类根据自己情况实现) 3)包含抽象方法的类是抽象类 4)抽象类中可以包含普通方法,也可以没有抽象方法 5)抽象类不能直接创建,可以定义引用变量","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/tags/Java/"},{"name":"学习记录","slug":"学习记录","permalink":"http://blog.haohome.top/tags/学习记录/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}]},{"title":"Java中super关键字的使用","slug":"Java/Java中super关键字的使用","date":"2017-12-31T16:00:00.000Z","updated":"2018-01-07T07:32:47.000Z","comments":true,"path":"2018/01/01/Java/Java中super关键字的使用/","link":"","permalink":"http://blog.haohome.top/2018/01/01/Java/Java中super关键字的使用/","excerpt":"","text":"super关键字在对象的内部使用,可以代表父类对象 1.访问父类的属性super.age 2.访问父类的方法super.eat()","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/tags/Java/"},{"name":"学习记录","slug":"学习记录","permalink":"http://blog.haohome.top/tags/学习记录/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}]},{"title":"FreeMaker 模板_数据模型","slug":"Java/FreeMaker 模板_数据模型","date":"2017-12-31T16:00:00.000Z","updated":"2018-03-05T16:07:58.000Z","comments":true,"path":"2018/01/01/Java/FreeMaker 模板_数据模型/","link":"","permalink":"http://blog.haohome.top/2018/01/01/Java/FreeMaker 模板_数据模型/","excerpt":"1. 模板 + 数据模型 = 输出1.1 模板 模板与静态HTML类似,区别是包含了一些指令,使网页内容可以动态生成，例如: 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome $&#123;user&#125;!&lt;/h1&gt; &lt;p&gt;Our latest product: &lt;a href=\"$&#123;latestProduct.url&#125;\"&gt;$&#123;latestProduct.name&#125;&lt;/a&gt;! &lt;/body&gt;&lt;/html&gt;","text":"1. 模板 + 数据模型 = 输出1.1 模板 模板与静态HTML类似,区别是包含了一些指令,使网页内容可以动态生成，例如: 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome $&#123;user&#125;!&lt;/h1&gt; &lt;p&gt;Our latest product: &lt;a href=\"$&#123;latestProduct.url&#125;\"&gt;$&#123;latestProduct.name&#125;&lt;/a&gt;! &lt;/body&gt;&lt;/html&gt; ${…}：插值表达式(interpolation) FTL标签：FreeMarker模板的语言标签，标签的名字以 # 开头，用户自定义的FTL标签则需要使用 @ 来代替 # 注释：使用 &lt;#– and –&gt; 来标识 其他任何不是插值、FTL标签或注释的内容将被视为静态文本，直接在页面输出 1.2 数据模型为模板准备的数据整体被称作为数据模型数据模型是树形结构,例如: 123456789101112131415161718192021222324252627(root) | +- animals | | | +- mouse | | | | | +- size = \"small\" | | | | | +- price = 50 | | | +- elephant | | | | | +- size = \"large\" | | | | | +- price = 5000 | | | +- python | | | +- size = \"medium\" | | | +- price = 4999 | +- message = \"It is a test\" | +- misc | +- foo = \"Something\" hashes (哈希表): 指变量中扮演目录角色(比如 root, animals, mouse, elephant, python, misc) 哈希表存储其他变量(被称为 子变量)， 它们可以通过名称来查找(比如 “animals”, “mouse” 或 “price”)。 scalars (标量): 指存储单值的变量 (size, price, message 和 foo) 如果要在模板中使用子变量， 那应该从根root开始指定它的路径，每级之间用点来分隔开。要访问 mouse 的 price ，要从root开始，首先进入到 animals ，之后访问 mouse ，最后访问 price 。就可以这样来写 animals.mouse.price。 sequences (序列): 像哈希表那样存储子变量，但是子变量没有名字，它们只是列表中的项。在下面这个数据模型中， animals 和 misc.fruits 就是序列： 1234567891011121314151617181920212223242526272829303132333435(root) | +- animals | | | +- (1st) | | | | | +- name = \"mouse\" | | | | | +- size = \"small\" | | | | | +- price = 50 | | | +- (2nd) | | | | | +- name = \"elephant\" | | | | | +- size = \"large\" | | | | | +- price = 5000 | | | +- (3rd) | | | +- name = \"python\" | | | +- size = \"medium\" | | | +- price = 4999 | +- misc | +- fruits | +- (1st) = \"orange\" | +- (2nd) = \"banana\" 要访问序列的子变量，可以使用方括号形式的数字索引下标。 索引下标从0开始(从0开始也是程序员的传统)，那么第一项的索引就是0， 第二项的索引就是1等等。要得到第一个动物的名称的话，可以这么来写代码 animals[0].name。 标量类型可以分为如下的类别： 字符串：就是文本，也就是任意的字符序列，比如上面提到的 ‘m’,’o’,’u’, ‘s’,’e’。比如 name 和 size 也是字符串。 数字：这是数值类型，就像上面的 price。 在FreeMarker中，字符串 “50” 和数字 50 是两种完全不同的类型。 日期/时间: 可以是日期-时间格式(存储某一天的日期和时间)， 或者是日期(只有日期，没有时间)，或者是时间(只有时间，没有日期)。 布尔值：对应着对/错(是/否，开/关等值)类似的值。 总结： 数据模型可以被看成是树形结构。 标量用于存储单一的值。这种类型的值可以是字符串，数字，日期/时间或者是布尔值。 哈希表是一种存储变量及其相关且有唯一标识名称的容器。 序列是存储有序变量的容器。存储的变量可以通过数字索引来检索，索引通常从0开始。","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/tags/Java/"},{"name":"学习记录","slug":"学习记录","permalink":"http://blog.haohome.top/tags/学习记录/"},{"name":"FreeMaker","slug":"FreeMaker","permalink":"http://blog.haohome.top/tags/FreeMaker/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}]},{"title":"Java中的类和对象","slug":"Java/Java中的类和对象","date":"2017-12-31T16:00:00.000Z","updated":"2018-03-05T16:10:10.000Z","comments":true,"path":"2018/01/01/Java/Java中的类和对象/","link":"","permalink":"http://blog.haohome.top/2018/01/01/Java/Java中的类和对象/","excerpt":"","text":"1.类 类是对象的类型 类具有相同属性和方法的一组对象的集合 定义:确定对象将拥有的特征(属性)和方法(行为) 类的组成:属性和方法 定义类的步骤 a.定义类名b.编写类的属性c.编写类的方法 !– more –&gt; 12345678public class 类名&#123; //定义属性部分(成员变量) 属性1的类型 属性1; 属性2的类型 属性2; //定义方法部分 方法1; 方法2;&#125; 2.对象对象的属性 对象具有的各种特征 每个对象的每个属性都拥有特定值对象的方法 对象可以执行的操作 使用对象的步骤: a. 创建对象(new) b. 使用对象 引用对象的属性:对象名.属性 引用对象的方法:对象名.方法 类是抽象的概念,对象是一个具体的实物 3.访问修饰符 访问修饰符 本类 同包 子类 其他 private √ 默认 √ √ protected √ √ √ public √ √ √ √ 属性通常设为private 外部调用对象属性通常通过对象的getter和setter方法 4.Object类的方法4.1 toString()方法默认:toString()方法默认返回的是对象的哈希码(对象的地址字符串)Override:返回的是对象的属性值 4.2 equals()方法默认:比较的是对象的引用是否指向同一块内存地址Override:比较对象的属性值(数据)信息","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/tags/Java/"},{"name":"学习记录","slug":"学习记录","permalink":"http://blog.haohome.top/tags/学习记录/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}]},{"title":"Java中的static的使用","slug":"Java/Java 中的 static 使用","date":"2017-12-20T16:00:00.000Z","updated":"2018-03-05T16:09:47.000Z","comments":true,"path":"2017/12/21/Java/Java 中的 static 使用/","link":"","permalink":"http://blog.haohome.top/2017/12/21/Java/Java 中的 static 使用/","excerpt":"static静态变量的使用 通常我们可以基于一个类创建多个该类的对象，每个对象都拥有自己的成员，互相独立。然而在某些时候，我们更希望该类所有的对象共享同一个成员。static的作用在于此; Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。 使用 static 可以修饰变量、方法和代码块。","text":"static静态变量的使用 通常我们可以基于一个类创建多个该类的对象，每个对象都拥有自己的成员，互相独立。然而在某些时候，我们更希望该类所有的对象共享同一个成员。static的作用在于此; Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。 使用 static 可以修饰变量、方法和代码块。 12345678910public class HelloWorld&#123; static String hobby=\"唱歌\";//static修饰的变量为静态变量,所有类的对象共享hobby; public static void main (String[] args)&#123; System.out.println(\"通过类名访问hobby: \" +HelloWorld.hobby); HelloWorld hello=new HelloWorld(); System.out.println(\"通过对象名访问hobby: \"+hello.hobby); hello.hobby=\"跳舞\";//通过对象名的形式修改静态变量的值 System.out.println(\"通过类名访问hobby: \" +HelloWorld.hobby);//再次使用类名访问静态变量,值已改变 &#125;&#125; 静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间,直到该类被卸载才会进行资源回收！ static静态方法的使用12345678910public static void main(String[] args) &#123; print();//直接调用同类中静态方法 HelloWorld.print();//直接使用类名调用静态方法 HelloWorld hello=new HelloWorld(); hello.print();//通过实例化对象再调用;&#125;//使用关键字声明静态方法public static void print() &#123; System.out.println(\"你好,世界!\");&#125; 注意 1.静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。123456789public class HelloWorld&#123; String name=\"小明\";//费静态变量 static String hobby=\"唱歌\";//静态变量hobby //在静态方法中调用非静态变量 public static void print()&#123; // System.out.println(\"欢迎:\"+name+\"!\");报错,不能直接调用非静态变量 System.out.println(\"爱好:\"+hobby+\"!\"); &#125;&#125; 如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量 1234567public static void print()&#123; //创建类的对象 HelloWorld hello=new HelloWorld(); //通过对象来实现在静态方法中调用非静态变量 System.out.println(\"欢迎:\"+hello.name+\"!\"); System.out.println(\"爱好:\"+hobby+\"!\");&#125; 2.在普通成员方法中，则可以直接访问同类的非静态变量和静态变量 123456String name=\"张三\"; //非静态变量static String hobby=\"唱歌\";//静态变量public void show()&#123; System.out.println(\"欢迎:\"+name+\"!\"); System.out.println(\"爱好:\"+hobby+\"!\");&#125; 3.静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。 1234567891011public void show()&#123; //普通成员方法 System.out.println(\"你好欢迎您!\");&#125;public static void print()&#123; System.out.println(\"欢迎来到这里\");&#125;public static void main(String[] args)&#123; HelloWorld hello=new HelloWorld(); hello.show();//普通成员方法必须通过对象调用 print();//可以直接调用静态方法&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/tags/Java/"},{"name":"学习记录","slug":"学习记录","permalink":"http://blog.haohome.top/tags/学习记录/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}]},{"title":"Backbone学习笔记","slug":"JavaScript/Backbone-study-note","date":"2017-12-16T16:00:00.000Z","updated":"2018-04-06T18:04:06.000Z","comments":true,"path":"2017/12/17/JavaScript/Backbone-study-note/","link":"","permalink":"http://blog.haohome.top/2017/12/17/JavaScript/Backbone-study-note/","excerpt":"Model1.简单的对象123456Man = Backbone.Model.extend(&#123; initialize: function()&#123; console.log('你好,你创建了我!'); &#125; &#125;); var man = new Man; 2.对象赋值的两种方法:直接定义默认值和赋值定义123456789101112Man = Backbone.Model.extend(&#123; initialize: function()&#123; console.log('你好,你创建了我!'); &#125;, defaults: &#123; name:'张三', age: '38' &#125; &#125;); var man = new Man; man.set&#123;name:\"李四\"&#125;; //赋值定义 console.log(man.get(\"name\"))","text":"Model1.简单的对象123456Man = Backbone.Model.extend(&#123; initialize: function()&#123; console.log('你好,你创建了我!'); &#125; &#125;); var man = new Man; 2.对象赋值的两种方法:直接定义默认值和赋值定义123456789101112Man = Backbone.Model.extend(&#123; initialize: function()&#123; console.log('你好,你创建了我!'); &#125;, defaults: &#123; name:'张三', age: '38' &#125; &#125;); var man = new Man; man.set&#123;name:\"李四\"&#125;; //赋值定义 console.log(man.get(\"name\")) 3.监听属性方法:bind1234567891011121314151617181920Man = Backbone.Model.extend(&#123; initialize: function()&#123; console.log('你好,你创建了我!'); //初始化时绑定监听 this.bind(\"change:name\",function()&#123; console.log(\"你改变了name属性为：\" + this.get(\"name\")); &#125;); &#125;, defaults: &#123; name:'张三', age: '38' &#125;, aboutMe: function()&#123; return '我叫' + this.get('name') + ',今年' + this.get('age') + '岁'; &#125; &#125;); var man = new Man; man.aboutMe(); man.set(&#123;name:'小明'&#125;); //触发绑定的change事件，输出。 man.aboutMe(); 4.为对象添加验证规则,以及错误提示12345678910111213141516171819202122232425262728293031323334 Man = Backbone.Model.extend(&#123; initialize: function()&#123; console.log('你好,你创建了我!'); //初始化时绑定监听 this.bind(\"change:name\",function()&#123; var name = this.get(\"name\"); console.log(\"你改变了name属性为：\" + name); &#125;); this.bind(\"invalid\",function(model, error)&#123; // 当model在客户端 validation（验证）失败时触发。 console.log(error); &#125;); &#125;, defaults: &#123; name:'张三', age: '38' &#125;, validate:function(attributes, options)&#123; if(attributes.name == '') &#123; return \"name不能为空！\"; &#125; &#125;, aboutMe: function()&#123; return '我叫' + this.get('name') + ',今年' + this.get('age') + '岁'; &#125; &#125;); var man = new Man;// 这种方式添加错误处理也行/* man.on('invalid', function(model, error)&#123; alert(error); &#125;);*/ man.set(&#123;name:''&#125;); man.set(&#123;name:''&#125;, &#123;'validate':true&#125;); //手动触发验证, set时会触发 man.save(); //save时触发验证。根据验证规则，弹出错误提示。 5.对象的获取和保存 save() 会发送POST到模型对应的url，数据格式为json{“name”:”小明”,”age”:38},接着用fetch([options])从服务器端获取数据 fetch({url:’/man/‘}) 发送get请求到/man/这个url中，服务器返回的结果样式是对应的json格式数据123456789man1.fetch(&#123;url:'/man/', success:function(model,response)&#123; console.log('get from server success');//model为获取到的数据 console.log(model.get('name')); &#125;, error:function()&#123; //当返回格式不正确或者是非json数据时，会执行此方法 alert('error');&#125;&#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 Man = Backbone.Model.extend(&#123; url:'/man/', initialize: function()&#123; console.log('你好,你创建了我!'); //初始化时绑定监听 this.bind(\"change:name\",function()&#123; var name = this.get(\"name\"); console.log(\"你改变了name属性为：\" + name); &#125;); this.bind(\"invalid\",function(model,error)&#123; console.log(\"error\",error); &#125;); &#125;, defaults: &#123; name:'张三', age: '38' &#125;, validate:function(attributes)&#123; if(attributes.name == '') &#123; return \"name不能为空！\"; &#125; &#125;, aboutMe: function()&#123; return '我叫' + this.get('name') + ',今年' + this.get('age') + '岁'; &#125;&#125;);var man = new Man;;man.set(&#123;name:'小明'&#125;);man.save(); //会发送POST到模型对应的url，数据格式为json&#123;\"name\":\"小明\",\"age\":38&#125;//然后接着就是从服务器端获取数据使用方法fetch([options])var man1 = new Man;//第一种情况，如果直接使用fetch方法，那么他会发送get请求到你model的url中，//你在服务器端可以通过判断是get还是post来进行对应的操作。man1.fetch();//第二种情况，在fetch中加入参数，如下：man1.fetch(&#123;url:'/man/'&#125;);//这样，就会发送get请求到/man/这个url中，//服务器返回的结果样式应该是对应的json格式数据，同save时POST过去的格式。//不过接受服务器端返回的数据方法是这样的：man1.fetch(&#123;url:'/man/',success:function(model,response)&#123; alert('get from server success'); //model为获取到的数据 alert(model.get('name')); &#125;,error:function()&#123; //当返回格式不正确或者是非json数据时，会执行此方法 alert('error');&#125;&#125;); collection 示例12345678910111213141516171819202122232425262728Book = Backbone.Model.extend(&#123; defaults : &#123; title:'默认标题' &#125;, initialize: function()&#123; console.log('你好,你创建了我!'); &#125; &#125;); BookShelf = Backbone.Collection.extend(&#123; model : Book &#125;); var book1 = new Book(&#123;title : 'book1'&#125;); var book2 = new Book(&#123;title : 'book2'&#125;); var book3 = new Book(&#123;title : 'book3'&#125;); //var bookShelf = new BookShelf([book1, book2, book3]); //实例化集合,参数为数组,或者使用add var bookShelf = new BookShelf; bookShelf.add(book1); bookShelf.add(book2); bookShelf.add(book3); bookShelf.remove(book3); //基于underscore这个js库，还可以使用each的方法获取collection中的数据 bookShelf.each(function(book)&#123; console.log(book.get('title')); &#125;); 2.使用fetch从服务器端获取数据,使用reset渲染12345678910111213141516171819showAllBooks = function()&#123; bookShelf.each(function(book)&#123; //将book数据渲染到页面。 document.writeln(book.get('title')); &#125;); &#125; bookShelf.bind('reset', showAllBooks); bookShelf.url = '/books/'; //注意这里 bookShelf.fetch(&#123; reset: true, success:function(collection,response, options)&#123; collection.each(function(book)&#123; console.log(book.get('title')); &#125;); &#125;, error:function(collection, response, options)&#123; console.log('error'); &#125; &#125;); 创建collection推送到server端创建数据，其实就是调用collection的create方法，POST对应的Model对象（json数据）到配置好的url上。之后会返回一个model的实例，如下面代码中的onebook。12345678var NewBooks = Backbone.Collection.extend(&#123; model: Book, url: '/books/'&#125;);var books = new NewBooks;var onebook = books.create(&#123;title: \"I'm coming\",&#125;);","categories":[{"name":"Framework","slug":"Framework","permalink":"http://blog.haohome.top/categories/Framework/"}],"tags":[{"name":"学习记录","slug":"学习记录","permalink":"http://blog.haohome.top/tags/学习记录/"},{"name":"Backbone","slug":"Backbone","permalink":"http://blog.haohome.top/tags/Backbone/"}],"keywords":[{"name":"Framework","slug":"Framework","permalink":"http://blog.haohome.top/categories/Framework/"}]},{"title":"Java中extends和implements的区别","slug":"Java/Java中extends和implements区别","date":"2017-12-10T16:00:00.000Z","updated":"2018-01-07T07:33:10.000Z","comments":true,"path":"2017/12/11/Java/Java中extends和implements区别/","link":"","permalink":"http://blog.haohome.top/2017/12/11/Java/Java中extends和implements区别/","excerpt":"在类的声明中,通过关键字extends来创建一个类的子类。一个类通过关键字implements声明自己使用一个或者多个接口。 extends 是继承父类(只要那个类不是声明为final或者那个类定义为abstract的就能继承), 继承之后可以使用父类的方法, 也可以重写父类的方法,可以实现父类，也可以调用父类初始化 this.parent()。而且会覆盖父类定义的变量或者函数。这样的好处是：架构师定义好接口，让工程师实现就可以了。整个项目开发效率和开发成本大大降低。 implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用;实现父类，子类不可以覆盖父类的方法或者变量。即使子类定义与父类相同的变量或者函数，也会被父类取代掉。 这两种实现的具体使用，是要看项目的实际情况，需要实现，不可以修改implements，只定义接口需要具体实现，或者可以被修改扩展性好，用extends。","text":"在类的声明中,通过关键字extends来创建一个类的子类。一个类通过关键字implements声明自己使用一个或者多个接口。 extends 是继承父类(只要那个类不是声明为final或者那个类定义为abstract的就能继承), 继承之后可以使用父类的方法, 也可以重写父类的方法,可以实现父类，也可以调用父类初始化 this.parent()。而且会覆盖父类定义的变量或者函数。这样的好处是：架构师定义好接口，让工程师实现就可以了。整个项目开发效率和开发成本大大降低。 implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用;实现父类，子类不可以覆盖父类的方法或者变量。即使子类定义与父类相同的变量或者函数，也会被父类取代掉。 这两种实现的具体使用，是要看项目的实际情况，需要实现，不可以修改implements，只定义接口需要具体实现，或者可以被修改扩展性好，用extends。 接口实现的注意点： 实现一个接口就是要实现该接口的所有的方法(抽象类除外)。 接口中的方法都是抽象的。 多个无关的类可以实现同一个接口，一个类可以实现多个无关的接口。 JAVA中不支持多重继承，但是可以用接口来实现，这样就要用到implements，继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了 比如 ：class A extends B implements C,D,E","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/tags/Java/"},{"name":"学习记录","slug":"学习记录","permalink":"http://blog.haohome.top/tags/学习记录/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}]},{"title":"get和post推荐使用场景","slug":"Java/get和post推荐使用场景","date":"2017-12-10T11:50:00.000Z","updated":"2018-03-05T16:08:20.000Z","comments":true,"path":"2017/12/10/Java/get和post推荐使用场景/","link":"","permalink":"http://blog.haohome.top/2017/12/10/Java/get和post推荐使用场景/","excerpt":"","text":"查询数据时用GET,因为通常查询条件较少; 提交数据(表单)时用POST,因为通常提交的数据较多.","categories":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/tags/Java/"},{"name":"学习记录","slug":"学习记录","permalink":"http://blog.haohome.top/tags/学习记录/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://blog.haohome.top/categories/Java/"}]},{"title":"DOM渲染流程","slug":"JavaScript/DOM渲染","date":"2017-11-27T16:00:00.000Z","updated":"2018-04-06T18:04:56.000Z","comments":true,"path":"2017/11/28/JavaScript/DOM渲染/","link":"","permalink":"http://blog.haohome.top/2017/11/28/JavaScript/DOM渲染/","excerpt":"1.解析HTML，构建DOM树（构建DOM节点）。 2.构建渲染树（解析样式信息，包括外部的css文件、style标签中的样式）。渲染树由一些包含有各种属性的矩形组成，他们将会按照正确的顺序显 示到屏幕上。 3.布局渲染树（布局DOM节点），执行布局的过程，将确定每个节点在屏幕上的确切坐标。 4.绘制渲染树（绘制DOM节点，即遍历渲染树），使用UI后端层来绘制每个节点。","text":"1.解析HTML，构建DOM树（构建DOM节点）。 2.构建渲染树（解析样式信息，包括外部的css文件、style标签中的样式）。渲染树由一些包含有各种属性的矩形组成，他们将会按照正确的顺序显 示到屏幕上。 3.布局渲染树（布局DOM节点），执行布局的过程，将确定每个节点在屏幕上的确切坐标。 4.绘制渲染树（绘制DOM节点，即遍历渲染树），使用UI后端层来绘制每个节点。 1.HTML标签元素经过HTML解析,依据DOM标准生成DOM树, 2.CSS样式代码经过CSS解析成样式规则,Webkit使用attachment连接DOM节点和可视化信息来构建渲染树; 3.渲染树由渲染对象构成,并使用layout来表示元素布局 4.最后遍历渲染树,最后在浏览器上绘制页面","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"},{"name":"DOM","slug":"DOM","permalink":"http://blog.haohome.top/tags/DOM/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"58同城面试总结","slug":"Interview/58面试总结","date":"2017-11-14T16:00:00.000Z","updated":"2018-10-22T01:12:46.000Z","comments":true,"path":"2017/11/15/Interview/58面试总结/","link":"","permalink":"http://blog.haohome.top/2017/11/15/Interview/58面试总结/","excerpt":"前言:面试中问了一些基础的问题,非常能反映基本功是否扎实,很佩服58的工程师! 记录两个印象比较深的两道CSS面试题,面试官对效果实现都是希望多种方法实现,平时的积累需要灵活应用:","text":"前言:面试中问了一些基础的问题,非常能反映基本功是否扎实,很佩服58的工程师! 记录两个印象比较深的两道CSS面试题,面试官对效果实现都是希望多种方法实现,平时的积累需要灵活应用: 1.左固定一个宽度div,右边div宽度自适应,如何实现?听到这个问题我还挺开心的,因为前两天还写过,当时也是试了几次才写出来,只是没有在意和及时总结。现场回答的非常不好，比较惭愧,回到家第一件事就把这个题模拟了一下： 利用绝对定位和padding-left实现1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt; *&#123; margin:0; padding:0; &#125; .box&#123; width:100%; position:relative; &#125; .left&#123; width:300px; position:absolute; z-index: 10; min-height:300px; background:#f00; &#125; .right&#123; width:100%; position:absolute; padding-left: 300px; box-sizing: border-box; min-height:300px; background:#ff0; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"box\"&gt; &lt;div class=\"left\"&gt;我属于左边&lt;/div&gt; &lt;div class=\"right\"&gt;我属于右边&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2. 写一个弹窗,怎么居中弹窗里的元素?这个问题平时写的比较多,但疏于整理现场只回答了一个方法,面试官希望有更多方法,现场另举了弹性布局,回来后整理了下,主要有以下四种方法: 1.居中浮动元素: 1.1 利用margin负值 123456789.son &#123; width:600px ; height:300px; margin: -150px 0 0 -300px; position:absolute;/*父元素relative*/ background-color:pink; left:50%; top:50%;&#125; 1.2 利用translate 12345678910111213141516.father &#123; width: 600px; height: 600px; position: relative; background-color: yellow;&#125;.son &#123; width: 200px; height: 200px; background-color: blue; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; 1.3 利用弹性布局` 12345678910111213.father &#123; width: 600px; height: 600px; background-color: yellow; display: flex; justify-content: center; align-items: center;&#125;.son &#123; width: 200px; height: 200px; background-color: blue;&#125; 1.4 利用margin特性 1234567891011121314151617.father &#123; width: 600px; height: 600px; position: relative; background-color: yellow;&#125;.son &#123; width: 200px; height: 200px; background-color: blue; position: absolute; margin: auto; left: 0; right: 0; top: 0; bottom: 0;&#125; 2.内容居中:123456.father&#123; height: 100px; line-height:100px; text-align: center; background-color:pink;&#125; 或者:123456.father&#123; display:table-cell;/*对象作为表格单元*/ vertical-align:middle; text-align:center; background-color:pink;&#125;","categories":[{"name":"Interview","slug":"Interview","permalink":"http://blog.haohome.top/categories/Interview/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.haohome.top/tags/css/"},{"name":"面试","slug":"面试","permalink":"http://blog.haohome.top/tags/面试/"}],"keywords":[{"name":"Interview","slug":"Interview","permalink":"http://blog.haohome.top/categories/Interview/"}]},{"title":"ready与load比较","slug":"JavaScript/ready与load","date":"2017-11-11T12:46:25.000Z","updated":"2018-04-06T18:25:48.000Z","comments":true,"path":"2017/11/11/JavaScript/ready与load/","link":"","permalink":"http://blog.haohome.top/2017/11/11/JavaScript/ready与load/","excerpt":"1.执行时间不同： $(document).ready()是指html解析完毕，dom树已经建立起来,页面内容(html,css,js,图片)还未加载完成 $(window).load()是指页面所有的加载完毕。","text":"1.执行时间不同： $(document).ready()是指html解析完毕，dom树已经建立起来,页面内容(html,css,js,图片)还未加载完成 $(window).load()是指页面所有的加载完毕。 2.执行次数不同 $(document).ready()可以执行多次。可以写多个。 $(window).load()一个页面,只能有一个，如果出现多个，则只会调用最后一个，之前的都会被覆盖。1234567891011121314&lt;script&gt; $(document).ready(function()&#123; alert(\"test1\");//这段代码会被执行 &#125;); $(document).ready(function()&#123; alert(\"test2\");//这段代码会被执行 &#125;); $(window).load(function()&#123; alert(\"test1\");//这段代码不会被执行 &#125;); $(window).load(function()&#123; alert(\"test2\");//这段代码将被执行 &#125;);&lt;/script&gt; 3.执行效率不同 $(document).ready()执行效率相对高一些 12345678910&lt;script&gt; $(document).ready(function()&#123; $(\".the_body a\").attr(\"onclick\",\"alert('test')\"); &#125;); $(window).load(function()&#123; $(\".close_btn\").click(function()&#123; $(\"#app_down\").hide(); &#125;); &#125;);&lt;/script&gt; 4.js和jQuery 序号 原生js jQuery 1 document.ready=function(){} $(document).ready(function(){})==$(function(){}) 2 window.onload=function(){} $(window).load(function(){}) 3 window.location.reload();","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"},{"name":"DOM","slug":"DOM","permalink":"http://blog.haohome.top/tags/DOM/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"flex-shrink 新弹性和模型属性","slug":"HTML5&CSS/flex-shrink  新弹性盒模型属性","date":"2017-11-09T15:30:54.000Z","updated":"2018-10-22T01:13:44.000Z","comments":true,"path":"2017/11/09/HTML5&CSS/flex-shrink  新弹性盒模型属性/","link":"","permalink":"http://blog.haohome.top/2017/11/09/HTML5&CSS/flex-shrink  新弹性盒模型属性/","excerpt":"语法： flex-shrink： 默认值：1 适用于：flex子项 继承性：无 动画性：是 计算值：指定值","text":"语法： flex-shrink： 默认值：1 适用于：flex子项 继承性：无 动画性：是 计算值：指定值 说明：设置或检索弹性盒的收缩比率。根据弹性盒子元素所设置的收缩因子作为比率来收缩空间。示例：a,b,c将按照1:1:3的比率来收缩空间 12345678910&lt;ul class=\"flex\"&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;&lt;style&gt;.flex&#123;display:flex;width:400px;margin:0;padding:0;list-style:none;&#125;.flex li&#123;width:200px;&#125;.flex li:nth-child(3)&#123;flex-shrink:3;&#125;&lt;/style&gt; flex-shrink的默认值为1，如果没有显示定义该属性，将会自动按照默认值1在所有因子相加之后计算比率来进行空间收缩。 本例中c显式的定义了flex-shrink，a,b没有显式定义，但将根据默认值1来计算，可以看到总共将剩余空间分成了5份，其中a占1份，b占1份，c占3分，即1:1:3 我们可以看到父容器定义为400px，子项被定义为200px，相加之后即为600px，超出父容器200px。那么这么超出的200px需要被a,b,c消化 通过收缩因子，所以加权综合可得2001+2001+200*3=1000px； 于是我们可以计算a,b,c将被移除的溢出量是多少： a被移除溢出量：(2001/1000)200，即约等于40px b被移除溢出量：(2001/1000)200，即约等于40px c被移除溢出量：(2003/1000)200，即约等于120px 最后a,b,c的实际宽度分别为：200-40=160px, 200-40=160px, 200-120=80px","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}],"tags":[{"name":"flex","slug":"flex","permalink":"http://blog.haohome.top/tags/flex/"}],"keywords":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}]},{"title":"关于递归计算","slug":"JavaScript/关于递归计算","date":"2017-02-23T11:14:00.000Z","updated":"2018-04-06T18:06:46.000Z","comments":true,"path":"2017/02/23/JavaScript/关于递归计算/","link":"","permalink":"http://blog.haohome.top/2017/02/23/JavaScript/关于递归计算/","excerpt":"什么是递归在一个函数中直接或间接的调用自己的过程就是递归 1234567function fun()&#123; // 自己调用自己，称为递归调用 fun(); console.log(\"m2\");&#125;fun(); 递归的两种形式: 函数+变量 函数+函数","text":"什么是递归在一个函数中直接或间接的调用自己的过程就是递归 1234567function fun()&#123; // 自己调用自己，称为递归调用 fun(); console.log(\"m2\");&#125;fun(); 递归的两种形式: 函数+变量 函数+函数 函数+变量用递归来求5的阶乘12345678//(n! = n * (n-1)!)//f(n)=n*f(n-1)function func(n)&#123; if(n==1)&#123; return 1; &#125; return n*func(n-1)&#125; 递归的实现1） 边界条件：决定递归何时向上返回 2） 递归前进：只要没满足递归的边界条件，就一直向下调用自己 3） 递归返回：当满足边界条件时，向上返回（将所有计算出来的值，依次返回给调用者） 函数+函数12345678910斐波拉契数列(兔子生兔子题目)--从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子对数为多少// 产量分析：1， 1， 2， 3， 5， 8， 13， 21 。。。// 第n个月的兔子总数 = 第n-1个月的兔子总数 + 第n-2个月的兔子总数// 问题： 求任意月兔子的总数function calc(n)&#123; if(n==0||n==1)&#123; return 1; &#125; return calc(n-1)+calc(n-2);&#125; 一道面试题12345678910111213141516171819202122232425262728293031var obj=&#123; //在页面渲染出value值 value:1, children:[ &#123; value:2, children:[] &#125;, &#123; value:3, children:[&#123; value:4, children:[] &#125;] &#125; ]&#125;//采用无序列表var arr=[\"&lt;ul&gt;\"];function fun(obj)&#123; var li=\"&lt;li&gt;\"+obj.value+\"&lt;/li&gt;\"; arr.push(li); obj.children.map(function(val)&#123; return fun(val) &#125;)&#125;fun(obj);arr.push(\"&lt;/ul&gt;\");var str=arr.join(\"\");var div=document.createElement(\"div\");div.innerHTML=str;document.body.appendChild(div);","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"http://blog.haohome.top/tags/js/"},{"name":"算法","slug":"算法","permalink":"http://blog.haohome.top/tags/算法/"}],"keywords":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.haohome.top/categories/JavaScript/"}]},{"title":"CSS样式----文字长度溢出显示省略号","slug":"HTML5&CSS/CSS样式---文字长度溢出显示省略号","date":"2016-11-02T14:56:24.000Z","updated":"2018-04-06T18:09:38.000Z","comments":true,"path":"2016/11/02/HTML5&CSS/CSS样式---文字长度溢出显示省略号/","link":"","permalink":"http://blog.haohome.top/2016/11/02/HTML5&CSS/CSS样式---文字长度溢出显示省略号/","excerpt":"","text":"text-overflow省略号样式语法结构 text-overflow语法：: clip | ellipsis ```12345678910111213141516171819- text-overflow参数值和解释：clip : 不显示省略标记（...），而是简单的裁切ellipsis : 当对象内文本溢出时显示省略标记（...）- text-overflow应用说明：CSS text-overflow设置或检索是否使用一个省略号标记（...）标示对象内文本文字的溢出。要想实现显示不完内容将显示省略号代替，还需要html nobr标签完成（nobr禁止换行标签）#### text-overflow应用案例- 1、实现方法对象设置text-overflow:ellipsis;省略号样式```csswidth:280px;display: inline-block;text-overflow:ellipsis; white-space:nowrap; /*规定段落中的文本不进行换行*/overflow:hidden;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://blog.haohome.top/categories/CSS/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.haohome.top/tags/css/"}],"keywords":[{"name":"CSS","slug":"CSS","permalink":"http://blog.haohome.top/categories/CSS/"}]},{"title":"CSS学习记录","slug":"HTML5&CSS/CSS学习记录","date":"2016-10-12T12:46:25.000Z","updated":"2018-10-22T01:13:39.000Z","comments":true,"path":"2016/10/12/HTML5&CSS/CSS学习记录/","link":"","permalink":"http://blog.haohome.top/2016/10/12/HTML5&CSS/CSS学习记录/","excerpt":"1.上外边距的溢出在某些特殊条件下，在为子元素设置上外边距时有可能会作用在父元素上 特殊条件：（同时满足） 1.父元素不能有上边框； 2.为第一个子元素设置上外边距时 解决方案： 1、 为父元素增加上边框：会影响父元素的高度 2、 使用父元素的上内边距来取代子元素的上外边距：会影响父元素的高度 3、 在子元素上增加一个空的元素即可","text":"1.上外边距的溢出在某些特殊条件下，在为子元素设置上外边距时有可能会作用在父元素上 特殊条件：（同时满足） 1.父元素不能有上边框； 2.为第一个子元素设置上外边距时 解决方案： 1、 为父元素增加上边框：会影响父元素的高度 2、 使用父元素的上内边距来取代子元素的上外边距：会影响父元素的高度 3、 在子元素上增加一个空的元素即可 2.CSS Sprites雪碧图将若干副不经常变换的图片封装到一幅大图中配合背景图片以及背景图片定位将想看的图片显示出来1） 在页面中创建一个与要显示区域大小一样的元素2） 将雪碧图作为元素的背景图3） 改变图片在元素中的位置（左上移动） 3.背景简写属性——background123background：color url( ) repeat attachment position;background: red;background: url(img/mm.png) no-repeat 95% center; 4.字体属性简写方式属性：font取值：style variant(小型大写字母) weight size family注意：一定要将Family写出来，否则无效 5.伪类选择器1)目标伪类: :target对页面中的某个target元素指定样式，该样式只对在用户点击了页面中的超链接并且跳转到target元素后起作用 2) :before或::before作用:匹配到某元素的内容区域之前 特点:外边距溢出问题3) :after或::after作用:匹配到某元素内容区域之后 解决浮动元素父元素的高度问题 :after 特点：1.在父元素的内容区域之后2.增加一个“空”元素 3.必须是块级元素 4.必须设置clear:both 6.图片和行内快的vertical-align属性控制图片或行内块元素两边的文本，相对于他们的对齐方式 取值： 1. top 2. middle 3. bottom 4. baseline 基线对齐 a) 行内块：基线是在最后一行文本的底部 b) 图片：基线是在图片底部向下3px(不一定)位置处 1img&#123;vertical-align:bottom;&#125; 7. 绝对定位对元素的影响 脱离文档流，允许压在其他元素的上方 绝对定位的元素会变成块级元素. margin可以正常使用，但是margin的左右auto值会失效. 绝对定位的元素，将left，right，bottom，top四个值都设置为0 的情况下，margin:auto会让整个元素变得绝对居中 8.弹性布局8.1 属性:display取值: 1、flex：将块级元素变为弹性布局的容器 2、inline-flex：将行内元素变为弹性布局的容器 注意： 1、 容器中的项目们会自动变为块级元素，允许修改尺寸 2、 项目们的float、clear、vertical-align、全部失效 3、 容器的text-align属性也会失效 8.2 属性flex-wrap取值:1.nowrap 2.wrap 3.wrap-reverse 8.3 justify-content作用：指定项目在主轴上的对齐方式取值： 1、 flex-start在轴的起点对齐 2、 flex-end 在轴的终点对齐 3、 center 居中对齐 4、 space-between 两端对齐，项目之间的间隔都是相等的 5、 space-around 每个项目两边的空白间距是相等的 9.转换 transform取值: 1.位移:translate(x)/translate(x,y)/translateX(x)/translateY(y) 2.缩放:scale(value)/scale（x，y）/scaleX（x）/scaleY（y） 3.旋转:rotate(ndeg) 4.倾斜:skewX(ndeg)/skewY(ndeg)/skew(x)/skew(x,y) 9.1 转换原点 属性:transform-origin 取值:1. 两个值：表示原点在x轴和y轴的位置 2. 三个值：表示原点在x轴、y轴和z轴的位置 可以取数值/百分比/关键字，多个值用空格隔开 9.2 3D转换(模拟人眼睛到3D转换物体的距离，取值越大，表示离物体越远，表示离物体越近) 属性:perspective 取值:rotateX(xdeg) 以x轴为中心轴旋转 rotateY(ydeg) 以y轴为中心轴旋转 rotateZ(zdeg) 以z轴为中心轴旋转 rotate3D(x,y,z,ndeg) x,y,z 取值大于0的话，则该轴参与旋转 x,y,z 取值为0的话，则该轴不参与旋转 rotate3D(1,0,0,45deg)==&gt;rotateX(45deg) 10.过渡 属性:transition 取值:property duration timing-function delay;11.动画样式表中,通过@keyframes规则来声明动画123456789101112131415@keyframes 动画名称name&#123; 0%&#123; /*动画开始时，元素的样式*/ 属性：值; 属性: 值; &#125; 50%&#123; /*动画执行到一半时，元素的样式*/ &#125; 100%&#123; /*动画结束时，元素的样式*/ 属性: 值; 属性: 值; &#125; &#125; 11.1动画声明的浏览器兼容性Firefox：@-moz-keyframes{ } Chrome &amp; Safari: @-webkit-keyframes{ } Oprea: @-o-keyframes{ } 11.2调用动画简写属性:animation取值:name duration timing-function delay iteration-count(播放次数) direction 11.3动画填充模式:animation-fill-mode 取值: 1.none 默认值，无任何效果 2.forwards 档动画播放完成后，元素将保持在最后一个帧的状态上 3.backwards 动画播放前，在延迟时间内，动画将保持在第一帧的状态上 4.both 动画播放前后，分别应用在第一帧和最后一个帧上 11.4动画播放状态animation-play-state 取值 paused：动画暂停 running：动画播放","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}],"tags":[{"name":"css","slug":"css","permalink":"http://blog.haohome.top/tags/css/"},{"name":"html5","slug":"html5","permalink":"http://blog.haohome.top/tags/html5/"}],"keywords":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.haohome.top/categories/HTML5/"}]},{"title":"餐饮研发员的基本素质","slug":"Food/餐饮研发员的基本素质","date":"2016-07-12T14:04:11.000Z","updated":"2018-04-06T18:09:26.000Z","comments":true,"path":"2016/07/12/Food/餐饮研发员的基本素质/","link":"","permalink":"http://blog.haohome.top/2016/07/12/Food/餐饮研发员的基本素质/","excerpt":"餐饮属于快节奏的行业，对研发员的工作是很大的挑战。 现在的餐饮都要做标准化，也要做创新，那么如何去做一位合格的餐饮研发员呢？","text":"餐饮属于快节奏的行业，对研发员的工作是很大的挑战。 现在的餐饮都要做标准化，也要做创新，那么如何去做一位合格的餐饮研发员呢？ 首先要明确研发的定位，设定一个场景： 当一家连锁餐饮企业希望由我们作为他们的中央厨房代加工，他们有自己成熟的菜品，包括配方和工艺，但他们缺少工业化生产的工艺和经验，需要我们为他们解决以达到合作。 这里研发的价值就是：转化客户现有的产品，在保证客户口感的前提下，实现产品和工业化生产，输出工业化生产工艺标准和产品标准。 这里有两种做法： 将客户的产品在研发厨房模拟操作，做到口味相近，写出标准化生产的工艺和产品标准，再去生产车间按标准中试，产品达到客户要求则研发过程结束，产品不合格再调整工艺直到符合客户要求； 对客户的产品进行分拆：原料、配方、工艺、包装、成品。分析成品选择合适的原料，结合研发厨房和测试，确定生产加工的工艺和产品和包装，寻求产品在品质和成本之间的平衡点。 两类研发都输出产品的工业化工艺标准和产品标准，但却有本质的区别。 第一种是标准化转化工作，只能凭借自身丰富的厨政经验和生产实际经验，不断摸索尝试，达到产品输出的目的。只能针对普通要求的客户进行产品制作，专业性差。 第二种是才是研发工作，运用专业的知识从源头为客户提供解决方案。针对客户的需求选用合适的原料和合适的加工工艺，并且在源头就解决产品在输出过程中可能遇到的问题。可以针对不同层次要求的客户进行产品定制，并在研发中不断积累自身的核心产品和加工技术。 做食品研发不仅要明确方向，更要专一、沉稳！浮躁的心做不好研发工作。 餐饮的研发是食品研发中最考验研发员的工作态度的工作，承接餐饮客户的部分产品是必然，这就决定了工作节奏快，不能给你充足的时间去研究产品，以解决问题为主。而在一些项目开发中，你要深度运用自己的专业知识去挖掘。专业的事让专业的人做，研发要追求完美的产品，过程不一定全程参与，但一定要明白产品做出来的关键点也就是核心技术，这样才能掌握产品和标准，你才是产品的核心！ 不论是餐饮客户产品转化还是项目开发，作为一名合格的餐饮研发员，需要明白工作的目的，明确自己的目标，要不断去比较，不断的去总结。 研发是一门独孤求败的匠心工作，追求极致，如果你心沉浸在这里，一切的辛苦，在看到产品被人赞美的那一刻，都是值得的！","categories":[{"name":"food","slug":"food","permalink":"http://blog.haohome.top/categories/food/"}],"tags":[{"name":"工作感想","slug":"工作感想","permalink":"http://blog.haohome.top/tags/工作感想/"}],"keywords":[{"name":"food","slug":"food","permalink":"http://blog.haohome.top/categories/food/"}]},{"title":"一年四季的时令蔬菜水果表","slug":"Food/一年四季的时令蔬菜水果表","date":"2016-06-08T13:28:39.000Z","updated":"2018-04-06T18:09:10.000Z","comments":true,"path":"2016/06/08/Food/一年四季的时令蔬菜水果表/","link":"","permalink":"http://blog.haohome.top/2016/06/08/Food/一年四季的时令蔬菜水果表/","excerpt":"春季（农历一~三月）蔬菜：辣椒、青椒、彩椒、洋葱、花椰菜、甜豆、豌豆、芹菜、莴苣、荠菜、油菜、菠菜、香椿、春笋、马兰头、瓠瓜、韭菜、春韭、菜心、茼蒿、豆苗、蒜苗、春笋等水果：番石榴、青枣、枇杷、桑葚、樱桃、莲雾（春末）。","text":"春季（农历一~三月）蔬菜：辣椒、青椒、彩椒、洋葱、花椰菜、甜豆、豌豆、芹菜、莴苣、荠菜、油菜、菠菜、香椿、春笋、马兰头、瓠瓜、韭菜、春韭、菜心、茼蒿、豆苗、蒜苗、春笋等水果：番石榴、青枣、枇杷、桑葚、樱桃、莲雾（春末）。 夏季（农历四~六月）蔬菜：辣椒、丝瓜、苦瓜、冬瓜、菜豆、芦笋、茭白、洋葱、黄瓜、佛手瓜、南瓜、苋菜、山苏、空心菜、龙须菜、地瓜叶、竹笋、生菜、西红柿、卷心菜、茄子、豇豆、黄瓜、西红柿、东瓜、四季豆、蚕豆等水果：草莓、莲雾、桃、李、西瓜、菠萝、芒果、柠檬、百香果、火龙果、杏、荔枝、猕猴桃、香蕉、椰子、樱桃。 秋季（农历七~九月）蔬菜：秋葵、菱角、莲藕、辣椒、栗子、冬瓜、四季豆（芸豆）、地瓜叶、豆角、山药、白菜、扁豆。 菜花、胡萝卜、藕、大葱、豆角、黄瓜、西红柿、藕、茄子、百合水果：柚子、梨、柿子、木瓜、苹果、莲子、甘蔗、葡萄、火龙果、杨桃、番石榴、杏、橘子、红枣、山楂、核桃。 冬季（农历十~十二月）蔬菜：青椒、卷心菜、白菜、洋葱、花椰菜、胡萝卜、萝卜、甜豆、芹菜、菠菜、芥菜、葵年菜、莴苣、花椰菜、大白菜、油菜、油麦菜、菜心、芥菜、菠菜、黄芽白、芥蓝、荸荠、藕等水果：橙、橘子、柚子、青枣、甘蔗、释迦。 按月份排的时令蔬菜水果 1月：青菜、卷心菜、菠菜、芹菜、萝卜、慈菇等 2月：青菜、卷心菜、菠菜、芹菜、菜尖等 3月：青菜、菠菜、芹菜、菜尖、花菜等 4月：青菜、莴笋、鸡毛菜、芹菜 5月：青菜、卷心菜、莴笋、鸡毛菜、黄瓜、蚕豆、茭白、番茄等 6月：卷心菜、黄瓜、番茄、土豆、鸡毛菜、刀豆（菜豆）、茄子、南瓜等 7月：豇豆、茄子、鸡毛菜、卷心菜、冬瓜、丝瓜、毛豆、辣椒、土豆、扁豆、卷心菜、空心菜等 8月：冬瓜、豇豆、茄子、青菜、鸡毛菜、南瓜、丝瓜、毛豆、辣椒、土豆、扁豆、卷心菜、空心菜等 9月：青菜、冬瓜、萝卜、丝瓜、毛豆、豇豆、茄子、辣椒、芋艿、茭白、卷心菜、扁豆等 10月：青菜、卷心菜、菠菜、芹菜、萝卜、芋艿、茭白、花菜、茼蒿、生菜、花瓜等 11月：青菜、卷心菜、菠菜、芹菜、萝卜、莴笋、花菜、荠菜、草头、生菜、慈菇、青蒜等 12月：青菜、卷心菜、博菜、芹菜、萝卜、塌菜、荠菜、慈菇、花菜等 要吃就吃当季水果各种水果成熟时间汇总 1月(冬季) 木瓜 红香蕉 樱桃番茄 杨桃 柑橘橙 青枣 甘果蔗 草莓 番石榴 牛奶蕉 柑桔 观赏南瓜 无花果 鹤首瓜 2月(冬季) 木瓜 红香蕉 樱桃番茄杨桃 番荔枝 青枣 甘果蔗 草莓 番石榴 牛奶蕉 柑桔 观赏南瓜 鹤首瓜 3月(春季) 枇杷 红香蕉 樱桃番茄杨桃 番荔枝 青枣 甘果蔗 草莓 番石榴 牛奶蕉 柑桔 观赏南瓜 果桑 鹤首瓜 蛇瓜 4月(春季) 枇杷 红香蕉 樱桃番茄荔枝 番荔枝 蛇瓜 甘果蔗 果桑 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 澳州坚果 柠檬 5月(春季) 芒果 红香蕉 樱桃番茄荔枝 番荔枝 蛇瓜 黄皮 果桑 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 李 西瓜 桃 香瓜 柠檬 台湾莲雾 澳州坚果油梨 6月(夏季) 芒果 红香蕉 樱桃番茄荔枝 番荔枝 蒲瓜 黄皮 果桑 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 李 西瓜 桃 香瓜 柠檬 台湾莲雾 澳州坚果菠萝 火龙果油梨 7月(夏季) 芒果 红香蕉 樱桃番茄荔枝 番荔枝 蒲瓜 黄皮 番龙眼 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 李 西瓜 桃 香瓜 柠檬 台湾莲雾 澳州坚果菠萝 火龙果 油梨龙眼 百香果 菠萝蜜 8月(夏季) 芒果 红香蕉 樱桃番茄木瓜 番荔枝 蒲瓜 杨桃 番龙眼 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 日本甜柿 西瓜 黑提子 香瓜 柠檬 菠萝蜜澳州坚果 菠萝 火龙果油梨 龙眼 百香果 9月(秋季) 芒果 红香蕉 鸡蛋果木瓜 番荔枝 百香果 杨桃 番龙眼 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 日本甜柿 西瓜 黑提子 香瓜 柠檬 菠萝蜜油梨 菠萝火龙果 10月(秋季) 樱桃番茄 红香蕉 鸡蛋果木瓜 台湾甜玉米 百香果 杨桃 无花果 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 火龙果 西瓜 黑提子 人心果 柠檬菠萝 油梨 11月(秋季) 樱桃番茄 红香蕉 鸡蛋果木瓜 台湾甜玉米 百香果 杨桃 无花果 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 火龙果 台湾青枣 黑提子 人心果柠檬 菠萝油梨 12月(冬季) 樱桃番茄 红香蕉 鸡蛋果木瓜 草莓 百香果 杨桃 无花果 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 果蔗 台湾青枣 黑提子 人心果 柠檬 菠萝油梨柑橘橙 按季节分的时令蔬果： 春季（农历一~三月） 蔬菜：辣椒、青椒、彩椒、洋葱、花椰菜、甜豆、豌豆、芹菜、莴苣、荠菜、油菜、菠菜、香椿、春笋、马兰头、瓠瓜。水果：番石榴、青枣、枇杷、桑葚、樱桃、莲雾（春末）。 夏季（农历四~六月） 蔬菜：辣椒、丝瓜、苦瓜、冬瓜、菜豆、芦笋、茭白、洋葱、黄瓜、佛手瓜、南瓜、苋菜、山苏、空心菜、龙须菜、地瓜叶、竹笋、生菜、西红柿、卷心菜、茄子。水果：草莓、莲雾、桃、李、西瓜、菠萝、芒果、柠檬、百香果、火龙果、杏、荔枝、猕猴桃、香蕉、椰子、樱桃。 秋季（农历七~九月） 蔬菜：秋葵、菱角、莲藕、辣椒、栗子、冬瓜、四季豆（芸豆）、地瓜叶、豆角、山药、白菜、扁豆。水果：柚子、梨、柿子、木瓜、苹果、莲子、甘蔗、葡萄、火龙果、杨桃、番石榴、杏、橘子、红枣、山楂、核桃。 冬季（农历十~十二月） 蔬菜：青椒、卷心菜、白菜、洋葱、花椰菜、胡萝卜、萝卜、甜豆、芹菜、菠菜、芥菜、葵年菜、莴苣。水果：橙、橘子、柚子、青枣、甘蔗、释迦。 吃当季当地的蔬果,自然成熟的蔬果。吃水果要分清寒热,根据自己的体质选择。 常见水果的性质： 温性水果：山楂、樱桃、石榴、荔枝、青果、木瓜、白果等 凉性水果：西瓜、甜瓜、梨、柑、桔、香蕉、桑椹、柿子、荸荠等。 中性水果：葡萄、苹果、桃、杏、菠萝、龙眼、甘蔗、乌梅等。食物的温寒性 属于寒性的食物有 苦瓜、番茄、茭白、荸荠、菱肉、百合、藕、竹笋、慈姑、魔芋、空心菜、蒲公英、败酱草、鱼腥草、马齿苋、蕨菜、苦菜、荠菜、香椿、莼菜、黑鱼、鲤鱼、河蟹、泥螺、文蛤、蛏子、海蜇、海带、紫菜、田螺、河蚌、蛤蜊、牛奶、豆豉、桑葚、甘蔗、梨、西瓜、柿子、香蕉等。 温热性食物有： 适用于风寒感冒、发热、恶寒、流涕、头痛等症象的生姜、葱白、香菜；适用于腹痛、呕吐、喜热饮等症象的干姜、红茶；适用于肢冷、畏寒、风湿性关节痛等症象的辣椒、酒等。 平性食物有： 大米、黄豆、黑芝麻、花生、土豆、白菜、圆白菜、胡萝卜、洋葱、黑木耳、柠檬猪肉、主题、鸡蛋，鱼肉中的鲤鱼、鲫鱼、泥鳅、黄鱼、鲳鱼。另外我们日常里饮用的牛奶也属于平性食物。 凉性食物有： 荞麦、玉米、白萝卜、冬瓜、蘑菇、芹菜、莴笋、油菜、橙子、苹果等等。 寒性食物有： 小米、绿豆、海带、绿豆芽、苦瓜、西红柿、黄瓜、香蕉、西瓜、甜瓜等等。食物的性是指“四性”，即寒、热、温、凉四种食性。凉性和寒性，温性和热性，在作用上有一定同性。只是在作用大小方面稍有差别。此外，有些食物其食性平和，称为平性。能减轻或消除热证的食物，属寒凉性；能减轻和消除寒证的食物属温热性。一般认为，寒凉性食物大都具有清热、泻火、解毒作用，常用于热性病证。温热性食物大多具有温中、助阳、散寒等作用，常用于寒性病证。平性食物则有健脾、开胃、补益身体的作用。 01.樱桃成熟期在5月中旬到6月中旬； 02.露地草莓在5月中下旬开始采摘，草莓的酸甜味道才浓厚； 03.杏成熟期在5月下旬至7月中旬； 04.桃从6月中旬到10月初都有成熟的； 05.李子早熟品种6月上旬就开始上市，最好吃的品种应在8、9月间成熟; 06.枣品种的成熟期在9月中下旬到10月上旬，大枣才有枣味，在此之前上市的枣又柴又木，根本没法吃； 07.有些苹果品种入伏后就成熟，即“伏苹果”，中晚期成熟的苹果，如“红星”9月底才熟，“富士”系列到10月份才能上市； 08.梨的早熟品种8月上旬成熟，如“绿宝石”，但价钱较贵，大多数梨在9月底或10月初上市； 09.柿子一般在霜降节气，也就是10月下旬才开始上市； 10.桔子分早熟的和晚熟的,一般来说早熟的在8月就可以了,晚熟的话可以晚到11月,不过这也不是绝对的,要看你是在哪个地域,还有就是当年的气候： 11.芒果开花至果实成熟时间因气候和品种而异，一般约需110～150天，6～9月间可陆续采收： 12.柚严格来讲，柚子成熟于深秋和初冬交接的时间， 13.一般的柚品种的成熟期大多集中在11-12月份，但矮晚柚的成熟期在第二年重-2月，正值春节期间； 14.红毛丹每年2月至4月开花，6月至8月为果实成熟采摘季节； 15.菠萝蜜又称木菠萝、树菠萝，海南特产的一种热带桑科常绿乔木。果实6~7月成熟，果实巨大，最重达40公斤，被称为水果之王、热带水果皇后，果实硕大，重者有20至25千克。 16.香蕉-按其种植时期，大致有三种蕉：春种蕉，每年在”雨水”前后的2至3月份种植，8至9月份抽蕾，11至12月份成熟。秋植蕉，一般于秋分前后的9至10月间种植，次年7月份抽蕾，10月中至11月初成熟。还有夏植蕉，于6至8月份种植，次年7月初抽蕾，9月底至10月份采果。以上是正常情况，若遇异常情况，尤其是遇寒害低温，则会延期成熟； 17.桃——桃从6月中旬到10月初都有成熟的； 18.榴莲成熟时间在7·8月，榴莲从树上摘下来后，十天就可成熟； 19.核桃：每年的九月份开始是山核桃的收获季节； 20.柠檬胡成熟季节在冬季； 21.杨梅的成熟期在5-6月份，南方5-6月份又是多雨季节，所以称为梅雨； 22.珍珠番石榴种后6——8个月即可开花结果，第二年即可四季开花结果，开花期集中于4——5月和8——10月，成熟期集中于7——9月和12——1月； 23.菠萝：一般热带一年可两次收获菠萝,有冬春菠萝和夏季菠萝之分,冬春菠萝在4、5月份成熟,夏季菠萝在7月份左右才可收收获； 24.龙眼就是桂圆..桂圆是龙眼干，9月至10月上旬成熟. 25.水蜜桃:依成熟期早晚分为极早熟、早熟、中熟、晚熟、极晚熟5类。果实发育期（即开花盛期至果实成熟所需天数）在80天以内的为极早熟，80～85天的为早熟，100～120天的为中熟，120～150天的为晚熟，150天以上的为极晚熟。 特早熟水蜜桃（5月底、6月上旬成熟） 五月鲜：6月下旬成熟，尖顶圆形，缝合线深而明显，色鲜红，肉脆，汁少，味酸甜。 大久保：7月下旬成熟，果大近圆形，底色黄绿，果顶有红晕，柔软多汁，芳香离核，味甜微酸，品质上等。 白凤：8月上旬成熟，近圆形，果面有鲜红色条纹，皮薄易剥，果肉白中透绿，多汁粘核，味甘甜，品质上等。 巨红水蜜桃：7月上旬成熟，大久保芽变选育而成，单果重200克，含糖量高，有清淡桃香，离皮、离核，品质上等。魁桃：又称红蜜，7月重旬成熟，色淡黄托着鲜红，皮薄肉细，汁多而稠，甘甜如蜜，品质上等 26.番荔枝又称佛头果一年可开花3次，开花至采收需时60~70天，以6月上旬结果最多，5月下旬所结的果最优； 27.荔枝成熟季节在5月初至6月底； 葡萄的正常成熟期是在七八月份，冬天也能吃上葡萄，．．研制了一年两熟的葡萄栽培技术，并开始大面积栽种，预计每次产量可达6万吨； 28.枇杷秋冬开花，春末夏初果实成熟； 29.木瓜一般几时都有； 30.椰子树一年四季都开花，但椰子只在每年最热的时候成熟，椰子的特殊性情使得它对高温特别依恋，所以在热带…； 31.火龙果高产，同时产果期长达6个月，分12至15批成熟火龙果从开花到果实成熟，约35天，当果实由绿色逐渐变红色，果实微香、鲜艳时，就可采收 32.无花果成熟季节在9－10月； 33.芭蕉每年2月至4月开花，6月至8月为果实成熟采摘季节； 34.人心果每年2月至4月开花，6月至8月为果实成熟采摘季节； 35.薄桃在年均温度在20度以上可开花，结果，一般盛花期3－4月，夏、秋季也有零星的花朵开放。果实于5-7月成熟。","categories":[{"name":"food","slug":"food","permalink":"http://blog.haohome.top/categories/food/"}],"tags":[{"name":"蔬菜","slug":"蔬菜","permalink":"http://blog.haohome.top/tags/蔬菜/"},{"name":"水果","slug":"水果","permalink":"http://blog.haohome.top/tags/水果/"}],"keywords":[{"name":"food","slug":"food","permalink":"http://blog.haohome.top/categories/food/"}]},{"title":"浅谈餐饮的标准化","slug":"Food/浅谈餐饮的标准化","date":"2016-05-12T12:25:06.000Z","updated":"2018-04-06T18:09:16.000Z","comments":true,"path":"2016/05/12/Food/浅谈餐饮的标准化/","link":"","permalink":"http://blog.haohome.top/2016/05/12/Food/浅谈餐饮的标准化/","excerpt":"对于餐饮，我其实第一感觉就是不喜欢，因为不规范。 餐饮从业者大部分都是厨师，他们有丰富的厨艺和从业经验，可以说他们炒一个菜是分分钟的事。但是，并不是每一位厨师都是大师，更多的是一个厨子。","text":"对于餐饮，我其实第一感觉就是不喜欢，因为不规范。 餐饮从业者大部分都是厨师，他们有丰富的厨艺和从业经验，可以说他们炒一个菜是分分钟的事。但是，并不是每一位厨师都是大师，更多的是一个厨子。 当前餐饮连锁店都倡导标准化转化，厨师也做起了研发，一道“西红柿炒鸡蛋”可以分解成几种原料形式，分别打包在独立包装，用时拆包混合就行。似乎看起来很简单，但实际做的时候没有那么简单。做一锅一人份的和一锅100人份的西红柿炒鸡蛋的配方和工艺完全不一样，加工的时间、加热的温度、所需要的原辅料添加重量、添加的顺序都需要重新计算，不再是适量、少许、火候、爆香等传统厨师用语来衡量，必须由准确的数据来定量每一道工序，普通的厨师做得到吗？ 现在的餐饮必然会是厨师+食品专业技术人员结合，由厨师做出一道菜，专业人员负责从食材的选择、工艺记录、产品标准制定等整个过程。不仅仅是这样，专业人员还需要研究这道菜在做出来后的风味变化，采用什么的工艺、包装以及储存条件才能让菜品风味保存更久，口感达到最佳的一个状态。这个就需要科学的理论支持。 现在我们总是自以为是，以为自己什么都会，厨师可以去研究专业理论，食品专业的人可以去做菜。真正的资源最大化利用是取长补短，由食品专业的人科普食品加工知识，厨师传授做菜的经验。 一道“西红柿炒鸡蛋”可以有几十种口味，但一份工艺只会产出一种口味或者说几种相近的口味，这就是标准化的能力。 现在的研发厨师不一定会编制这样的工艺，但都懂这样的标准化工艺带来的好处。但进一步的说,如何将这样标准化的菜品提升，可能才是餐饮标准化的核心技术。 菜品进一步分解： 选择不同的食材、采用不同的工艺技术，做出不同等级的菜品； 利用食品添加剂，改善菜品最终的成色和口感； 通过杀菌技术和包装技术，最大程度的延长货架期和保留风味； 总结菜品的加工规律，利用数据分析菜品加工变化，优化菜品加工工艺； 知识是为人服务的并指引正确方向的，资源也是要共享的，餐饮的标准化一定是厨师传授专业人员做菜过程，专业人员用科学的方法指引厨师做菜提升菜品品质。","categories":[{"name":"food","slug":"food","permalink":"http://blog.haohome.top/categories/food/"}],"tags":[{"name":"工作感想","slug":"工作感想","permalink":"http://blog.haohome.top/tags/工作感想/"}],"keywords":[{"name":"food","slug":"food","permalink":"http://blog.haohome.top/categories/food/"}]},{"title":"苹果为什么会褐变","slug":"Food/苹果为什么会褐变","date":"2016-04-18T16:34:14.000Z","updated":"2018-04-10T05:53:46.000Z","comments":true,"path":"2016/04/19/Food/苹果为什么会褐变/","link":"","permalink":"http://blog.haohome.top/2016/04/19/Food/苹果为什么会褐变/","excerpt":"当切开的苹果不及时吃掉，它就会由白色苹果慢慢变成暗淡的棕褐色苹果，影响你的食欲。最好的消息是它依然是安全的苹果，你可以吃掉它。导致苹果变色的原因是酶促褐变，当植物组织内存在的酶与多酚类物质结合在氧气的环境下产生的分子反应，产生的黑色素。","text":"当切开的苹果不及时吃掉，它就会由白色苹果慢慢变成暗淡的棕褐色苹果，影响你的食欲。最好的消息是它依然是安全的苹果，你可以吃掉它。导致苹果变色的原因是酶促褐变，当植物组织内存在的酶与多酚类物质结合在氧气的环境下产生的分子反应，产生的黑色素。 不仅苹果有这种现象，其他水果如梨、香蕉、鳄梨、茄子和土豆都存在酶促褐变，因为他们都存在酶的底物————酚类化合物。 切块的苹果让细胞组织破碎，原本分开的酚类物质和酶相结合，同时当你切开苹果时，酚类物质与酶的混合物就会暴露在空气中，就会产生氧化褐变过程。这个过程持续时间越长，褐变程度越深，直到酚类物质消耗完，这时苹果也就变成棕色的了。 酶只是普通的蛋白质，但是它在自然界中有特殊的功能。大多数化学反应需要较高的活化能才能进行，而酶可以降低化学反应的活化能促使一些反应发生。酶是一种催化剂，它能加快化学反应速率。本身酶在反应过程中不被消耗，也不影响反应的化学平衡。但它会不断催化化学反应进行。有些反应是不可逆的，如水果切块的酶促褐变反应， 但酶在食品中也有重要的积极作用，举个例子：凝乳酶可以促使液态来凝结成奶酪，乳糖酶可以分解我们人体内的乳糖（除非你有乳糖不耐症），食品工业中还利用酶含量来判断海鲜的新鲜度、巴氏杀菌奶的安全以及其他积极应用。此外，酶促褐变反应还有利于茶、咖啡和葡萄干形成理想的色泽。","categories":[{"name":"food","slug":"food","permalink":"http://blog.haohome.top/categories/food/"}],"tags":[{"name":"保鲜知识","slug":"保鲜知识","permalink":"http://blog.haohome.top/tags/保鲜知识/"}],"keywords":[{"name":"food","slug":"food","permalink":"http://blog.haohome.top/categories/food/"}]}]}