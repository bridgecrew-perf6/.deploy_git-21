<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS判断当前文本输入状态]]></title>
    <url>%2F2018%2F08%2F28%2FProgram%2Fjs%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[最近在重构我的网址导航页面,这是我认识前端网页的启蒙项目,网上找的模板,然后修改链接、微调样式，成为了最初的网页导航1.0。 在搜索的时候，我们需要按Enter键实现直接跳转搜索，因此添加了按键监听事件。但问题出现了: 绑定keyup事件会将输入法中的英文文字输入到文字框并直接触发搜索按钮 单纯按键监听，并没有判断中文输入状态 网上查了一些资料： 键盘事件:当一个键盘被按下并松开时,每个浏览器都会触发三个事件:keydown、keypress、keyupkeydown事件发生在按键被按下的时候，接着触发keypress，松开按键的时候触发keyup事件 还有一个事件就是input:input事件能够检测用户的每一次输入 以上事件在英文状态下没有问题,但在中文状态下,依然捕获到的是英文,如下图: 中文输入法 firfox：输入触发keydown，回车确认输入触发keyupchrome：输入触发keydown、keyup，回车确认输入只触发keydownIE：输入触发keydown、keyup，回车确认输入触发keydown，keyupSafari：输入触发keydown、keyup，回车确认输入触发keydown，keyupopera：输入触发keydown、keyup，回车确认输入触发keydown，keyup在input、textarea中，中文输入法时：没有触发keypress事件keypress事件：对中文输入法支持不好，无法响应中文输入；无法响应系统功能键 解决方案: 利用change事件: 监听输入框最终内容变化识别,当文本输入状态完成,并且input失去焦点再触发enter事件 通常情况下,文本框中文输入状态时,按下回车会触发相应的按钮,此时input会失去焦点并触发change事件,此时将输入状态传给按钮事件,即可判断并执行相应事件 利用compositionstart和compositionend事件(事件不兼容旧浏览器) compositionstart:事件触发于一段文字的输入之前 compositionend事件:当文本段落的组成完成或取消时, compositionend事件将被激发 简单来说，非直接输入法如中文输入开始时，触发compositionstart事件，结束时触发compositionend事件 两类解决方案都可以监听到当前输入框的输入状态,结合input事件，就能对所有的输入进行实时的检测了 1234567891011121314151617var doing=false;var doSomething=function(e)&#123; //我要干点啥&#125;document.getElementById('testInput').addEventListener('compositionstart',function(e)&#123; doing=true;&#125;,false);document.getElementById('testInput').addEventListener('input',function(e)&#123; if(!doing)&#123; doSomething(); &#125;&#125;,false);document.getElementById('testInput').addEventListener('compositionend',function(e)&#123; doing=false; doSomething();&#125;,false);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>input</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hashchange事件]]></title>
    <url>%2F2018%2F08%2F28%2FProgram%2Fhashchange%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[最近在写公司的后台管理系统，因为需求需要刷新后保持原来页面,原有的单页面组件跳转方式不能满足，所以在原有项目基础上增加了路由功能,目前比较简单的路由切换就是通过监听hash变化，实现不同页面的加载。 当 一个窗口地址的 hash （URL 中 # 后面的部分）改变时就会触发 hashchange 事件: 1234window.onhashchange = handleHashChange;window.addEventListener("hashchange",function(event)&#123; //hash变化的处理逻辑&#125;) hashchange 事件回调函数对象主要有两个参数会用到: newURL: 当前页面新的URL oldURL: 当前页面旧的URL 但在IE浏览器里,这两个属性不被支持,需要在绑定hashchange事件前添加以下代码: 12345678if(!window.HashChangeEvent)(function()&#123; var lastURL=document.URL; window.addEventListener("hashchange",function(event)&#123; Object.defineProperty(event,"oldURL",&#123;enumerable:true,configurable:true,value:lastURL&#125;); Object.defineProperty(event,"newURL",&#123;enumerable:true,configurable:true,value:document.URL&#125;); lastURL=document.URL; &#125;);&#125;());]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>hash</tag>
        <tag>兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收机制与内存管理]]></title>
    <url>%2F2018%2F07%2F11%2FJavaScript%2F%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 垃圾回收机制JavaScript是一门高级语言,具有自动垃圾回收机制(Garbage Collecatio), js创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放,其主要原理为: 垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。 JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 任何程序语言,内存生命周期都是一致的: 分配你所需要的内存 使用分配到的内存（读、写） 不需要时将其释放/归还 JavaScript的内存分配 在定义变量时就完成了内存分配: 123456var n = 123; // 给数值变量分配内存var s = "hello"; // 给字符串分配内存var o = &#123; a: 1, b: null&#125;; // 给对象及其包含的值分配内存 通过函数调用分配内存 12var d = new Date(); // 分配一个 Date 对象var e = document.createElement('div'); // 分配一个 DOM 元素 当内存不再需要使用时释放 不再使用的变量也就是内存生命周期的结束,只可能是局部变量,局部变量只在函数的执行过程中存在,全局变量的生命周期直至浏览器卸载页面才会结束。 1234567891011function fn1() &#123; var obj = &#123;name: 'hanzichi', age: 10&#125;;&#125;function fn2() &#123; var obj = &#123;name:'hanzichi', age: 10&#125;; return obj;&#125;var a = fn1();var b = fn2(); 上面定义了两个function，分别叫做fn1和fn2: 当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象{name: &#39;hanzichi&#39;, age: 10},当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放； 在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。 所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，垃圾回收算法主要依赖于引用的概念。 在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。 例如:一个Javascript对象具有对它原型的引用（隐式引用）和对它属性的引用（显式引用）。 1.1 标记清除这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”; 12345function test()&#123; var a = 10 ; //被标记 ，进入环境 var b = 20 ; //被标记 ，进入环境&#125;test(); //执行完毕 之后 a、b又被标离开环境，被回收。 1.2 引用计数引用计数的含义是跟踪记录每个值被引用的次数。 当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。 123456function test()&#123; var a = &#123;&#125; ; //a的引用次数为0 var b = a ; //a的引用次数加1，为1 var c =a; //a的引用次数再加1，为2 var b =&#123;&#125;; //a的引用次数减1，为1&#125; 引用计数这种方式在老式浏览器中采用,在循环引用是会出现内存泄露问题: 1234567function fn() &#123; var a = &#123;&#125;; var b = &#123;&#125;; a.pro = b; b.pro = a;&#125;fn(); 标记清除: fn()执行完毕后，两个对象都已经离开环境,内存回收; 引用计数: fn()执行完毕后,a和b的引用次数都是2,不会被垃圾回收器回收内存;如果fn函数被大量调用，就会造成内存泄露。(在IE7与IE8上，内存直线上升) IE中有一部分对象并不是原生js对象。例如，其内存泄露DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使IE的js引擎采用标记清除策略来实现，但js访问的COM对象依然是基于引用计数策略的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。 1234window.onload=function outerFunction()&#123; var obj = document.getElementById("element"); obj.onclick=function innerFunction()&#123;&#125;;&#125;; obj引用了document.getElementById(“element”)，而document.getElementById(“element”)的onclick方法会引用外部环境中德变量，自然也包括obj，是不是很隐蔽? 最简单的方式就是自己手工解除循环引用: 12345window.onload=function outerFunction()&#123; var obj = document.getElementById("element"); obj.onclick=function innerFunction()&#123;&#125;; obj=null;&#125;; IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变 2. 内存管理2.1 合理的方案当前比较合理的方案是标记清除: 遍历所有可访问的对象; 回收已不可访问的对象 2.2 GC的缺陷和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>你不知道的JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[点击事件重复请求]]></title>
    <url>%2F2018%2F05%2F29%2FJavaScript%2F%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[引子当我们针对某个按钮绑定点击事件后，就可以随时通过点击鼠标来触发按钮的点击事件，如： 12345var num = 1;$('ele').on('click',function()&#123; num++; //执行的业务逻辑&#125;) 这样num值会不断增加，依赖于num值的业务逻辑就会出错；一般出现的场景有： ajax请求; 问卷答题 接下来我们根据这些场景来分析下; 场景分析1. ajax提交 当用户短时间内重复点击登录按钮时,会触发多次的表单提交;解决方案: 当点击提交按钮后,给按钮添加disabled属性,事件完成后再removeAttr(&#39;disabled&#39;) 2. 问卷答题 当选择一个答案时,重复点击,机会造成num重复增加,可能会造成中间某些选题未答直接跳到后面的答题，而添加一个name数组判断是否重复就可以避免该问题; 总结解决重复点击问题可以归结为标记作用位点，有两种方法: 点击触发请求后，作用点设为disabled属性，请求（或者包括请求后具体的业务流程处理）后，移除disabled属性； 记录作用点，判断作用点是否重复，重复则直接return 其实ajax还有一个更好的方法来避免重复提交,我们知道js是单线程执行事件的,所以可以根据此原理定义事件序列，重新封装ajax方法来避免。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>event</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex入门基础]]></title>
    <url>%2F2018%2F05%2F14%2FJavaScript%2FVuex%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1. Vuex 概念Vuex 是一个状态管理模式,它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。 每一个 Vuex 应用的核心就是 store(仓库)，在store中包含组件中的共享状态state和改变状态的方法mutations。 store仓库 12345678910111213import Vue from 'vue';import Vuex from 'vuex';Vue.use(Vuex);const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;&#125;) 1) Vuex 的状态存储是响应式的2) 不能直接改变 store 中的状态,需显式地提交 (commit) mutation 2. State单一状态树用一个对象包含全部的应用层级状态 Vuex 通过 store 选项，将状态从根组件“注入”到每一个子组件中,子组件需调用 Vue.use(Vuex)： 根组件: 123456//根组件:const app = new Vue(&#123; el: '#app', store, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 components: &#123; Counter &#125;,&#125;) 子组件: 通过computed(计算属性)返回this.$store.state.count来获取相应数据 1234567const Counter = &#123; computed: &#123; count () &#123; return this.$store.state.count //获取根组件的state &#125; &#125;&#125; mapState 辅助函数简化生成计算属性 1234567import &#123; mapState &#125; from 'vuex';export default &#123; computed: mapState (&#123; count: state =&gt; state.count, countAlias: 'count', // 别名 `count` 等价于 state =&gt; state.count &#125;)&#125; 还可以更简化: 1234computed: mapState([ // 映射 this.count 为 store.state.count 'count']) 3. Getter 从 store 中的 state 派生出状态如果我们需要对state对象进行做处理计算，如对列表进行过滤并计数: 12345computed: &#123; doneTodosCount () &#123; return this.$store.state.todos.filter(todo =&gt; todo.done).length &#125;&#125; 如果多个组件都要进行这样的处理，那么就要在多个组件中复制该函数,这样效率低下。 Vuex中getters对象，可以方便我们在store中做集中的处理,Getters接受state作为第一个参数：: 12345678910111213const store = new Vuex.Store(&#123; state: &#123; todos: [ &#123; id: 1, text: '...', done: true &#125;, &#123; id: 2, text: '...', done: false &#125; ] &#125;, getters: &#123; doneTodos: state =&gt; &#123; return state.todos.filter(todo =&gt; todo.done) &#125; &#125;&#125;) Getter 会暴露为 store.getters 对象，可以以属性的形式访问这些值： 1store.getters.doneTodos // -&gt; [&#123; id: 1, text: '...', done: true &#125;] Getter 也可以接受其他 getter 作为第二个参数： 123456getters: &#123; doneTodosCount: (state, getters) =&gt; &#123; return getters.doneTodos.length &#125;&#125;store.getters.doneTodosCount // -&gt; 1 mapGetters辅助函数与mapState类似，都能达到简化代码的效果mapGetters辅助函数仅仅是将store中的getters映射到局部计算属性： 12345678910111213import &#123; mapGetters &#125; from 'vuex'export default &#123; // ... computed: &#123; // 使用对象展开运算符将 getters 混入 computed 对象中 ...mapGetters([ 'doneTodosCount', 'anotherGetter', // ... ]) &#125;&#125; 也可写作: 12345computed: mapGetters([ 'doneTodosCount', 'anotherGetter', // ...]) 所以在Vue的computed计算属性中会存在两种辅助函数： 123456789import &#123; mapState, mapGetters &#125; from 'vuex';export default &#123; // ... computed: &#123; mapState(&#123; ... &#125;), mapGetter(&#123; ... &#125;) &#125;&#125; 4. Mutation 更改 Vuex 的 store 中的状态每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler) 1234567891011const store = new Vuex.Store(&#123; state: &#123; count: 1 &#125;, mutations: &#123; increment (state) &#123; //type:'increment' // 变更状态 state.count++ &#125; &#125;&#125;) 要唤醒一个 mutation handler，你需要调用 store.commit 方法调用mutation type: store.commit(&#39;increment&#39;) 提交载荷（Payload） 向 store.commit 传入第二个参数,也就是mutation的payload: 123456mutations: &#123; increment (state, n) &#123; state.count += n &#125;&#125;store.commit('increment', 10) 单单传入一个n，可能并不能满足我们的业务需要，这时候我们可以选择传入一个payload对象： 12345mutation: &#123; increment (state, payload) &#123; state.totalPrice += payload.price + payload.count; &#125;&#125; 对象风格的提交方式提交 mutation 的另一种方式是直接使用包含 type 属性的对象： 1234store.commit(&#123; type: 'increment', amount: 10&#125;) mapMutations函数使用mapMutations辅助函数将组件中的methods映射为store.commit调用。 12345678910111213import &#123; mapMutations &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapMutations([ 'increment' // 映射 this.increment() 为 this.$store.commit('increment') ]), ...mapMutations(&#123; add: 'increment' // 映射 this.add() 为 this.$store.commit('increment') &#125;) &#125;&#125; 5.Action Action 提交的是 mutation，而不是直接变更状态。 Action 可以包含任意异步操作。 在vuex中,mutation是同步事件:store.commit(&#39;increment&#39;) 123456789101112131415const store = new Vuex.Store(&#123; state: &#123; count: 0 &#125;, mutations: &#123; increment (state) &#123; state.count++ &#125; &#125;, actions: &#123; increment (context) &#123; context.commit('increment') &#125; &#125;&#125;) Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。 分发ActionAction 通过 store.dispatch 方法触发：store.dispatch(&#39;increment&#39;); Actions 支持同样的载荷方式和对象方式进行分发： 12345678910// 以载荷形式分发store.dispatch('incrementAsync', &#123; amount: 10&#125;)// 以对象形式分发store.dispatch(&#123; type: 'incrementAsync', amount: 10&#125;) 在组件中分发Action在组件中使用 this.$store.dispatch(&#39;xxx&#39;) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用 123456789101112131415import &#123; mapActions &#125; from 'vuex'export default &#123; // ... methods: &#123; ...mapActions([ 'increment', // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')` // `mapActions` 也支持载荷： 'incrementBy' // 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)` ]), ...mapActions(&#123; add: 'increment' // 将 `this.add()` 映射为 `this.$store.dispatch('increment')` &#125;) &#125;&#125; 组合 ActionAction 通常是异步的，如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？ 首先，你需要明白 store.dispatch 可以处理被触发的 action 的处理函数返回的 Promise，并且 store.dispatch 仍旧返回 Promise： 12345678910actions: &#123; actionA (&#123; commit &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; commit('someMutation') resolve() &#125;, 1000) &#125;) &#125;&#125; 这样就可以: 123store.dispatch('actionA').then(() =&gt; &#123; // ...&#125;) 在另外一个 action 中也可以： 12345678actions: &#123; // ... actionB (&#123; dispatch, commit &#125;) &#123; return dispatch('actionA').then(() =&gt; &#123; commit('someOtherMutation') &#125;) &#125;&#125; 如果我们利用 async / await，我们可以如下组合 action： 1234567891011// 假设 getData() 和 getOtherData() 返回的是 Promiseactions: &#123; async actionA (&#123; commit &#125;) &#123; commit('gotData', await getData()) &#125;, async actionB (&#123; dispatch, commit &#125;) &#123; await dispatch('actionA') // 等待 actionA 完成 commit('gotOtherData', await getOtherData()) &#125;&#125; 一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js的web服务器路由重构]]></title>
    <url>%2F2018%2F05%2F02%2FJavaScript%2FNode.js%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B7%AF%E7%94%B1%E9%87%8D%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Node使JavaScript操作服务器成为可能，同时其带来了强大的文件操作方法。我们在创建一个服务器时，会遇到路由切换的问题，当前express等库是可以识别不同路由并执行不同操作的，最近在回顾Node.js的一些用法，这里就尝试采用原生的方法重构一个路由功能。 原始路由方法： 12345678910111213141516171819const http=require('http');const fs=require('fs');let server=http.createServer(function(req,res)&#123; if(req.url=='/index')&#123; res.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是首页&lt;/h1&gt;') &#125;else if(req.url=='/products')&#123; res.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是产品页&lt;/h1&gt;') &#125;else if(req.url=='/detail')&#123; res.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是详情页&lt;/h1&gt;') &#125;else&#123; res.writeHead(404, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); res.write('&lt;h1&gt;这是404页&lt;/h1&gt;') res.end('欢迎来到NodeJs');&#125;)server.listen(3000);console.log('开始监听3000端口') 这样的路由方法看似结构清晰，但实际情况比这复杂的多，有大量的路由和相应的页面响应方法，就会显得臃肿了。 其实，我们可以采用ES6的模块语法，使创建服务器、路由控制、地址处理方法执行分别处于不同模块，最终在一个入口文件中引入： 服务器模块: 123456789101112131415const http=require('http');//1.http创建服务器并监听端口方法function startServer(route,handle)&#123; var onRequest=function(req,resp)&#123; //路由处理 route(handle,req.url,resp); &#125; //http创建服务器 var server= http.createServer(onRequest) //服务器监听3000端口 server.listen(3000,'127.0.0.1'); console.log('运行在3000端口');&#125;//2.导出路由模块module.exports.startServer = startServer; 地址处理方法: 123456789101112131415161718192021222324const fs=require('fs');//网站默认图标function favicon(resp)&#123; fs.createReadStream(__dirname +'/favicon.ico').pipe(resp);&#125;//首页function index(resp)&#123; fs.createReadStream(__dirname +'/index.html','utf8').pipe(resp);&#125;//产品页function products(resp)&#123; fs.createReadStream(__dirname +'/products.html','utf8').pipe(resp);&#125;//详情页function detail(resp)&#123; fs.createReadStream(__dirname +'/detail.html','utf8').pipe(resp);&#125;//将不同页面的方法导出module.exports=&#123; index:index, products:products, detail:detail, favicon:favicon&#125; 路由模块: 123456789101112const fs=require('fs');//1.路由处理方法function route(handle,url,resp)&#123; if(typeof handle[url] ==='function')&#123; resp.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); handle[url](resp); &#125;else&#123; resp.writeHead(404, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); fs.createReadStream(__dirname+'/404.html','utf8').pipe(resp); &#125;&#125;module.exports.route=route; 入口app.js 1234567891011121314var server=require('./server');var router=require('./router')var handler = require('./handler');//1.匹配url地址,var handle = &#123;&#125;;handle["/"] = handler.index;handle['/index'] = handler.index;handle['/products'] = handler.products;handle['/detail'] = handler.detail;handle['/favicon.ico'] = handler.favicon;//2.启动服务器server.startServer(router.route,handle) 这样如果增加路由页面，只需在相应的位置依次增加即可，结构清晰！ 当使用GET或POST请求时，需要对服务器模块做一些更改: 请求为GET时,解析路由地址’?’后面的query语句; 请求为POST时,监听数据流并解析; 123456789101112131415161718192021222324252627282930const http=require('http');const url=require('url');const queryString=require('querystring');function startServer(route,handle)&#123; var onRequest=function(req,resp)&#123; //url路径 var pathName=url.parse(req.url).pathname; //请求为POST时,监听数据流 if(req.method=="POST")&#123; var data=""; req.on('error',function(err)&#123; console.log(err); &#125;).on('data',function(chunk)&#123; data+=chunk; &#125;).on('end',function()&#123; var params=queryString.parse(data); route(handle,pathName,resp,params); &#125;) &#125; //请求为GET时,解析路由query else&#123; var params=url.parse(req.url,true).query; route(handle,pathName,resp,params); &#125; &#125; var server= http.createServer(onRequest) server.listen(3000,'127.0.0.1'); console.log('运行在3000端口');&#125;module.exports.startServer = startServer; 相应的，增加router和handler的传参。 详细代码：Demo-web]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟jQuery的ajax方法封装]]></title>
    <url>%2F2018%2F04%2F14%2FJavaScript%2F%E6%A8%A1%E6%8B%9FjQuery%E7%9A%84ajax%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[ajax在我们的前后端交互占据着重要的位置,前段时间在自己的小项目里模仿jQuery的模式封装了ajax请求的方法,但似乎没有达到满意的效果,同步异步实现并不是很满意,而且有一些局限性。感觉还是要单独拿出来记录，深入的去剖析ajax的原生封装更为妥当！ jQuery的常规ajax实现：123456789101112$.ajax(&#123; url:"http://....", method:"GET", data:&#123;&#125;, dataType:'json', success:function(resp,status)&#123; console.log(resp) &#125;, error:function(err)&#123; console.log(err) &#125;&#125;) 可以看到jQuery的ajax方法是$.ajax()传了一个对象参数。 ajax交互的四个基本步骤: 创建对象 创建请求xhr.open; 设置onreadystatechange，判断readyState以及status并接受响应 发送请求：xhr.send() 创建的对象obj需要包含url、method、data、dataType、success、error等属性 获得xhr对象: 判断请求方法是get还是post data参数处理 ajax请求状态判断,要考虑重定向的情况 获得响应数据 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var $=&#123; /*get方法传入data,返回一个拼接好的字符串uname=min&amp;age=12*/ params:function(data)&#123; var arr=[]; for(var key in data)&#123; arr.push(key+"="+data[key])//将对象键值对以字符串形式存入数组中 &#125; var str=arr.join("&amp;"); return str; &#125;, /*该方法发送http请求*/ ajax:function(obj)&#123; var url=obj.url; var type=obj.method || obj.type;//支持方法属性为method或type; var async=obj.async == undefined ? true : obj.async; var data = obj.data == undefined ? &#123;&#125; : obj.data; var success=obj.success; var error=obj.error; //创建一个XMLHttpRequest 对象 var xhr; if(window.XMLHttpRequest)&#123; xhr=new XMLHttpRequest(); &#125;else&#123; //微软IE浏览器的xhr对象 xhr=new ActiveXObject("MicroSoft.XMLHttp") &#125;; //判断请求类型是"get"还是"post" if(type.toLowerCase()==="get")&#123; //get类型的url参数为拼接字符串 url=url+"?"+this.params(data); data=null; &#125;else&#123; //post类型要给服务器端一个请求头 xhr.setRequestHeader('Content-Type',"application/x-www-form-urlencoded") &#125; //创建请求 xhr.open(type,url,async); //当xhr的readyState发生改变时，要自动激发的操作 xhr.onreadystatechange=function()&#123; //返回的状态可能为200成功,也可能是304重定向 if(xhr.readyState==4 &amp;&amp; xhr.status==200 || xhr.status==304)&#123; var respData=xhr.responseText; success(data);// &#125;else&#123; error(); &#125; &#125; //xhr.send()方法要放在后面,这样xhr.onreadystatechange方法提前绑定监听xhr.readyState,同步请求才能拿到数据 xhr.send(data); //get类型data为null &#125;&#125; 以上有一点需要注意,就是xhr.send()方法一定要放在最后,这样xhr.onreadystatechange才能监听xhr的readyState变化,否则同步发送请求时不能监听xhr的readyState变化]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>ajax</tag>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域请求的jsonp处理]]></title>
    <url>%2F2018%2F04%2F07%2FWeb%2F%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84jsonp%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[跨域简介跨域是指不用域之间相互请求资源,只要协议，主机名，端口号，二级域名等不同都算跨域。 浏览器认为多数由js程序发起的跨域请求都是不合法的，主要为xhr，但不由js发起的跨域是允许的，包括：img，link，script，iframe； JSONP JSON with Padding 填充式 json 正常的ajax请求是不允许跨域请求的，只能用允许跨域请求的元素script代替 处理步骤 客户端定义一个专门处理相应的有名函数doResponse(处理函数中仅接受并处理服务端json数据,不用xhr对象，更不用判断状态) 服务器端php: 接受请求数据并处理,返回一条js语句echo ‘doResponse($json)’; 动态创建一个script元素,设置src指向服务器端的php地址 客户端js: 12345678910function doResponse(resp)&#123; console.log(resp); for(var i in resp)&#123; console.log(i); &#125; &#125;$("#btn").click(function() &#123; /*动态追加script元素*/ $("body").append(`&lt;script src="http://127.0.0.1/jsonp.php?callback=doResponse"&gt;&lt;\/script&gt;`); &#125;); 也可以采用ajax获得返回数据 1234567891011$.getJSON("https://www.haohome.top/demo/jsonp.php?callback=doResponse",data=&gt;&#123; console.log(data);&#125;);$.ajax(&#123; type:"GET", url:"https://www.haohome.top/demo/jsonp.php?callback=doResponse", success:data=&gt;&#123; console.log("返回数据",data); &#125;, dataType:"jsonp"&#125;) 服务器端php: 1234header("Content-type:application/javascript;charset:utf-8");$getData=$_GET['callback'];$hello=json_encode([1,2,3,4]);echo $getData."('$hello')"; ​]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建对象的Object.create与new]]></title>
    <url>%2F2018%2F04%2F07%2FJavaScript%2F%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84Object.create%E4%B8%8Enew%2F</url>
    <content type="text"><![CDATA[创建对象有几种方式: 直接量: 123var obj1=&#123;name:"xiaowang"&#125;;var obj2=new Object(&#123;name:"xiaowang"&#125;);console.log(obj1,obj2); 构造函数: 123var M=function(name)&#123;this.name=name&#125;;var obj3=new M('xiaowang');console.log(obj3); Object.create 123var p=&#123;name:'xiaowang'&#125;;var obj4=Object.create(p);console.log(obj4); 对应的输出结果为: 可以看到,Object.create方法得到的对象是空对象，再输出各自对象的name属性看看: console.log(obj2.name,obj3.name,obj4.name) 得到的结果为xiaowang xiaowang xiaowang 这是为什么??? Object.create 的实现方式: 1234567var obj1 = Object.create(null);console.log(obj1); // &#123;&#125;obj1.name = 'jian';var obj2 = Object.create(obj1);console.log(obj2); // &#123;&#125;console.log(obj2.name); // 'jian', conosle.log(obj2.__proto__===obj1.prototype) //true obj2是空对象,但obj2.name输出了’jian’,obj2继承自obj1的原型对象 由此可以总结Object.create()做了： ​ 1. 创建空对象{} ​ 2. 指定空对象{}继承自参数的原型对象,即空对象的 __proto__ 指向Object.create()参数的原型对象。 var obj1=new M({name:&#39;xiaowang&#39;}) 的实现方式: 123456789101112//定义构造函数Person var Person = function (name) &#123; this.name = firstName;&#125;;//定义Person原型对象的新方法Person.prototype.sayHello = function() &#123; console.log("Hello, I'm " + this.name);&#125;;//实例化对象var person1 = new Person("Alice");//对象调用methodperson1.sayHello(); // logs "Hello, I'm Alice" 由此可以总结new做了： 创建实例对象person1 调用构造函数(Person)初始化person1成员变量（name)。 指定实例对象的继承自Person.prototype对象。即person1.__proto__指向构造函数的原型对象Person.prototype。 对比 Object.create new 创建对象 创建空对象 创建实例对象,并将参数初始化赋值 继承 空对象继承自参数对象的原型对象,本身为空对象 实例对象继承自构造函数的原型对象 总结:Object.create得到的对象未实例化,本身为空对象,可继承对象,而new得到的对象是实例化的对象]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器缓存问题]]></title>
    <url>%2F2018%2F03%2F29%2FWeb%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[请求缓存的路线图: 两个概念 强缓存用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。 协商缓存用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源。 共同点: 客户端获得的数据最后都是从客户端缓存中获得 区别: 强缓存不与服务器交互，而协商缓存则需要与服务器交互。 四个过程详解（a）浏览器判定是否有缓存所谓“客户端缓存”就是指用户设备中本地资源。不同浏览器缓存文件的地址也不尽相同。 对于一个html页面，缓存分3部分，一个是页面内容，一个是css样式，一个是JS文件 我们以chrome为例来查看下浏览器缓存文件的地址，1）首先在chrome中输入：chrome://chrome-urls/，看到一堆列表,里面隐藏了许多浏览器的奥秘，有兴趣的可以自己深扒。2）找到 chrome://cache（当然也可以直接输入这个地址） （b）缓存是否过期 expires Http1.0 中的标准，表明过期时间，注意此处的时间都是指的是服务器的时间。 存在的问题：服务器时间与客户端时间的不一致，就会导致缓存跟期待效果出现偏差。 Cache-ControlHttp1.1 中的标准，可以看成是 expires 的补充。使用的是相对时间的概念。Cache-Control的属性: 1）max-age: 设置缓存的最大的有效时间，单位为秒（s）。max-age会覆盖掉Expires 2) s-maxage: 只用于共享缓存，比如CDN缓存（s -&gt; share）。与max-age 的区别是：max-age用于普通缓存，而s-maxage用于代理缓存。如果存在s-maxage,则会覆盖max-age 和 Expires. 3) public：响应会被缓存，并且在多用户间共享。默认是public。 4) private: 响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。 5）no-cache: 指定不缓存响应，表明资源不进行缓存。但是设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。 6）no-store: 绝对禁止缓存。 7）must-revalidate: 如果页面过期，则去服务器进行获取。 所以判断缓存是否过期步骤是：1） 查看是否有cache-control 的max-age / s-maxage , 如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期2）查看是否有cache-control 的max-age / s-maxage，则用expires 作为过期时间比较 总结：（b）过程执行完后，如果判定为未过期，则使用客户端缓存。那么就是属于“强缓存”。 （c）跟服务器协商是否使用缓存 到这一步的时候，浏览器会向服务器发送请求，同时如果上一次的缓存中有Last-modified 和 Etag 字段，浏览器将在request header 中加入If-Modified-Since（对应于Last-modified）， 和If-None-Match（对应于Etag）。 Last-modified: 表明请求的资源上次的修改时间。 If-Modified-Since：客户端保留的资源上次的修改时间。 Etag：资源的内容标识。（不唯一，通常为文件的md5或者一段hash值，只要保证写入和验证时的方法一致即可） If-None-Match： 客户端保留的资源内容标识。 1） 分布式系统尽量关闭Etag，因为每台机器生成的Etag都不一样。2）分布式系统里多台机器间文件的Last-Modified必须一致，以免负载均衡不同导致对比失败。 通常情况下，如果同时发送 If-None-Match 、If-Modified-Since字段，服务器只要比较etag 的内容即可，当然具体处理方式，看服务器的约定规则。 （d）协商缓存在这个阶段，服务器一般会将Cache-control、expires 、last-modified、date、etag 等字段在response header 中返回，便于下次缓存。当然具体的场景，也是看服务器的约定规则设定。 缓存的不同来源from disk cache从磁盘中获取缓存资源，等待下次访问时不需要重新下载资源，而直接从磁盘中获取。它的直接操作对象为CurlCacheManager。 from memory cache从内存中获取资源，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。目前Webkit资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类： MainResourceLoader和SubresourceLoader。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，JS等），以及解码过的图片数据。 区别当退出进程时，内存中的数据会被清空，而磁盘的数据不会，所以，当下次再进入该进程时，该进程仍可以从diskCache中获得数据，而memoryCache则不行。 相似diskCache与memoryCache相似之处就是也只能存储一些派生类资源文件。它的存储形式为一个index.dat文件，记录存储数据的url，然后再分别存储该url的response信息和content内容。Response信息最大作用就是用于判断服务器上该url的content内容是否被修改。 用户行为 解决方案:1、页面内容 2、CSS和JS文件 改成 就是只要在每次修改后改一下版本号即可 这样每次修改后都要改，有没有自动加版本号的东西，估计有，如果是JSP和php可以通过脚本自动生成，如果是纯html也可以通过document.write，或者用动态加载JS的框架啥的。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通俗易懂的原型与原型链]]></title>
    <url>%2F2018%2F03%2F11%2FJavaScript%2F%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[普通对象与函数对象123456789101112131415var o1 = &#123;&#125;; var o2 =new Object();var o3 = new f1();function f1()&#123;&#125;; var f2 = function()&#123;&#125;;var f3 = new Function('str','console.log(str)');console.log(typeof Object); //function console.log(typeof Function); //function console.log(typeof f1); //function console.log(typeof f2); //function console.log(typeof f3); //function console.log(typeof o1); //object console.log(typeof o2); //object console.log(typeof o3); //object 上面的例子中: o1、o2、o3都是普通对象object，而f1、f2、f3是函数对象function 凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1、f2归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的。 构造函数12345678function Student(name, age, job) &#123; this.name = name; this.age = age; this.job = job; this.intr = function() &#123; console.log(this.name+"年龄是"+this.age) &#125; &#125;var lilei = new Student('lilei', 28, 'Software Engineer');var hmm = new Student('hmm', 23, 'Doctor'); 这个例子中lilei、hmm都是构造函数Student的实例 原型对象JavaScript中,每定义一个对象,对象中都会包含一些预定义的属性,每个普通对象和函数对象都包含__proto__ ，而每个函数对象都会有prototype 属性，指向函数的原型对象; 看一个简单示意图: 例子中,Student 是构造函数(昵称”妈”),其prototype(原型对象)就是Student.prototype (昵称”爹”)，原型对象(爹)的构造函数属性(妈)是构造函数，而lilei和hmm都是构造函数Student(妈)的实例(儿子/女儿)，儿子/女儿都继承(__proto__)了爹，遗传了爹的方法和属性，用公式表示即： 12Student===Student.prototype.constructor; //truelilei.__proto__===Student.prototype; //true 构造函数具有prototype 属性，指向原型对象 原型对象具有constructor 属性，指向构造函数 实例对象具有__protot__ 属性，指向原型对象 从 ECMAScript 6 开始，[[Prototype]] 可以通过Object.getPrototypeOf()和Object.setPrototypeOf()访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 __proto__。 原型对象其实就是普通对象，但Function.prototype除外，它是函数对象，且没有prototype属性(前面说函数对象具有prototype属性) 123456function Student()&#123;&#125;; console.log(Student.prototype) //Student&#123;&#125; 空对象,具有constructor属性 console.log(typeof Student.prototype) //object console.log(typeof Function.prototype) // function，这个特殊 console.log(typeof Object.prototype) // object console.log(typeof Function.prototype.prototype) //undefined 原型对象的应用原型对象的应用主要就是继承 12345678910var Student = function(name)&#123; this.name = name; // tip: 当函数执行时这个 this 指该构造函数的实例 &#125;;/*给Student添加getName方法*/ Student.prototype.getName = function()&#123; return this.name; // tip: 当函数执行时这个 this 指该构造函数的实例 &#125; var lilei = new Student('lilei'); console.log(lilei.name); //'lilei' 此时 lilei 已经有 name 这个属性了 console.log(lilei.getName()); //lilei 原型链 12345lilei.__proto__ 是Student.prototypeStudent.__proto__ 是Function.prototypeStudent.prototype.__proto__ 是Object.prototypeObject.__proto__ 是Function.prototype,Object也是构造函数Object.prototype__proto__ 是null 函数对象所有的函数对象的__proto__ 都指向Function.prototype ,它是一个空函数 12345678910111213141516171819202122232425Number.__proto__ === Function.prototype // trueNumber.constructor == Function //trueBoolean.__proto__ === Function.prototype // trueBoolean.constructor == Function //trueString.__proto__ === Function.prototype // trueString.constructor == Function //true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Object.__proto__ === Function.prototype // trueObject.constructor == Function // true// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身Function.__proto__ === Function.prototype // trueFunction.constructor == Function //trueArray.__proto__ === Function.prototype // trueArray.constructor == Function //trueRegExp.__proto__ === Function.prototype // trueRegExp.constructor == Function //trueError.__proto__ === Function.prototype // trueError.constructor == Function //trueDate.__proto__ === Function.prototype // true JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的__proto__ 是Object.prototype。如下 12345Math.__proto__ === Object.prototype // trueMath.construrctor == Object // trueJSON.__proto__ === Object.prototype // trueJSON.construrctor == Object //true 本文借鉴了 Yi罐可乐: 最详尽的 JS 原型与原型链终极详解，没有「可能是」]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生JS实现瀑布流效果]]></title>
    <url>%2F2018%2F03%2F10%2FJavaScript%2F%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @name:瀑布流 * @param:parent(容器元素) * @param:oneGap(只有一列时元素的间距,其他列数自适应) * @description:自适应瀑布流,多列间距自适应 */waterFall:function (parent,oneGap)&#123; /**容器的宽度(包含内边距、边框) */ var width=parent.offsetWidth; /**容器内盒子元素的宽度(包含内边距、边框) */ var items=parent.children; var itemWidth = items[0].offsetWidth; var gap=(width-parseInt(width / (itemWidth))*itemWidth)/2; /**计算每列放的盒子元素个数 */ var columns = parseInt(width / (itemWidth + gap)); /**定义一个空数组,用来储存每列元素的高度 */ var arr = []; for (var i = 0; i &lt; items.length; i++) &#123; /**1.将第一行元素的高度都存到arr中 */ if (i &lt; columns) &#123; items[i].style.top = 0; items[i].style.left = (itemWidth + gap) * i + 'px'; arr.push(items[i].offsetHeight); &#125; /**2.找到每一行的最小高度 */ else &#123; var minHeight = arr[0]; var index = 0; for (var j = 0; j &lt; arr.length; j++) &#123; if (minHeight &gt; arr[j]) &#123; minHeight = arr[j];//获得当前行最小高度 index = j; //记下当前列下标 &#125; &#125; /**3.设置下一行第一个盒子的位置, * top值就是最小高度值+gap * left值就是最小列距离左边的距离 */ if(gap!=0)&#123; items[i].style.top = arr[index] + gap + 'px'; items[i].style.left = items[index].offsetLeft + 'px'; /**4.修改最小列的高度 * 最小列的高度 = 当前自己的高度 + 拼接过来的高度 + 间隙的高度 */ arr[index] = arr[index] + items[i].offsetHeight + gap; &#125;else&#123; items[i].style.top = arr[index] + oneGap + 'px'; items[i].style.left = 0; arr[index] = arr[index] + items[i].offsetHeight + oneGap; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用H5画随机色圆]]></title>
    <url>%2F2018%2F03%2F06%2FHTML5%2F%E5%88%A9%E7%94%A8H5%E7%94%BB%E9%9A%8F%E6%9C%BA%E8%89%B2%E5%9C%86%2F</url>
    <content type="text"><![CDATA[忽然想到曾经遇到的一个案例： ​ 在页面上绘制随机数量的圆并填充随机色，但鼠标点击圆时该圆逐渐放大，同时透明度降低，直至消失。 在这里用代码重现下，首先分析下需求： 绘制页面： 生成随机数，根据随机数生成随机颜色 利用svg绘图技术在页面绘制随机数量的圆 将圆填充随机色 JS事件： 为每个圆绑定单击事件 创建定时器 代码： 生成随机数和随机颜色方法 12345678910111213/*获取指定范围内的随机数字*/function randomNum(min,max)&#123; var n=Math.random()*(max-min)+min; return Math.floor(n)&#125;/*生成随机色*/function randomColor(min,max)&#123; var r=randomNum(min,max); var g=randomNum(min,max); var b=randomNum(min,max); var a=Math.random(); return `rgba($&#123;r&#125;,$&#123;g&#125;,$&#123;b&#125;,$&#123;a&#125;)`;&#125; 利用svg绘图 html: 1&lt;svg id="svg" width="1000px" height="500px"&gt;&lt;/svg&gt; JavaScript: 123456789101112131415161718192021222324252627282930var svg=document.getElementById("svg"); for(var i=0;i&lt;50;i++)&#123; //创建圆元素 var c=document.createElementNS("http://www.w3.org/2000/svg","circle"); c.setAttribute("r",randomNum(10,80)); c.setAttribute("cx",randomNum(0,800)); c.setAttribute("cy",randomNum(0,400)); c.setAttribute("fill",randomColor(0,255)); c.setAttribute("fill-opacity",Math.random()); svg.appendChild(c) //绑定单击事件 c.onclick=function()&#123; var that=this; //设置循环定时器 var timer=setInterval(function()&#123; var r=that.getAttribute("r"); r*=1.05; that.setAttribute("r",r); var fillOpac=that.getAttribute("fill-opacity"); fillOpac*=0.9; that.setAttribute("fill-opacity",fillOpac); //设置循环定时器停止条件 if(fillOpac&lt;0.001)&#123; clearInterval(timer); timer=null; svg.removeChild(that); &#125; &#125;,20)() &#125;&#125; 附上codePen链接 效果图:]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道简单的setTimeout面试题]]></title>
    <url>%2F2018%2F03%2F05%2FWeb%2F%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这是一道很入门的js面试题，考察JavaScript的单线程事件执行机制: 12345for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(i) //10*10 &#125;, 10 * i)&#125; 不理解原因的可能会认为输出0,1,2,3,4,5,6,7,8,9。事实并不是这样，原因很简单： 先看下JavaScript的单线程和异步： JS是单线程语言，浏览器只分配给JS一个主线程用来执行任务（函数）； 任务一次只能一次，任务会形成队列排队执行； 浏览器会为setTimeout（定时器，异步）单独开一个线程，异步任务完成后会触发回调函数，这时就把回调函数放到主线程任务队列等待执行 具体到例子： js没有块级作用域，for循环中i提升为全局变量； setTimeout是异步执行，而for循环为同步执行，每执行一次for循环，setTimeout执行一次，触发一次回调函数； for循环已经执行完时setTimeout内部回调函数开始，i值为10，故最后连续输出10个10 如果需要输出连续数字，则需要采用闭包或ES6语法中的let 123456789101112131415// 闭包for (var i = 0; i &lt; 10; i++) &#123; void function (j) &#123; setTimeout(function () &#123; console.log(j) &#125;, 10 * j) &#125;(i)&#125;// letfor (let i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 10 * i)&#125; 闭包： JavaScript的函数会形成作用域，闭包就是记住变量不受污染 i作为参数传入匿名函数被记住 let： 在{ }内形成块级作用域； 生成不同的i实例，形成一个匿名函数自调，类似于闭包]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>events</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包与模块]]></title>
    <url>%2F2018%2F03%2F01%2FJavaScript%2F%E9%97%AD%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[什么是闭包闭包是有重用机制，同时保护变量不被污染的一种机制 变量类型 优点 缺点 全局变量 可重用 污染/随处可用 局部变量 仅作用域内部可用,不会污染不可重用全局 不可重用 闭包在需要重用一个变量，又需要保护变量不被污染的情况时使用 即使函数已经完成了运行，它依然可以“记住”并持续访问函数的作用域。 123456function makeAdder(x) &#123; // 参数x是一个内部变量 function add(y) &#123; // 内部函数add()使用x，所以它对x拥有一个“闭包” return y + x; &#125;; return add;&#125; 每次调用makeAdder(...) 所对应的add(...) 函数引用都会记住被传入makeAdder() 的参数X 12345var plusOne = makeAdder( 1 ); //plusOne得到一个指向内部函数add(..)的引用,add()函数拥有对外部makeAdder(..)的参数x的闭包,相当于add()中x=2var plusTen = makeAdder( 10 ); //相当于add()中x=10plusOne( 3 ); //调用add()方法,y=3,返回值为4plusOne( 41 ); //调用add()方法,y=41,返回值为42plusTen( 13 ); //x=10,调用add()方法,y=13,返回值为23 这段代码的工作机制: 当调用makeAdder(1)时,会得到返回的内部函数add(),该函数引用了参数x为1并记住了1; 将调用返回的函数引用为plusOne; 当调用plusOne(3)时,它会在传入参数y为3的基础上加上记住的x为1，结果为4； 实现闭包的三个步骤： 用外层函数包裹要保护的变量和操作变量的函数 外层函数将内层函数的对象返回到外部 使用者调用外层函数,获得内层函数对象 闭包形成原因：外层函数的作用域对象(AO)无法释放,被内层函数对象引用着 模块模块是闭包中最常见的用法，模块让你定义对外面世界不可见的私有实现细节（变量，函数），和暴露给外面可访问的公有API。 12345678910111213function User()&#123; var username, password; function doLogin(user,pw) &#123; //登录的方法 username = user; password = pw; &#125; var publicAPI = &#123; //需要暴露给外面的API login: doLogin &#125;; return publicAPI; //将API暴露出来&#125;var fred = User(); // 创建一个 `User` 模块的实例fred.login( "fred", "12Battery34!" ); 工作机制: 接口 publicAPI是一个带有一个属性/方法的对象，login是一个指向内部doLogin()函数的引用 方法User() 内部包含两个局部作用域变量username和password，私有的doLogin()方法接受从API传入的两个参数值,并赋值给相应的username和password 执行User()创建了User模块的一个 实例 —— 一个全新的作用域会被创建，而每个内部变量/函数因此被创建新的副本。将这个实例赋值给fred 如果再次运行User() ，将会得到一个与fred完全分离的新实例； 当User() 函数执行完，username 和password 这样的内部变量不会消失，因为login() 函数里有一个闭包保护变量]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>function</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex弹性布局]]></title>
    <url>%2F2018%2F02%2F25%2FCSS%2FFlex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[flex布局是什么Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为flex布局,包括行内元素 123456.box&#123; display: flex;&#125;.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 基础概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性有六个属性设置在容器上: flex-direction flex-wrap flex-flow : flex-direction和flex-wrap的简写 .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;} 默认值为row nowrap justify-content align-items align-content 1. flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 2. flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap wrap wrap-reverse 3. justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 4. align-items属性align-items属性定义项目在交叉轴上对齐方式。 可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 5. align-content属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 可能取6个值: flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 1234&gt; .box &#123;&gt; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&gt; &#125;&gt; 项目的属性6个属性设置在项目上(子元素); order flex-grow flex-shrink flex-basis flex: 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self 1. order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 123.item &#123; order: &lt;integer&gt;;&#125; 2. flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 3. flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 4. flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本身大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它也可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 5. align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 1234.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch; /*除了auto，其他都与align-items属性完全一致*/&#125; 应用实例骰子]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组以及对象的深拷贝]]></title>
    <url>%2F2018%2F02%2F22%2FJavaScript%2Fjavascript%20%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[转载自 csdn博客 FengCms FungLeo 博客:原文链接 前言在js中，数组和对象的复制如果使用=号来进行复制，那只是浅拷贝。如下图演示：如上，arr的修改，会影响arr2的值，这显然在绝大多数情况下，并不是我们所需要的结果。因此，数组以及对象的深拷贝就是javascript的一个基本功了。 数组的深拷贝条条大道通罗马，实现数组的深拷贝，是有好几种方法的。举例如下： for 循环实现数组的深拷贝for循环是非常好用的。如果不知道高级方法，通过for循环能够完成我们大多数的需求。 123456789var arr = [1,2,3,4,5]var arr2 = copyArr(arr)function copyArr(arr) &#123; let res = [] for (let i = 0; i &lt; arr.length; i++) &#123; res.push(arr[i]) &#125; return res&#125; 如上，通过对数组的for循环，即可实现对数组的深拷贝了。 slice 方法实现数组的深拷贝这个代码实现非常简单。原理也比较好理解，他是将原数组中抽离部分出来形成一个新数组。我们只要设置为抽离全部，即可完成数组的深拷贝。代码如下： 12345var arr = [1,2,3,4,5]var arr2 = arr.slice(0)arr[2] = 5console.log(arr)console.log(arr2) 运行结果如下：更多 slice 内容请访问 w3school JavaScript slice 方法 concat 方法实现数组的深拷贝这个代码也非常简单，原理更加粗暴。它是用于连接多个数组组成一个新的数组的方法。那么，我们只要连接它自己，即可完成数组的深拷贝。代码如下： 12345var arr = [1,2,3,4,5]var arr2 = arr.concat()arr[2] = 5console.log(arr)console.log(arr2)//12345 运行结果如下：更多 concat 内容请访问 w3school JavaScript concat 方法 2017年10月31日补充：ES6扩展运算符实现数组的深拷贝OK，以上之前讲的方法全部过时了，用下面的方法实现数组的深拷贝是最简单的。 12345var arr = [1,2,3,4,5]var [ ...arr2 ] = arrarr[2] = 5console.log(arr)console.log(arr2)12345 运行结果如下： 对象的深拷贝对象的深拷贝相比数组也没有困难许多，列举两个方法。 万能的for循环实现对象的深拷贝在很多时候，for循环能够解决大问题。 12345678910111213var obj = &#123; name: 'FungLeo', sex: 'man', old: '18'&#125;var obj2 = copyObj(obj)function copyObj(obj) &#123; let res = &#123;&#125; for (var key in obj) &#123; res[key] = obj[key] &#125; return res&#125; 转换成json再转换成对象实现对象的深拷贝上面的代码实在是比较长，所以，用一个更暴力的方法吧！代码如下： 123456var obj = &#123; name: 'FungLeo', sex: 'man', old: '18'&#125;var obj2 = JSON.parse(JSON.stringify(obj)) 这个原理没什么好解释的，实在是够简单粗暴的啦！ 2017年10月31日补充： 扩展运算符实现对象的深拷贝123456789var obj = &#123; name: 'FungLeo', sex: 'man', old: '18'&#125;var &#123; ...obj2 &#125; = objobj.old = '22'console.log(obj)console.log(obj2) 运行结果如下： 小结数组和对象的深拷贝是js中最常见的应用。理解各种方法是必须的。希望对大家有所帮助。本文中并没有对异常进行处理，主要在讲原理。更多的数组以及对象的操作方法，可以参考lodash的源码，查看它的源码可以让你的js基础变得非常牢固。我也在学习中。 2017年10月31日补充，使用es6提供的扩展运算符的方法实现深拷贝，简单，高效。并且，对象的深拷贝不会像使用 JSON 方法深拷贝一样，丢失函数等信息，只能用来深拷贝 JSON 数据格式的对象。推荐大家使用。 补充一个数组去重的方法12345function dedupe(array) &#123; return [...new Set(array)]&#125;var arr = [1,2,2,3,3,4,4,5,5]console.log(dedupe(arr)) //[1, 2, 3, 4, 5]]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Viewport剖析]]></title>
    <url>%2F2018%2F02%2F20%2FCSS%2Fviewports%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[转载自W3CPlus创始人 大漠 博客:原文链接 1. 桌面（pc）浏览器1.1 设备的pixels和CSS的pixelspixels决定了你工作所用的那些设备上正式的分辨率。在大多数情况下，能够从screen.width/height上取出具体值 如果用户缩放（zoom）了浏览器，当然必须改变计算方式。 现代浏览器上的缩放，是基于“伸展”pixels。结果是，html元素上的宽度并没有因为缩放200%而由128pix变成256px，而是真实的pixels的被计算成了双倍。html元素在形式上依然是128CSS的pixels，即便它占用了256设备的pixels 。 有4个1像素，缩放为100%的html元素，CSS的pixels完整的和设备的pixels重叠: 当我们缩小浏览器时，CSS的pixels开始收缩，导致1单位的设备的pixels上重叠了多个CSS的pixels 同理，放大浏览器时，相反的事情发生了，CSS的pixels开始扩大，导致1单位的CSS的pixels上重叠了多个设备的pixels 你只需要关注CSS的pixels，这些pixels指定你的样式被如何渲染. 1.2 100% 缩放在缩放级别为100%时，1单位的CSS的pixel是严格相等于1单位的设备pixel，通常会在100%缩放级别下测试网站 1.2.1 屏幕尺寸 Screen size 含义：用户的屏幕的完整大小。这两个属性包含了用户屏幕的完整宽度/高度,尺寸使用设备的pixels来定义，他们的值不会因为缩放而改变(显示器的特征，而不是浏览器) 度量：设备的pixels,screen.width/height (基本无用) 兼容性问题：IE8里，不管使用IE7模式还是IE8模式，都以CSS的pixels来度量 1.2.2 浏览器尺寸 Window size 含义：包含滚动条尺寸的浏览器完整尺寸; 想要知道的浏览器的内部尺寸。它定义了当前用户有多大区域，可供你的CSS布局占用度量：CSS的pixels, window.innerWidth/Height兼容性问题：IE不支持，Opera用设备pixels来度量 1.2.3 滚动移位 Scrolling offset 含义：页面的移位 , 定义了页面(document)的相对于窗口原点的水平、垂直位移。因此你能够定位用户滚动了多少的滚动条距离。 度量：CSS的pixels, window.pageX/YOffset 兼容性问题：pageXOffset 和 pageYOffset 在 IE 8 及之前版本的IE不支持, 使用”document.body.scrollLeft” and “document.body.scrollTop” 来取代 1.2.4 视窗 viewportviewport的功能在于控制你网站的最高块状（block）容器：&lt;html&gt; 元素。viewport是严格的等于浏览器的窗口,viewport不是一个HTML的概念，不能通过CSS修改它。 举个例子~假设你定义了一个可变尺寸的布局（liquid layout），且你定义一个侧边栏的宽度为width: 10%。当你改变浏览器窗口大小时，该侧边栏会自动扩张和收缩。 原理是侧边栏的宽度为它父元素宽度的10% 一个块级元素占有起父元素的100%的宽度（这里有异常情况，暂时忽略）。所以&lt;body&gt;的宽度就是其父元素&lt;html&gt;的宽度。 那么&lt;html&gt;元素到底有多宽？因为它的宽度恰好为浏览器的宽度。所以你的侧边栏宽度width: 10%会占用10%的浏览器宽度。所以的web开发人员都直观的知道和使用该特性了。 但是你也许不知道原理。在原理上，&lt;html&gt;的宽度受viewport所限制，&lt;html&gt;元素为viewport宽度的100%。 1.2.5 页面宽度 document width 度量viewport 尺寸 : 含义：viewport的尺寸 度量：CSS的pixels, document. documentElement. clientWidth/Height 兼容性问题：无 document.documentElement实际上就是·&lt;html&gt;元素：HTML文档的根元素，然而viewport是比&lt;html&gt;更高级别的元素，打个比喻，它是容纳&lt;html&gt;元素的元素。 document. documentElement. clientWidth/Height只会给出viewport的尺寸，而不管&lt;html&gt;元素尺寸如何改变 度量&lt;html&gt; 元素 含义：&lt;html&gt;的尺寸 度量：CSS的pixels, document. documentElement. offsetWidth/Height 兼容性问题：IE用这个值标示viewport的尺寸而非&lt;html&gt; 如果clientWidth/Height一直用以标示viewport的尺寸，我们该如何去获取&lt;html&gt;元素的尺寸呢？答案是：document.documentElement.offsetWidth/Height。 这个特性对真实的让你访问块级元素&lt;html&gt;元素，如果你为&lt;html&gt;元素赋值了宽度，offsetWidth会真实的反应出来 1.3 几种尺寸区别 window.innerWidth/Height 包含滚动条 document. documentElement. clientWidth/Height: 不包含滚动条 viewport尺寸 document. documentElement. offsetWidth：html尺寸 1.4 事件坐标 pageX/Y：从&lt;html&gt;原点到事件触发点的CSS的 pixels (使用概率:90%) clientX/Y：从viewport原点（浏览器窗口）到事件触发点的CSS的 pixels (使用概率:10%) screenX/Y：从用户显示器窗口原点到事件触发点的设备 的 pixels。(使用概率:0%) 兼容性问题：IE不支持pageX/Y,IE使用CSSpixels来度量screanX/Y 1.5 Media查询 含义：可以根据页面的特定宽度来定义特殊的CSS规则。 度量：width/height 和 device-width/device-heigh 兼容性问题：IE不支持. 12345div.sidebar &#123; width: 300px; &#125; @media all and (max-width: 400px) &#123; div.sidebar &#123; width: 100px; &#125; &#125;/*如果宽度大于400px，那么sidebar宽度为300px。反之，sidebar宽度为100px*/ device-width/height: 使用screen.width/height来做为的判定值。该值以设备的pixels来度量 width/height: 使用documentElement.clientWidth/Height即viewport的值。该值以CSS的pixels来度量 2. 移动端浏览器2.1 一些概念2.1.1 视窗 viewport简单的理解，viewport是严格等于浏览器的窗口。在桌面浏览器中，viewport就是浏览器窗口的宽度高度。但在移动端设备上就有点复杂。 移动端的viewport太窄，为了能更好为CSS布局服务，所以提供了两个viewport：虚拟的viewportvisualviewport和布局的viewportlayoutviewport。 2.1.2 物理像素(physical pixel)又称为设备像素 设备独立像素(density-independent pixel) 设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。 CSS像素 CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs。 屏幕密度 屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。 设备像素比(device pixel ratio) 设备像素比简称为dpr，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到： 1设备像素比 ＝ 物理像素 / 设备独立像素 在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。 在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。 iPhone6的设备宽度和高度为375pt * 667pt,可以理解为设备的独立像素；而其dpr为2，根据上面公式，我们可以很轻松得知其物理像素为750pt * 1334pt。 在不同的屏幕上，CSS像素所呈现的物理尺寸是一致的，而不同的是CSS像素所对应的物理像素具数是不一致的。在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素对应的却是4个物理像素。 在移动端时代屏幕适配除了Layout之外，还要考虑到图片的适配，因为其直接影响到页面显示质量 meta标签 viewport的meta标签，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大。 在开发移动端页面，我们需要设置meta标签如下： 1&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt; 代码以显示网页的屏幕宽度定义了视窗宽度。网页的比例和最大比例被设置为100%。 CSS单位rem 在W3C规范中是这样描述rem的: font size of the root element 简单的理解，rem就是相对于根元素&lt;html&gt; 的font-size来做计算。 2.2 适配方案在移动端布局，我们需要面对两个最为重要的问题： 各终端下的适配问题 Retina屏的细节处理 2.2.1 适配终端以前的Flexible方案是通过JavaScript来模拟vw的特性，如今vw已经得到了众多浏览器的支持，也就是说，可以直接考虑将vw单位运用于我们的适配布局中。 vw 是基于Viewport视窗的长度单位，这里的视窗（Viewport）指的就是浏览器可视化的区域，而这个可视区域是window.innerWidth/window.innerHeight的大小。用下图简单的来示意一下： 在CSS Values and Units Module Level 3中和Viewport相关的单位有四个，分别为vw、vh、vmin和vmax。 vw：是Viewport’s width的简写,1vw等于window.innerWidth的1% vh：和vw类似，是Viewport’s height的简写，1vh等于window.innerHeihgt的1% vmin：vmin的值是当前vw和vh中较小的值 vmax：vmax的值是当前vw和vh中较大的值 vmin和vmax是根据Viewport中长度偏大的那个维度值计算出来的，如果window.innerHeight &gt; window.innerWidth则vmin取百分之一的window.innerWidth，vmax取百分之一的window.innerHeight计算。 这个方案中大胆的使用vw来替代以前Flexible中的rem缩放方案 目前出视觉设计稿，我们都是使用750px宽度的，从上面的原理来看，那么100vw = 750px，即1vw = 7.5px。那么我们可以根据设计图上的px值直接转换成对应的vw值。看到这里，很多同学开始感到崩溃，又要计算，能不能简便一点，能不能再简单一点，其实是可以的，我们可以使用PostCSS的插件postcss-px-to-viewport，让我们可以直接在代码中写px，比如： 1234567891011[w-369]&#123; width: 369px; &#125; [w-369] h2 span &#123; background: #FF5000; color: #fff; display: inline-block; border-radius: 4px; font-size: 20px; text-shadow: 0 2px 2px #FF5000; padding: 2px 5px; margin-right: 5px; &#125; PostCSS编译之后就是我们所需要的带vw代码： 12345678910111213[w-369] &#123; width: 49.2vw; &#125; [w-369] h2 span &#123; background: #ff5000; color: #fff; display: inline-block; border-radius: .53333vw; text-shadow: 0 0.26667vw 0.26667vw #ff5000; padding: .26667vw .66667vw; &#125; [w-369] h2 span, [w-369] i &#123; font-size: 2.66667vw; margin-right: .66667vw; &#125; 在实际使用的时候，你可以对该插件进行相关的参数配置： 123456789"postcss-px-to-viewport": &#123; viewportWidth: 750, viewportHeight: 1334, unitPrecision: 5, viewportUnit: 'vw', selectorBlackList: [], minPixelValue: 1, mediaQuery: false&#125; 假设你的设计稿不是750px而是1125px，那么你就可以修改vewportWidth的值。有关于该插件的详细介绍，可以阅读其官方使用文档。 在哪些地方可以使用vw来适配我们的页面。根据相关的测试： 容器适配，可以使用vw 文本的适配，可以使用vw 大于1px的边框、圆角、阴影都可以使用vw 内距和外距，可以使用vw 另外有一个细节需要特别的提出，比如我们有一个这样的设计： 如果我们直接使用： 123456[w-188-246] &#123; width: 188px;&#125;[w-187-246]&#123; width: 187px&#125; 最终的效果会造成[w-187-246]容器的高度小于[w-188-246]容器的高度。这个时候我们就需要考虑到容器的长宽比缩放。这方面的方案很多，但我还是推荐工具化来处理，这里推荐@一丝 姐姐写的一个PostCSS插件postcss-aspect-ratio-mini。这个插件使用很简单，不需要做任何的配置，你只需要本地安装一下就OK。使用的时候如下： 12345678910111213141516171819202122[aspectratio] &#123; position: relative;&#125;[aspectratio]::before &#123; content: ''; display: block; width: 1px; margin-left: -1px; height: 0;&#125;[aspectratio-content] &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%;&#125;[aspectratio][aspect-ratio="188/246"]&#123; aspect-ratio: '188:246';&#125; 编译出来： 123[aspectratio][aspect-ratio="188/246"]:before &#123; padding-top: 130.85106382978725%;&#125; 这样就可以完美的实现长宽比的效果。]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端网摘]]></title>
    <url>%2F2018%2F02%2F20%2FWeb%2F%E5%89%8D%E7%AB%AF%E7%BD%91%E6%91%98%2F</url>
    <content type="text"><![CDATA[1. 移动端网摘 viewports剖析 使用Flexible实现手淘H5页面的终端适配 再聊移动端适配 如何在Vue项目中使用vw实现移动端适配 谷歌device列表 最新Android &amp; iOS设计尺寸规范——2015 px、pt、ppi、dpi、dp、sp之间的关系]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>网摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM通用事件绑定]]></title>
    <url>%2F2018%2F02%2F18%2FJavaScript%2FDOM%E9%80%9A%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[1. 认识DOMDOM(Document Object Model),即文档对象模型,是为了以编程的方法操作HTML和XML文档内容制定的标准,主要有三种: 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 这里主要认识HTML DOM HTML DOM: 关于如何获取、修改、添加或删除 HTML 元素的标准 在DOM中,HTML 文档中的所有内容都是节点,通过HTML DOM,树中的所有节点均可通过Js进行增删改查(操作DOM); 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;DOM 教程&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;DOM 第一课&lt;/h1&gt; &lt;p&gt;Hello world!&lt;/p&gt; &lt;button id="btn"&gt;点击&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 12345var p = document.querySelector("p");//根据选择器标签查找DOM元素var btn=document.getElementById("btn");//根据ID查找DOM元素btn.onclick=function()&#123; //通过操作DOM事件绑定事件 console.log("你点击了我")&#125; 事件的绑定有一个通用的方法: 123btn.addEventListener('click',function()&#123; console.log("绑定了点击事件")&#125;) 2. DOM事件绑定上面讲了两种点击事件绑定的方法，addEventListener是一个通用的事件绑定API，但单词太多，最好自己封装一个绑定方法： 1234567function bindEvent(elem,type,fn)&#123; event.addEventListener(type,fn)&#125;//给按钮btn绑定点击事件bindEvent(btn,click,function()&#123; console.log("绑定了点击事件")&#125;) 重写的bindEvent是一个通用事件绑定,结合事件冒泡情况,可以更完善: 123456&lt;div id="div1"&gt; &lt;p id="p1"&gt;激活1&lt;/p&gt; &lt;p id="p2"&gt;激活2&lt;/p&gt; &lt;p id="p3"&gt;激活3&lt;/p&gt; &lt;p id="p4"&gt;激活4&lt;/p&gt;&lt;/div&gt; 按之前的事件绑定方式,给每个p元素绑定事件,打印输出对应的innerHTML值 12345678var p1=document.getElementById('p1');bindEvent(p1,'click',function(e)&#123; console.log(e.target.innerHTML)&#125;)var body=document.body;bindEvent(body,'click',function(e)&#123; console.log(e.target.innerHTML)&#125;) 运行后发现,点击p1元素会输出两次,说明该元素绑定了两次单击事件,这是由于给p1元素绑定单击事件时冒泡到父元素div1上; 1234bindEvent(p1,'click',function(e)&#123; e.stopPropagation(); console.log(e.target.innerHTML)&#125;) 那么这样通用事件绑定方法就不通用,需要进行改造: 123456789101112131415161718192021function bindEvent(elem,type,selector,fn)&#123; if(fn==null)&#123; //如果没有第四个参数 fn=selector; selector=null; &#125; elem.addEventListener(type,function(e)&#123; if(selector)&#123; var target=e.target if(target.matches(selector))&#123; fn.call(this,e) &#125; &#125;else&#123; fn(e) &#125; &#125;)&#125;var div1=document.getElementById('div1');bindEvent(div1,'click','p',function(e)&#123; // e.stopPropagation(); console.log(e.target.innerHTML)&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的点赞效果]]></title>
    <url>%2F2018%2F02%2F14%2FJavaScript%2FVue%E7%9A%84%E7%82%B9%E8%B5%9E%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[1. 原生: 利用CSS3 Animation 实现animation的动画效果通常是连贯性的，简单的说就是线性渐变的动画。但有些效果不需要连贯性，只需要关键帧之间的跳跃，这时应该使用steps 过渡方式，称之为帧动画。 比较知名的Twitter点赞功能就是采用steps方式： HTML 1&lt;i class="heart"&gt;&lt;/i&gt; CSS123456789101112.heart &#123; display: inline-block; width: 5rem; height: 5rem; background: url(heart.png); background-size: auto 5rem; background-position: 0 0;&#125;.heart:active &#123; /*当鼠标点击激活时执行动画效果*/ transition: background 1s steps(28); background-position: -140rem 0; &#125; transition的简写方式为: transition: property duration timing-function delay 属性 描述 transition-property 设置过渡效果的 CSS 属性的名称。 transition-duration 完成过渡效果需要多少秒或毫秒。 transition-timing-function 速度效果的速度曲线。 transition-delay 定义过渡效果何时开始。 上面的CSS动画效果等同于: 12345678.heart:active&#123; animation : heartBlast 1s 1; animation-timing-function:steps(28);&#125;@keyframes heartBlast &#123; 0% &#123;background-position: left;&#125; 100% &#123;background-position: right;&#125;&#125; 逐帧播放红心背景图片达到实现效果 2. Vue的实现方法与原生DOM不同的是,vue是一个以数据驱动的框架,可以直接在html上直接绑定相关事件或属性 template 12&lt;i class=&quot;heart&quot; :style=&quot;star&quot; :class=&quot;&#123;hover:parseInt(item.isHover)&#125;&quot; @click=&quot;heart(item)&quot;&gt;&lt;/i&gt;&lt;!--item是v-for循环中的某个子项,有pid/isHover/count等属性--&gt; 通过绑定设置元素背景图片,双向绑定css类hover,通过点击事件heart控制hover类显示以及点赞数量count变化 script 123456789101112131415161718192021222324252627282930313233343536373839export default &#123; name:'MainBox', data()&#123; return &#123; star:&#123; backgroundImage:'url(' + require('../../assets/img/web_heart_animation.png') + ')' &#125;, isHover:false &#125; &#125;, methods:&#123; updateCount(pid,count)&#123; this.$axios(&#123; url:'/updateCarrousel.php', baseURL: 'http://www.haohome.top/yx/data', methods:'post', params:&#123;pid:pid,count:count&#125;, //pid:当前id,count:当前id已点赞数量 responseType: 'json', transformResponse:function(data)&#123; var code=data.code; if(code)&#123; console.log("点赞成功"); &#125;else&#123; console.log("点赞失败"); &#125; &#125;, &#125;) &#125;, heart(item)&#123; if(item.isHover=="0")&#123; item.isHover="1", //点赞动画class:hover绑定 item.count++; &#125;else&#123; item.isHover="0" item.count--; &#125; this.updateCount(item.pid,item.count) &#125; &#125; style 1234567891011.heart&#123; display: inline-block; width: 5rem; height: 5rem; background-size: auto 5rem; background-position: 0 0;&#125;.heart.hover &#123; transition: background 1s steps(28); background-position: -140rem 0; &#125;]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>css3</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue的CSS作用域问题]]></title>
    <url>%2F2018%2F02%2F12%2FJavaScript%2FVue%E7%9A%84CSS%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. CSS 作用域问题1.1 style标签增加scoped属性CSS 只作用于当前组件中的元素,类似于 Shadow DOM 中的样式封装。 原理: 通过使用 PostCSS 来实现转换 123456789&lt;style scoped&gt;.example &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class="example"&gt;hi&lt;/div&gt;&lt;/template&gt; 转换结果: 123456789&lt;style&gt;.example[data-v-f3f3eg9] &#123; color: red;&#125;&lt;/style&gt;&lt;template&gt; &lt;div class="example" data-v-f3f3eg9&gt;hi&lt;/div&gt;&lt;/template&gt; 1.2 混用本地和全局样式Vue中可以在一个组件中同时使用有作用域和无作用域的样式: 1234567&lt;style&gt;/* 全局样式 */&lt;/style&gt;&lt;style scoped&gt;/* 本地样式 */&lt;/style&gt; 1.3 子组件的根元素子组件使用了scoped后,父组件的样式不会渗透到子组件中,不过子组件的根节点会同时受到父组件和子组件的css影响 设计目的：为了父组件可以从布局角度出发,调整其子组件根元素的样式 1.4深度作用选择器如果希望scoped样式中的某个样式作用的更深,如影响子组件,可以使用&gt;&gt;&gt;操作符: 1234&lt;style scoped&gt;.a &gt;&gt;&gt; .b &#123; /* ... */ &#125;&lt;/style&gt;&lt;!-- 解析成: .a[data-v-f3f3eg9] .b &#123; /* ... */ &#125; --&gt; 有些像 SASS 之类的预处理器无法正确解析 &gt;&gt;&gt;。这种情况下你可以使用 /deep/ 操作符取而代之——这是一个 &gt;&gt;&gt;的别名，同样可以正常工作。 1.5动态生成的内容通过 v-html 创建的 DOM 内容不受作用域内的样式影响，但仍然可以通过深度作用选择器来为他们设置样式。 2. CSS Modules2.1 使用CSS Modules是一个用于模块化和组合 CSS 的流行系统。 在&lt;style&gt; 上添加 module 属性： 12345678&lt;style module&gt;.red &#123; color: red;&#125;.bold &#123; font-weight: bold;&#125;&lt;/style&gt; 这将为 css-loader 打开 CSS Modules 模式，生成的 CSS 对象将为组件注入一个名叫 $style 的计算属性，可以在模块中使用动态 class 绑定： 12345&lt;template&gt; &lt;p :class="$style.red"&gt; This should be red &lt;/p&gt;&lt;/template&gt; 由于具有computed属性,也适用于:class 的 object/array 语法： 12345678910&lt;template&gt; &lt;div&gt; &lt;p :class="&#123; [$style.red]: isRed &#125;"&gt; Am I red? &lt;/p&gt; &lt;p :class="[$style.red, $style.bold]"&gt; Red and bold &lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 可以在 JavaScript 访问它： 123456789&lt;script&gt;export default &#123; created () &#123; console.log(this.$style.red) // -&gt; "_1VyoJ-uZOjlOxP7jWUy19_0" // an identifier generated based on filename and className. &#125;&#125;&lt;/script&gt; 2.2 自定义注入名称在 .vue 中你可以定义不止一个 &lt;style&gt;，为了避免被覆盖，可以通过设置 module 属性来为它们定义注入后计算属性的名称。 1234567&lt;style module="a"&gt; /* identifiers injected as a */&lt;/style&gt;&lt;style module="b"&gt; /* identifiers injected as b */&lt;/style&gt;]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack入门]]></title>
    <url>%2F2018%2F01%2F28%2FJavaScript%2Fwebpack%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[背景ES6 的模块系统: import 和export 12345export default custom = &#123; // 对象&#125;/*****************/import custom from '.....' Common.js 1234567let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let fs = require('fs');let stat = fs.stat;let exists = fs.exists;let readfile = fs.readfile; 没有模块加载和打包工具前,需要要么手工合并文件，要么使用一堆&lt;script&gt;标签,带来一些问题 必须保证文件加载的顺序没错，包括知道哪些文件依赖另外一些文件，以及不包含不需要的文件。 多个&lt;script&gt;标签意味着对服务器发送多次请求，性能会受影响。 模块文件使用很方便,通过npm安装相应插件模块,直接import引入即可 1.概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 认识webpack,需了解四个核心概念: 入口(entry) 输出(output) loader 插件(plugins) 1.1 入口(entry )入口起点指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。 每个依赖项随即被处理，最后输出到称之为 bundles 的文件中 可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点） 123module.exports = &#123; entry: './index.js'&#125;; 当工程是多页面应用程序: 1234567const config = &#123; entry: &#123; pageOne: './src/pageOne/index.js', pageTwo: './src/pageTwo/index.js', pageThree: './src/pageThree/index.js' &#125;&#125;; 1.2 出口(output)output属性指在哪里输出它所创建的 bundles，包括以下两点： filename 用于输出文件的文件名。 path指输出 的绝对路径。 属性告诉 webpack 在**哪里(path)输出它所创建的 bundles**，以及如何命名这些文件。1234567891011```JavaScriptconst path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;[name].bundle.js&apos;, //输出的文件名将为file.bundle.js,在当前文件夹dist目录下 publicPath: &apos;/dist/&apos; &#125;&#125;; 决定了每个输出 bundle 的名称123456789101112131415161718192021222324252627282930313233343536| 模板 | 描述 || ----------- | ------------------------------ || [hash] | 模块标识符(module identifier)的 hash || [chunkhash] | chunk 内容的 hash || [name] | 模块名称 || [id] | 模块标识符(module identifier) || [query] | 模块的 query，例如，文件名 `?` 后面的字符串 |#### 1.3 [loader](https://doc.webpack-china.org/concepts/loaders)*loader* 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效[模块](https://doc.webpack-china.org/concepts/modules).&gt; 本质: webpack loader 将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块。 webpack 的配置中 **loader** 有两个属性:- `test` :识别出应该被对应的 loader 进行转换的那些文件;- `use`:转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）当编译时碰到 `require()`/`import` 语句中被解析为路径时,打包前将执行loader进行转换```JavaScriptconst path = require(&apos;path&apos;);module.exports = &#123; entry: &apos;./path/to/my/entry/file.js&apos;, output: &#123; path: path.resolve(__dirname, &apos;dist&apos;), filename: &apos;my-first-webpack.bundle.js&apos; &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: &apos;css-loader&apos; &#125; ] &#125;&#125;; 1.4 插件(plugins)插件的执行范围比较广,包括从打包优化和压缩,一直到重新定义环境中的变量 使用步骤：先require（），再添加到plugins数组中 tips： ①多数插件可以通过选项options自定义 ②多次使用同一个插件时，可以通过new 创建实例 12345678910111213141516171819const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const path = require('path');module.exports = &#123; entry: './file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: 'css-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) //使用html模板 ]&#125;; 1.5 配置(Configuration) webpack 的配置文件，是导出一个对象的 JavaScript 文件(module.exports) webpack 配置是标准的 CommonJS``` 模块:1234567891011121314151617181920212223- 通过 `require(...)` 导入其他文件- 通过 `require(...)` 使用 npm 的工具函数- 使用 JavaScript 控制流表达式，例如 `?:` 操作符- 对常用值使用常量或变量- 编写并执行函数来生成部分配置导出多个配置对象```JavaScriptmodule.exports = [&#123; output: &#123; filename: &apos;./dist-amd.js&apos;, libraryTarget: &apos;amd&apos; &#125;, entry: &apos;./app.js&apos;,&#125;, &#123; output: &#123; filename: &apos;./dist-commonjs.js&apos;, libraryTarget: &apos;commonjs&apos; &#125;, entry: &apos;./app.js&apos;,&#125;] 1.6 模块(Modules)对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系,如: ES2015 import 语句 CommonJS require() 语句 AMD define 和 require 语句 css/sass/less 文件中的 @import 语句。 样式(url(…))或 HTML 文件()中的图片链接(image url) webpack 通过 loader 可以支持各种语言和预处理器编写模块。 1.7 模块解析(Module Resolution)一个模块可以作为另一个模块的依赖模块，然后被后者引用 123import foo from 'path/to/module'// 或者require('path/to/module') 1.8 构建目标(Targets)多个 Target: 12345678910111213141516171819var path = require('path');var serverConfig = &#123; target: 'node', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' &#125; //…&#125;;var clientConfig = &#123; target: 'web', // &lt;=== 默认是 'web'，可省略 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.js' &#125; //…&#125;;module.exports = [ serverConfig, clientConfig ];//将在dist 文件夹下创建 lib.js 和 lib.node.js 文件。 1.9 Manifest runtime:在模块交互时，连接模块所需的加载和解析逻辑 manifest:当编译器(compiler)开始执行、解析和映射应用程序时，保留的所有模块详细要点的数据集合 通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。 1.10 模块热替换(Hot Module Replacement)在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 2.安装12npm install --save-dev webpacknpm install --save-dev webpack@&lt;version&gt; 3.配置在webpack.config.js文件中进行配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; // string | object | array app: './src/index.js', print: './src/print.js' &#125;, output: &#123; // webpack 如何输出结果的相关选项, 必须是绝对路径 filename: '[name].bundle.js',//文件名模板 path: path.resolve(__dirname, 'dist'), publicPath: '/' // 输出解析文件的目录，url 相对于 HTML 页面 &#125;, devtool: 'inline-source-map',//追踪到错误和警告在源代码中的原始位置 devServer: &#123; //提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading) contentBase: path.join(__dirname, "./dist"), //服务器的位置 port: 3000 &#125;, plugins: [ new CleanWebpackPlugin(['dist']),//每次build都会清理dist文件夹 new HtmlWebpackPlugin(&#123; //指定模板输出,自动生成新的index,所有的bundle 会自动添加到 html 中 filename: 'index.html', template: 'src/assets/test.html'//模板文件路径 &#125;) ], module: &#123; //加载对应资源 rules: [ &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, &#123; test: /\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125;, &#123; test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125;, &#123; test: /\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, &#123; test: /\.xml$/, use: [ 'xml-loader' ] &#125; ] &#125; &#125;; loader PostCSS PostCSS是一个利用JS插件来对CSS进行转换的工具，这些插件非常强大，强大到无所不能。其中，Autoprefixer就是众多PostCSS插件中最流行的一个。 安装方法: npm i --save-dev postcss 一般postcss会结合autoprefixer一起使用,autoprefixer是css的后处理器,可为css添加浏览器前缀,使兼容不同浏览器,安装方法: npm install --save-dev autoprefixer 配置1: 123456 &#123; test: /\.less$/, exclude: /node_modules/, use: ExtractTextPlugin.extract(&#123;fallback: "style-loader",use: 'css-loader!postcss-loader!less-loader'&#125;) &#125;/*可以处理less或sass*/ 这种方式需要在项目根目录下添加psotcss-config.js文件,里面添加 12345module.exports = &#123; plugins: [ require('autoprefixer')(&#123;browsers: ['last 5 versions']&#125;) ] &#125; 配置2: 1234567891011121314&#123; test: /\.less$/, exclude: /node_modules/, use: ExtractTextPlugin.extract(&#123; fallback: "style-loader", use: [ &#123;loader: 'css-loader'&#125;, &#123;loader: 'postcss-loader', options: &#123;plugins: [require('autoprefixer')(&#123;browsers: ['last 5 versions']&#125;) ]&#125; &#125;, &#123;loader: 'less-loader'&#125;] )&#125;&#125; 这种配置是将postcss配置依赖直接放在里面了 babel 安装npm install --save-dev babel-loader babel-core 安装: npm install babel-preset-env --save-dev 在根目录下新建.babelrc 文件,添加 123&#123; "presets": ["env"]&#125; 123456789&#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; // presets: ["env"] //如果有.babellrc文件这个配置可省略 &#125; // &#125;&#125;, 4.环境构建4.1 配置 开发环境(development)：需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server； 生产环境(production)：我们的目标转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间； 由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置，但会保留”通用”配置。 通过工具,将"通用"配置合并在一起:123```JavaScriptnpm install --save-dev webpack-merge project项目结构 123456789webpack-demo |- package.json |- config |- webpack.common.js |- webpack.dev.js |- webpack.prod.js |-src |-index.js |- index.html webpack.common.js公共配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const webpack = require('webpack');module.exports = &#123; entry: &#123; index: path.resolve(__dirname,'../src/index.js'), &#125;, resolve: &#123; alias: &#123; //别名,引入第三方库jQuery之后起的别名 jquery: path.resolve(__dirname,'../libs/jquery-3.2.1.js') &#125; &#125;, plugins: [ new CleanWebpackPlugin(//清理文件夹 ['*.js','*.map','*.png','*.css','*.html'], //匹配删除的文件,若为*则全部删除 &#123; root: path.resolve(__dirname,'../dist'), verbose: true, //开启在控制台输出信息 &#125;), new HtmlWebpackPlugin(&#123; //指定模板输出 filename: 'index.html', template: './index.html' &#125;), new webpack.ProvidePlugin(&#123; //自动生成全局变量,一旦引用,就会打包 $:"jquery", jQuery:"jquery", 'window.jQuery':"jquery", 'window.$':"jquery" &#125;), ], module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ["env"] &#125; &#125; &#125; ] &#125;, output: &#123; //打包输出配置路径 filename: '[name]-[hash].bundle.js', path: path.resolve(__dirname, '../dist'), publicPath: '' //上线的绝对地址 可以为http://www.haohome.top/ &#125;, &#125;; webpack.dev.js 开发配置 123456789const path = require('path');const merge = require('webpack-merge');const common = require('./webpack.common.js');module.exports = merge(common, &#123; //与公共配置合并 devtool: 'inline-source-map',//追踪错误和警告 devServer: &#123; //提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading) contentBase:path.resolve(__dirname, "../"), //服务器的位置 &#125;,&#125;); webpack.prod.js 生产配置 123456789101112const merge = require('webpack-merge');const UglifyJSPlugin = require('uglifyjs-webpack-plugin');//代码压缩工具const common = require('./webpack.common.js');module.exports = merge(common, &#123; devtool: 'source-map', //调试源码(debug)和运行基准测试(benchmark tests)很有用 plugins: [ new UglifyJSPlugin(&#123; sourceMap: true //如果配置了devtool则加改选项 &#125;) ],&#125;);/ 避免在生产中使用 inline-*** 和 eval-***，因为它们可以增加 bundle 大小，并降低整体性能。 package.json配置NPM Scripts: 把 scripts 重新指向到新配置。我们将 npm start 定义为开发环境脚本，并在其中使用 webpack-dev-server，将 npm run build 定义为生产环境脚本: 1234"scripts": &#123; "start": "webpack-dev-server --progress --colors --open --config webpack.dev.js", "build": "webpack --progress --colors --config webpack.prod.js"&#125; 4.2 指定环境许多 library 将通过与 process.env.NODE_ENV 环境变量关联，以决定 library 中应该引用哪些内容。当使用 process.env.NODE_ENV === &#39;production&#39; 时，一些 library 可能针对具体用户的环境进行代码优化，从而删除或添加一些重要代码。 可以使用 webpack 内置的 DefinePlugin为所有的依赖定义这个变量 webpack.prod.js 12345678910111213141516+ const webpack = require('webpack');//引入webpack const merge = require('webpack-merge'); const UglifyJSPlugin = require('uglifyjs-webpack-plugin'); const common = require('./webpack.common.js'); module.exports = merge(common, &#123; devtool: 'source-map', plugins: [ new UglifyJSPlugin(&#123; sourceMap: true &#125;),+ new webpack.DefinePlugin(&#123;+ 'process.env.NODE_ENV': JSON.stringify('production')//指定为生产环境+ &#125;) ] &#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack入门]]></title>
    <url>%2F2018%2F01%2F28%2FJavaScript%2Fwebpack%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。 1.1 入口(entry )入口起点指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。 每个依赖项随即被处理，最后输出到称之为 bundles 的文件中 可以通过在 webpack 配置中配置 entry 属性，来指定一个入口起点（或多个入口起点） 123module.exports = &#123; entry: './file.js'&#125;; 1.2 出口(output)output属性的最低要求是，将它的值设置为一个对象，包括以下两点： filename 用于输出文件的文件名。 目标输出目录 path 的绝对路径。 output 属性告诉 webpack 在哪里(path)输出它所创建的 bundles，以及如何命名这些文件。 12345678const path = require('path');module.exports = &#123; entry: './file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].bundle.js' //输出的文件名将为file.bundle.js,在当前文件夹dist目录下 &#125;&#125;; output.filename 决定了每个输出 bundle 的名称 模板 描述 [hash] 模块标识符(module identifier)的 hash [chunkhash] chunk 内容的 hash [name] 模块名称 [id] 模块标识符(module identifier) [query] 模块的 query，例如，文件名 ? 后面的字符串 1.3 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块. 本质: webpack loader 将所有类型的文件，转换为应用程序的依赖图可以直接引用的模块。 webpack 的配置中 loader 有两个目标: 1.识别出应该被对应的 loader 进行转换的那些文件。(使用 test 属性) 2.转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）(use 属性) 12345678910111213const path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] //当webpack打包require()/import 语句中被解析为'.txt'的路径时,先使用raw-loader转换一下 &#125;&#125;; 1.4 插件(plugins)插件的执行范围比较广,包括从打包优化和压缩,一直到重新定义环境中的变量 使用步骤：先require（），再添加到plugins数组中 tips： ①多数插件可以通过选项options自定义 ②多次使用同一个插件时，可以通过new 创建实例 12345678910111213141516171819const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const path = require('path');module.exports = &#123; entry: './file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;)//使用html模板 ]&#125;; 1.5 配置(Configuration) webpack 的配置文件，是导出一个对象的 JavaScript 文件(module.exports) webpack 配置是标准的 Node.js CommonJS 模块: 通过 require(...) 导入其他文件 通过 require(...) 使用 npm 的工具函数 使用 JavaScript 控制流表达式，例如 ?: 操作符 对常用值使用常量或变量 编写并执行函数来生成部分配置 配置类型(可略过) 在开发和生产构建之间，消除 webpack.config.js 的差异,（至少）有两种选项: 导出一个函数,包含两个参数: 12345678910module.exports = function(env, argv) &#123;//env:environment,argv:一个选项 map 对象 return &#123; devtool: env.production ? 'source-maps' : 'eval', plugins: [ new webpack.optimize.UglifyJsPlugin(&#123; compress: argv['optimize-minimize'] // 只有传入 -p 或 --optimize-minimize &#125;) ] &#125;;&#125;; 导出一个 Promise webpack 将运行由配置文件导出的函数，并且等待 Promise 返回。便于需要异步地加载所需的配置变量。 123456789module.exports = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(&#123; entry: './app.js', &#125;) &#125;, 5000) &#125;)&#125; 导出多个配置对象 12345678910111213module.exports = [&#123; output: &#123; filename: './dist-amd.js', libraryTarget: 'amd' &#125;, entry: './app.js',&#125;, &#123; output: &#123; filename: './dist-commonjs.js', libraryTarget: 'commonjs' &#125;, entry: './app.js',&#125;] 1.6 模块(Modules)对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系,如: ES2015 import 语句 CommonJS require() 语句 AMD define 和 require 语句 css/sass/less 文件中的 @import 语句。 样式(url(…))或 HTML 文件(&lt;img src=...&gt;)中的图片链接(image url) webpack 通过 loader 可以支持各种语言和预处理器编写模块。 1.7 模块解析(Module Resolution)一个模块可以作为另一个模块的依赖模块，然后被后者引用 123import foo from 'path/to/module'// 或者require('path/to/module') 1.8 构建目标(Targets)多个 Target: 12345678910111213141516171819var path = require('path');var serverConfig = &#123; target: 'node', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' &#125; //…&#125;;var clientConfig = &#123; target: 'web', // &lt;=== 默认是 'web'，可省略 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.js' &#125; //…&#125;;module.exports = [ serverConfig, clientConfig ];//将在dist 文件夹下创建 lib.js 和 lib.node.js 文件。 1.9 Manifest runtime:在模块交互时，连接模块所需的加载和解析逻辑 manifest:当编译器(compiler)开始执行、解析和映射应用程序时，保留的所有模块详细要点的数据集合 通过使用 manifest 中的数据，runtime 将能够查询模块标识符，检索出背后对应的模块。 1.10 模块热替换(Hot Module Replacement)在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 2.安装12npm install --save-dev webpacknpm install --save-dev webpack@&lt;version&gt; 3.配置在webpack.config.js文件中进行配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');module.exports = &#123; entry: &#123; // string | object | array app: './src/index.js', print: './src/print.js' &#125;, output: &#123; // webpack 如何输出结果的相关选项, 必须是绝对路径 filename: '[name].bundle.js',//文件名模板 path: path.resolve(__dirname, 'dist'), publicPath: '/' // 输出解析文件的目录，url 相对于 HTML 页面 &#125;, devtool: 'inline-source-map',//追踪到错误和警告在源代码中的原始位置 devServer: &#123; //提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading) contentBase: path.join(__dirname, "./dist"), //服务器的位置 port: 3000 &#125;, plugins: [ new CleanWebpackPlugin(['dist']),//每次build都会清理dist文件夹 new HtmlWebpackPlugin(&#123; //指定模板输出,自动生成新的index,所有的bundle 会自动添加到 html 中 filename: 'index.html', template: 'src/assets/test.html'//模板文件路径 &#125;) ], module: &#123; //加载对应资源 rules: [ &#123; test: /\.css$/, use: [ 'style-loader', 'css-loader' ] &#125;, &#123; test: /\.(png|svg|jpg|gif)$/, use: [ 'file-loader' ] &#125;, &#123; test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ 'file-loader' ] &#125;, &#123; test: /\.(csv|tsv)$/, use: [ 'csv-loader' ] &#125;, &#123; test: /\.xml$/, use: [ 'xml-loader' ] &#125; ] &#125; &#125;; 4.环境构建4.1 配置 开发环境(development)：需要具有强大的、具有实时重新加载(live reloading)或热模块替换(hot module replacement)能力的 source map 和 localhost server； 生产环境(production)：我们的目标转向于关注更小的 bundle，更轻量的 source map，以及更优化的资源，以改善加载时间； 由于要遵循逻辑分离，我们通常建议为每个环境编写彼此独立的 webpack 配置，但会保留”通用”配置。 通过工具webpack-merge ,将”通用”配置合并在一起: 1npm install --save-dev webpack-merge project项目结构 123456789webpack-demo |- package.json |- config |- webpack.common.js |- webpack.dev.js |- webpack.prod.js |-src |-index.js |- index.html webpack.common.js公共配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');const CleanWebpackPlugin = require('clean-webpack-plugin');const webpack = require('webpack');module.exports = &#123; entry: &#123; index: path.resolve(__dirname,'../src/index.js'), &#125;, resolve: &#123; alias: &#123; //别名,引入第三方库jQuery之后起的别名 jquery: path.resolve(__dirname,'../libs/jquery-3.2.1.js') &#125; &#125;, plugins: [ new CleanWebpackPlugin(//清理文件夹 ['*.js','*.map','*.png','*.css','*.html'], //匹配删除的文件,若为*则全部删除 &#123; root: path.resolve(__dirname,'../dist'), verbose: true, //开启在控制台输出信息 &#125;), new HtmlWebpackPlugin(&#123; //指定模板输出 filename: 'index.html', template: './index.html' &#125;), new webpack.ProvidePlugin(&#123; //自动生成全局变量,一旦引用,就会打包 $:"jquery", jQuery:"jquery", 'window.jQuery':"jquery", 'window.$':"jquery" &#125;), ], module: &#123; rules: [ &#123; test: /\.css$/, use: ['style-loader', 'css-loader'] &#125;, &#123; test: /\.js$/, exclude: /(node_modules|bower_components)/, use: &#123; loader: 'babel-loader', options: &#123; presets: ["env"] &#125; &#125; &#125; ] &#125;, output: &#123; //打包输出配置路径 filename: '[name]-[hash].bundle.js', path: path.resolve(__dirname, '../dist'), publicPath: '' //上线的绝对地址 可以为http://www.haohome.top/ &#125;, &#125;; webpack.dev.js 开发配置 123456789const path = require('path');const merge = require('webpack-merge');const common = require('./webpack.common.js');module.exports = merge(common, &#123; //与公共配置合并 devtool: 'inline-source-map',//追踪错误和警告 devServer: &#123; //提供了一个简单的 web 服务器，并且能够实时重新加载(live reloading) contentBase:path.resolve(__dirname, "../"), //服务器的位置 &#125;,&#125;); webpack.prod.js 生产配置 123456789101112const merge = require('webpack-merge');const UglifyJSPlugin = require('uglifyjs-webpack-plugin');//代码压缩工具const common = require('./webpack.common.js');module.exports = merge(common, &#123; devtool: 'source-map', //调试源码(debug)和运行基准测试(benchmark tests)很有用 plugins: [ new UglifyJSPlugin(&#123; sourceMap: true //如果配置了devtool则加改选项 &#125;) ],&#125;);/ 避免在生产中使用 inline-*** 和 eval-***，因为它们可以增加 bundle 大小，并降低整体性能。 package.json配置NPM Scripts: 把 scripts 重新指向到新配置。我们将 npm start 定义为开发环境脚本，并在其中使用 webpack-dev-server，将 npm run build 定义为生产环境脚本: 1234"scripts": &#123; "start": "webpack-dev-server --progress --colors --open --config webpack.dev.js", "build": "webpack --progress --colors --config webpack.prod.js"&#125; 4.2 指定环境许多 library 将通过与 process.env.NODE_ENV 环境变量关联，以决定 library 中应该引用哪些内容。当使用 process.env.NODE_ENV === &#39;production&#39; 时，一些 library 可能针对具体用户的环境进行代码优化，从而删除或添加一些重要代码。 可以使用 webpack 内置的 DefinePlugin为所有的依赖定义这个变量 webpack.prod.js 12345678910111213141516+ const webpack = require('webpack');//引入webpack const merge = require('webpack-merge'); const UglifyJSPlugin = require('uglifyjs-webpack-plugin'); const common = require('./webpack.common.js'); module.exports = merge(common, &#123; devtool: 'source-map', plugins: [ new UglifyJSPlugin(&#123; sourceMap: true &#125;),+ new webpack.DefinePlugin(&#123;+ 'process.env.NODE_ENV': JSON.stringify('production')//指定为生产环境+ &#125;) ] &#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue实现简单分页功能]]></title>
    <url>%2F2018%2F01%2F21%2FJavaScript%2FVue%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E5%88%86%E9%A1%B5%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[分页功能在列表查询中是一个比较重要的组成部分,按结构划分可分为页码与上一页/下一页: 页码:通过点击数字,并将页码数字传递到后台查询获取相应的页码内容 上一页/下一页:可以共用一个方法,利用不同参数识别,查询数据逻辑与页码类似; 页面显示页码:可以采用计算属性computed获得 下面的案例是我从自己的vue项目中摘取出来: 实现分页的CSS部分 1234567891011121314151617181920212223242526272829.pages &#123; text-align: center;&#125;.pages a &#123; color:#999; box-sizing: border-box; height: 20px; min-width: 20px; border-radius: 2px; display: inline-block; border:1px solid #ddd; margin: 0 2px; padding: 0 4px; line-height: 18px;&#125;.pages a:hover &#123; border-color:#f8b551; color:#f8b551;&#125;.pages a.cur &#123; border-color:#f8b551; background: #f8b551; color: #fff;&#125;.pages a.default &#123; border-color: #ddd; color:#ddd; cursor: default;&#125; 实现分页的template 123456&lt;div class="pages"&gt; &lt;a href="" @click.self.prevent="togglePage(-1)" :class="&#123;default:pno&lt;=1&#125;"&gt;上一页&lt;/a&gt; &lt;a v-for="(temp,key) in realPage" :key=key :class="&#123;cur:pno==temp&#125;" href="" @click.self.prevent="changePage(temp)"&gt;&#123;&#123;temp&#125;&#125;&lt;/a&gt; &lt;a href="" @click.self.prevent="togglePage(1)" :class="&#123;default:pno&gt;=pageCount&#125;"&gt;下一页 &lt;/a&gt;&lt;/div&gt;&lt;!--利用事件修饰符 @click.self.prevent阻止对元素自身的点击。--&gt; 实现分页的Js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 data ()&#123; return &#123; newsList:[], pno:1, pageCount:0 &#125; &#125;, mounted()&#123; this.getList() //挂载的时候获取新闻列表 &#125;, methods: &#123; getList()&#123; var self=this; self.$axios(&#123; method: 'get', baseURL:'http://127.0.0.1:3000/', url: '/news/list/'+self.pno, withCredentials: true, responseType: 'json', transformResponse:function(response)&#123; self.newsList=response.data; self.pageCount=response.pageCount; &#125;, &#125;); &#125;, // 点击页面切换 changePage(index)&#123; var self=this; self.pno=index; self.$axios(&#123; method: 'get', baseURL:'http://127.0.0.1:3000/', url: '/news/list/'+self.pno, withCredentials: true, responseType: 'json', transformResponse:function(response)&#123; self.newsList=response.data; self.pageCount=response.pageCount; &#125;, &#125;); &#125;, //点击上一页/下一页事件 togglePage(index)&#123;//通过对index赋值来识别按钮 var self=this; if(index&gt;0)&#123; if(self.pno&gt;=self.pageCount)return; self.pno++; &#125;else&#123; if(self.pno&lt;=1)return self.pno--; &#125; self.$axios(&#123; method: 'get', baseURL:'http://127.0.0.1:3000/', url: '/news/list/'+self.pno, withCredentials: true, responseType: 'json', transformResponse:function(response)&#123; self.newsList=response.data; self.pageCount=response.pageCount; &#125;, &#125;); &#125; &#125;, computed :&#123; //vue内置的计算属性,可以直接使用realPage,相当于java的getter方法 realPage:function()&#123; let left=1; let right=this.pageCount; var realCount=[];//当前可显示的页码数组,如[4,5,6] if(right&gt;=3)&#123;//控制最多显示3页 if(this.pno&gt;1 &amp;&amp; this.pno+1&lt;this.pageCount)&#123; left=this.pno-1; right=this.pno+1; &#125;else &#123; if(this.pno&lt;=3)&#123; left=1; right=3; &#125;else&#123; left=this.pageCount-2; right=this.pageCount; &#125; &#125; &#125; while(left&lt;=right)&#123; //通过循环将当前可显示的页码存到realCount数组中 realCount.push(left); left++; &#125; return realCount; &#125; &#125;&#125; 当页面发生变化,如果需要通知其他组件做出相应变化,可以再增加watch监听页面变化 12345watch: &#123; pno: function(newValue,oldValue)&#123; console.log(arguments); &#125;&#125; ​]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node基础]]></title>
    <url>%2F2018%2F01%2F21%2FJavaScript%2FNode_%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[1.HTTP模块 http模块是创建HTTP协议的服务器端应用(代替Apache和php)——接受客户端请求,解析并处理请求,返回响应消息. http模块还用于创建HTTP协议的客户端应用(模拟浏览器功能)——向其他的服务器发起请求，等待返回响应消息. Node.js中使用http模块创建服务器端应用： 123456const http=require('http');let server=http.createServer(function(req,res)&#123; //客户端请求消息 req.method/url/headers //服务器响应消息 res.write()/writeHead()/end&#125;)server.listen(3000);//监听3000端口 eg:http模块请求不同url,响应不同消息主体 12345678910111213const http=require('http');let server=http.createServer(function(req,res)&#123; res.writeHead(200, &#123;'Content-Type':'text/html;charset=UTF-8'&#125;); if(req.url=='/index')&#123; res.write('&lt;h1&gt;这是首页&lt;/h1&gt;') &#125;else if(req.url=='/user/login')&#123; res.write('&lt;h1&gt;这是登录页&lt;/h1&gt;') &#125;else if(req.url=='/user/register')&#123; res.write('&lt;h1&gt;这是注册页&lt;/h1&gt;') &#125; res.end('欢迎来到NodeJs');&#125;)server.listen(3000);//监听3000端口 2.fs模块 fs模块提供了文件的读写、更名、删除、遍历目录等操作。 fs模块中大多方法都带有同步和异步两种操作模式 1)异步方法的最后一个参数都是一个回调函数2)传给回调函数的参数取决于具体方法,但回调函数的第一个参数是error异常,如果有异常,会静默失败,需要手动处理;3)同步方法中任何异常都会被立即抛出,可以使用 try/catch 来处理异常，或让异常向上冒泡。 123456//异步方法const fs = require('fs');fs.unlink('/tmp/hello', (err) =&gt; &#123; if (err) throw err;//有异常则抛出异常 console.log('成功删除 /tmp/hello');&#125;); 1234//同步方法 方法名后+Syncconst fs = require('fs');fs.unlinkSync('/tmp/hello');console.log('成功删除 /tmp/hello'); 2.1 判断文件是否存在fs.stat方法:fs.stat(path, callback(err,stats))第一个参数是path(路径),第二个参数是回调函数(第一个参数是异常error,第二个是统计信息描述对象)1234567fs.stat('data.txt', (err, stats) =&gt; &#123; if (err) &#123; console.log(err.code); throw err; &#125; console.log(stats);&#125;); 2.2 文件路径转换fs.realpath方法:fs.realpath(path[, options], callback(err,realpath)),将相对路径转为绝对路径 在express中提供文件路径时用到12345678fs.realpath('./data.txt',function(err,resolvedPath)&#123; //如果转换失败,则err中有值,否则为null if(err)&#123; console.error(err); &#125;else&#123; console.log(resolvedPath);// e:\Github\Node\data.txt &#125;&#125;) 2.3 文件重命名fs.rename方法:fs.rename(oldPath, newPath, callback(err)) 2.4 文件读写fs.readFile方法:fs.readFile(path[, options], callback(err,data))fs.writeFile方法:fs.writeFile(file, data[, options], callback(err)) options encoding | 默认 = ‘utf8’如果 data 是一个 buffer，则忽略 encoding 选项。它默认为 ‘utf8’. mode 默认 = 0o666 flag 默认 = ‘w’,表示”写”,flag==”a”,则为追加append 12345fs.writeFile('data.txt', 'Hello Node.js', (err) =&gt; &#123; if (err) throw err; console.log('The file has been saved!');&#125;);fs.writeFile('message.txt', 'Hello Node.js', 'utf8', callback); 多次对同一文件使用 fs.writeFile 且不等待回调，是不安全的。 对于这种情况，强烈推荐使用 fs.createWriteStream。 2.5 读写流 读取流 123456789101112var rs=fs.createReadStream('./data.txt');var temp="";rs.on('data',function(chunk)&#123; //每读取64kb执行data方法 console.log(chunk); //看字符串 // console.log(chunk.toString()); temp+=chunk;//拼接所有的数据&#125;)//读取流完毕后执行endrs.on('end',function()&#123; console.log(temp);&#125;) 写入流 12345var rs=fs.createReadStream('./data.txt');var ws=fs.createWriteStream('./data_bak.txt');rs.on('data',function(chunk)&#123; ws.write(chunk);&#125;) pipe方法写入数据时,会等当前读出的数据全部写入后,才进行下一次的读取操作,内存利用充分,当时读取时间比较长 123var rs=fs.createReadStream('./data.txt');var ws=fs.createWriteStream('./data_bak.txt');rs.pipe(ws) 3.http第三方模块express 使用步骤： 1.安装 2.使用http模块创建Web服务器，运行express，让其承担请求监听器的任务12var app = express();http.createServer( app ).listen(80); 3.为app对象添加特定URL的请求处理12345678910app.get('/user', function(req, res)&#123; //接收请求消息中的数据 req.query //获取查询字符串中的数据&#123; &#125; req.params //获取请求参数(手册自学) req.on('data', function(buf)&#123;&#125;) //获取请求主体中的数据 //发送响应消息 res.send(HTML文本); res.sendFile(任意类型的文件); res.json(对象/数组数据);&#125;) 3.1 路由路由，针对客户端的某个请求方法所请求的特定URL，如何给出响应消息的过程，称为“路由”路由 = 请求方法 + 请求URL + 处理函数一个典型的路由形如：1234567891011app.get('/user', function(req, res)&#123; //接收请求消息中的数据 req.query //获取查询字符串中的数据&#123; &#125; req.params //获取请求参数(手册自学) req.on('data', function(buf)&#123;&#125;) //获取请求主体中的数据 //发送响应消息 res.send(HTML文本); res.sendFile(任意类型的文件); res.json(对象/数组数据);&#125;) express.Router 在 app 目录下创建名为 birds.js 的文件，内容如下： 1234567891011121314151617 var express = require('express');var router = express.Router();// 该路由使用的中间件router.use(function timeLog(req, res, next) &#123; console.log('Time: ', Date.now()); next();&#125;);// 定义网站主页的路由router.get('/', function(req, res) &#123; res.send('Birds home page');&#125;);// 定义 about 页面的路由router.get('/about', function(req, res) &#123; res.send('About birds');&#125;);module.exports = router; 然后在应用中加载路由模块：123var birds = require('./birds');...app.use('/birds', birds); 应用即可处理发自 /birds 和 /birds/about 的请求，并且调用为该路由指定的 timeLog 中间件。 3.2 中间件中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。功能:(1)执行任何代码。(2)修改请求和响应对象。(3)终结请求-响应循环。(4)调用堆栈中的下一个中间件。 如果当前中间件没有终结请求-响应循环，则必须调用 next() 方法将控制权交给下一个中间件，否则请求就会挂起。 应用级中间件应用级中间件绑定到app对象使用app.use()和app.METHOD(),其中，METHOD是需要处理的HTTP请求的方法，例如GET,PUT,POST等等全部小写。123456789101112131415var app = express();// 没有挂载路径的中间件，应用的每个请求都会执行该中间件app.use(function (req, res, next) &#123; console.log('Time:', Date.now()); next();&#125;);// 挂载至 /user/:id 的中间件，任何指向 /user/:id 的请求都会执行它app.use('/user/:id', function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;);// 路由和句柄函数(中间件系统)，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; res.send('USER');&#125;); 3.2.1 在一个挂载点装载一组中间件12345678// 一个中间件栈，对任何指向 /user/:id 的 HTTP 请求打印出相关信息app.use('/user/:id', function(req, res, next) &#123; console.log('Request URL:', req.originalUrl); next();&#125;, function (req, res, next) &#123; console.log('Request Type:', req.method); next();&#125;); 3.2.2 下例为指向 /user/:id 的 GET 请求定义了两个路由,但第一个路由终止了请求-响应循环,第二个路由不会被执行1234567891011// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; console.log('ID:', req.params.id); next();&#125;, function (req, res, next) &#123; res.send('User Info');&#125;);// 处理 /user/:id， 打印出用户 idapp.get('/user/:id', function (req, res, next) &#123; res.end(req.params.id);&#125;); 3.2.3 如果需要在中间件栈中跳过剩余中间件，调用next(‘route’)方法将控制权交给下一个路由 注意：next(‘route’)只对使用app.VERB()或router.VERB()加载的中间件有效。123456789101112131415// 一个中间件栈，处理指向 /user/:id 的 GET 请求app.get('/user/:id', function (req, res, next) &#123; // 如果 user id 为 0, 跳到下一个路由 if (req.params.id == 0) next('route'); // 否则将控制权交给栈中下一个中间件 else next(); //&#125;, function (req, res, next) &#123; // 渲染常规页面 res.render('regular');&#125;);// 处理 /user/:id， 渲染一个特殊页面app.get('/user/:id', function (req, res, next) &#123; res.render('special');&#125;); 路由级中间件 使用方法与应用级中间件类似 var router = express.Router(); 错误处理中间件 错误处理中间件有4个参数，定义错误处理中间件时必须使用这4个参数。即使不需要next对象，也必须在签名中声明它，否则中间件会被识别为一个常规中间件，不能处理错误。 1234app.use(function(err, req, res, next) &#123; console.error(err.stack); res.status(500).send('Something broke!');&#125;); 项目中常用的中间件 (1)向客户端返回指定目录下的所有静态资源文件 1234567- (2)将客户端POST请求主体中的数据封装到req.body中 ```JavaScript npm i body-parser const bodyParser = require(&apos;body-parser&apos;); app.use( bodyParser.urlencoded(&#123;extended: false&#125;)); (3)将请求头部中的Cookie数据封装到req.cookies中 123npm i cookie-parserconst cookieParser = require('cookie-parser');app.use(cookieParser()); (4)解决跨域问题cors 1234app.use( cors(&#123; origin: ["http://127.0.0.1", "http://localhost:8080"], credentials: true&#125;) ); 配置cors: 12345678910111213var express = require('express')var cors = require('cors')var app = express()var corsOptions = &#123; //配置跨域选项 origin: 'http://example.com', optionsSuccessStatus: 200 // some legacy browsers (IE11, various SmartTVs) choke on 204 &#125; app.get('/products/:id', cors(corsOptions), function (req, res, next) &#123; res.json(&#123;msg: '跨域仅限域名:example.com.'&#125;)&#125;) app.listen(80, function () &#123; console.log('80端口服务器可以跨域')&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域资源共享CORS]]></title>
    <url>%2F2018%2F01%2F14%2FWeb%2F%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB%20CORS%2F</url>
    <content type="text"><![CDATA[CORS是一个W3C标准,全称是”跨域资源共享”(Cross-origin resource sharing)。它允许浏览器向夸源服务器发出XMLHttpRequest请求，克服Ajax只能同源使用的限制。 一、简介CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 二、两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 2.1简单请求简单请求满足一下两大条件(1)请求方法时一下三种方法之一 HEAD GET POST (2)HTTP的头信息不超出一下几种字段: Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 2.1.1 基本流程对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个12345678910 &gt; 下面的例子,浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个```Origin```字段。 ```JavaScriptGET /cors HTTP/1.1Origin: &apos;http://api.bob.com&apos;Host: &apos;api.alice.com&apos;Accept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0...//上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果1234567891011 &gt; 这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200 - 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。```JavaScript//浏览器响应头resAccess-Control-Allow-Origin: &apos;http://api.bob.com&apos;Access-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8//上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。 (1)Access-Control-Allow-Origin(必须)该字段是必须的。受任意域名的请求。 (2)Access-Control-Allow-Credentials(可选)它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 (3)Access-Control-Expose-Headers(可选)CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 2.1.2 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定12```JavaScriptAccess-Control-Allow-Credentials: true 同时开发者必须在AJAX请求中打开1234```JavaScriptvar xhr = new XMLHttpRequest();xhr.withCredentials = true; 这样就能向服务器发送Cookie,服务器才能获得SessionId;否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理,这时服务器会新建一个新的Cookie的Id号。 但是，有时即使省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 注意:如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 2.2非简单请求 2.2.1预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的JavaScript脚本。 123456var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send();//上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。 下面是这个”预检”请求的HTTP头信息。 12345678OPTIONS /cors HTTP/1.1Origin: 'http://api.bob.com'Access-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 (1)Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。 (2)Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 转载自阮一峰的网络日志]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Http</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串操作slice、substr、sbustring比较]]></title>
    <url>%2F2018%2F01%2F13%2FJavaScript%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9Cslice%E3%80%81substr%E3%80%81substring%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[在截取字符串时常常会用到substr()、substring()、slice()截取数组或字符串的方法,几个方法之间有时易混淆. slice() 可接受一个或者两个参数 两个参数:slice(start,end),start指截取字符串开始的位置,end指截取字符串结束的位置(不包含) 一个参数:slice(start),指截取从start位置到结束位置(字符串长度为结束位置) 1.传递参数为正值,end表示结束的位置123var str="HelloWorld";console.log(str.slice(3));//"loworld" console.log(str.slice(3,7)); //'loWo' 2.传递参数为负值slice()将传入的负值与字符串长度相加 123var str='Helloworld';console.log(str.slice(-3));//'rld' 一个参数,与字符串长度相加即为slice(7);console.log(str.slice(3,-4));//'low' 两个参数,字符串长度相加即为slice(3,6); 3.第二个参数比第一个参数小,则返回空字符串 4.IE兼容性:在IE8浏览器测试下,没有兼容性问题 slice与substring、substr区别 传递参数为正值:1) substring与slice方法行为类似,但substring会将较小的数作为开始位置,较大的数作为结束位置(substring(3,0) 与substring(0,3)是一样效果);2) substr第二个参数表示返回字符的个数,如果没有第二参数,则字符串的长度作为结束位置 传递参数为负值:1) substring()会把所有负值参数转换为0;2) substr()方法会将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。 123var str ="helloWorld";console.log(str.substr(-3,5));//"rld" 即为：substr(7,5) ，从位置7开始向后截取5个字符console.log(str.substr(3,-2));//substr(3,0)，即从位置3截取0个字符串，则返回空 IE兼容性: slice() 和 substring ()在IE8都正常,substr()方法传递负值的情况下会存在问题，会返回原始的字符串。IE9修复了此问题。 总结 在传递正值参数情况下，slice() 和 substring () 行为是一致的，substr()方法在第二个参数上会容易混淆 在传递负值参数情况下，slice() 方法是通过字符串长度相加，符合一般思维，substring()第二个参数转换为0会容易出问题，起始位置会容易变更， substr() 方法负值情况下会出现IE兼容性问题。综上，一般推荐使用slice()方法。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>String</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的接口]]></title>
    <url>%2F2018%2F01%2F07%2FJava%2FJava%E4%B8%AD%E7%9A%84%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1.接口的概念接口定义了某一批类所需要遵守的规范,接口不关心这些类的内部数据,也不关心这些类里方法的实现细节,它只规定这些类里必须提供某些方法; 2.接口定义定义接口不再使用class关键字,而使用interface关键字 2.1 基本语法12345[修饰符public] [abstract] interface 接口名 [extends 父接口1,父接口2...]&#123; 零个到多个常量定义... 零个到多个抽象方法的定义...&#125; 接口是开放的（被继承、被实现），修饰符使用public，不能使用private和protected 常量接口中的属性是常量,即使定义时不添加public static final修饰符,系统也会自动加上 方法接口中的方法只能是抽象方法,总是使用,即使定义时不添加public abstract修饰符,系统也会自动加上3.使用接口一个类可以实现一个或多个接口,实现接口使用implements关键字 阶层父类实现接口的语法: 1234[修饰符] class 类名 extends 父类 implements 接口1,接口2...&#123; 类体部分 //如果继承了抽象类,需要实现继承的抽象方法;要实现接口中的抽象方法&#125; 如果要继承父类,继承父类必须在实现接口之前 补充:接口使用过程中,还经常与匿名内部类配合使用 匿名内部类就是没有名字的内部类,多用于关注实现而不关注实现类的名称语法格式 123456Interface i=new Interface()&#123; public void method()&#123; System.out.println("匿名内部类实现接口的方式"); &#125;&#125;i.method();//直接调用]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的多态]]></title>
    <url>%2F2018%2F01%2F01%2FJava%2FJava%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81%2F</url>
    <content type="text"><![CDATA[多态1.引用多态 父类的引用可以指向本类的对象 父类的引用可以指向子类的对象2.方法多态 创建本类对象时,调用的方法为本类方法 创建子类对象时,调用的方法为子类重写的方法或者继承的方法3.引用类型转换 向上类型转换(隐式/自动类型转换),是小类型向大类型转换 向下类型转换(强制类型转换),是大类型到小类型转换(存在数据溢出风险) instanceof运算符:避免类型转换出现的安全问题12345678Dog dog=new Dog();Animal animal=dog;//(向上类型转换)if (animal instanceof Dog) &#123; Dog dog2=(Dog)animal;&#125;else&#123; System.out.println("无法进行类型转换");&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeMaker 模板_数据模型]]></title>
    <url>%2F2018%2F01%2F01%2FJava%2FFreeMaker%20%E6%A8%A1%E6%9D%BF_%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1. 模板 + 数据模型 = 输出1.1 模板 模板与静态HTML类似,区别是包含了一些指令,使网页内容可以动态生成，例如: 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome!&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome $&#123;user&#125;!&lt;/h1&gt; &lt;p&gt;Our latest product: &lt;a href="$&#123;latestProduct.url&#125;"&gt;$&#123;latestProduct.name&#125;&lt;/a&gt;! &lt;/body&gt;&lt;/html&gt; ${…}：插值表达式(interpolation) FTL标签：FreeMarker模板的语言标签，标签的名字以 # 开头，用户自定义的FTL标签则需要使用 @ 来代替 # 注释：使用 &lt;#– and –&gt; 来标识 其他任何不是插值、FTL标签或注释的内容将被视为静态文本，直接在页面输出 1.2 数据模型为模板准备的数据整体被称作为数据模型数据模型是树形结构,例如: 123456789101112131415161718192021222324252627(root) | +- animals | | | +- mouse | | | | | +- size = "small" | | | | | +- price = 50 | | | +- elephant | | | | | +- size = "large" | | | | | +- price = 5000 | | | +- python | | | +- size = "medium" | | | +- price = 4999 | +- message = "It is a test" | +- misc | +- foo = "Something" hashes (哈希表): 指变量中扮演目录角色(比如 root, animals, mouse, elephant, python, misc) 哈希表存储其他变量(被称为 子变量)， 它们可以通过名称来查找(比如 “animals”, “mouse” 或 “price”)。 scalars (标量): 指存储单值的变量 (size, price, message 和 foo) 如果要在模板中使用子变量， 那应该从根root开始指定它的路径，每级之间用点来分隔开。要访问 mouse 的 price ，要从root开始，首先进入到 animals ，之后访问 mouse ，最后访问 price 。就可以这样来写 animals.mouse.price。 sequences (序列): 像哈希表那样存储子变量，但是子变量没有名字，它们只是列表中的项。在下面这个数据模型中， animals 和 misc.fruits 就是序列： 1234567891011121314151617181920212223242526272829303132333435(root) | +- animals | | | +- (1st) | | | | | +- name = "mouse" | | | | | +- size = "small" | | | | | +- price = 50 | | | +- (2nd) | | | | | +- name = "elephant" | | | | | +- size = "large" | | | | | +- price = 5000 | | | +- (3rd) | | | +- name = "python" | | | +- size = "medium" | | | +- price = 4999 | +- misc | +- fruits | +- (1st) = "orange" | +- (2nd) = "banana" 要访问序列的子变量，可以使用方括号形式的数字索引下标。 索引下标从0开始(从0开始也是程序员的传统)，那么第一项的索引就是0， 第二项的索引就是1等等。要得到第一个动物的名称的话，可以这么来写代码 animals[0].name。 标量类型可以分为如下的类别： 字符串：就是文本，也就是任意的字符序列，比如上面提到的 ‘m’,’o’,’u’, ‘s’,’e’。比如 name 和 size 也是字符串。 数字：这是数值类型，就像上面的 price。 在FreeMarker中，字符串 “50” 和数字 50 是两种完全不同的类型。 日期/时间: 可以是日期-时间格式(存储某一天的日期和时间)， 或者是日期(只有日期，没有时间)，或者是时间(只有时间，没有日期)。 布尔值：对应着对/错(是/否，开/关等值)类似的值。 总结： 数据模型可以被看成是树形结构。 标量用于存储单一的值。这种类型的值可以是字符串，数字，日期/时间或者是布尔值。 哈希表是一种存储变量及其相关且有唯一标识名称的容器。 序列是存储有序变量的容器。存储的变量可以通过数字索引来检索，索引通常从0开始。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
        <tag>FreeMaker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中super关键字的使用]]></title>
    <url>%2F2018%2F01%2F01%2FJava%2FJava%E4%B8%ADsuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[super关键字在对象的内部使用,可以代表父类对象 1.访问父类的属性super.age 2.访问父类的方法super.eat()]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的抽象类]]></title>
    <url>%2F2018%2F01%2F01%2FJava%2FJava%E4%B8%AD%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1.语法定义抽象类前使用abstract关键字修饰,则该类为抽象类 2.应用场景 父类只知道子类应该包含哪些方法,但不知道子类如何实现这些方法 从多个具有相同特征的类中抽象出一个抽象类,以这个抽象类作为子类额模板,避免子类设计的随意性3.作用抽象类是约束子类必须有哪些方法,而并不关注子类如何实现这些方法4.使用规则(步骤) 1)abstract定义抽象类 2)abstract定义抽象方法,只有声明,不需要实现(就是定义一个方法名,让子类根据自己情况实现) 3)包含抽象方法的类是抽象类 4)抽象类中可以包含普通方法,也可以没有抽象方法 5)抽象类不能直接创建,可以定义引用变量]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的类和对象]]></title>
    <url>%2F2018%2F01%2F01%2FJava%2FJava%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[1.类 类是对象的类型 类具有相同属性和方法的一组对象的集合 定义:确定对象将拥有的特征(属性)和方法(行为) 类的组成:属性和方法 定义类的步骤 a.定义类名b.编写类的属性c.编写类的方法 !– more –&gt; 12345678public class 类名&#123; //定义属性部分(成员变量) 属性1的类型 属性1; 属性2的类型 属性2; //定义方法部分 方法1; 方法2;&#125; 2.对象对象的属性 对象具有的各种特征 每个对象的每个属性都拥有特定值对象的方法 对象可以执行的操作 使用对象的步骤: a. 创建对象(new) b. 使用对象 引用对象的属性:对象名.属性 引用对象的方法:对象名.方法 类是抽象的概念,对象是一个具体的实物 3.访问修饰符 访问修饰符 本类 同包 子类 其他 private √ 默认 √ √ protected √ √ √ public √ √ √ √ 属性通常设为private 外部调用对象属性通常通过对象的getter和setter方法 4.Object类的方法4.1 toString()方法默认:toString()方法默认返回的是对象的哈希码(对象的地址字符串)Override:返回的是对象的属性值 4.2 equals()方法默认:比较的是对象的引用是否指向同一块内存地址Override:比较对象的属性值(数据)信息]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的static的使用]]></title>
    <url>%2F2017%2F12%2F21%2FJava%2FJava%20%E4%B8%AD%E7%9A%84%20static%20%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[static静态变量的使用 通常我们可以基于一个类创建多个该类的对象，每个对象都拥有自己的成员，互相独立。然而在某些时候，我们更希望该类所有的对象共享同一个成员。static的作用在于此; Java 中被 static 修饰的成员称为静态成员或类成员。它属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问。 使用 static 可以修饰变量、方法和代码块。 12345678910public class HelloWorld&#123; static String hobby="唱歌";//static修饰的变量为静态变量,所有类的对象共享hobby; public static void main (String[] args)&#123; System.out.println("通过类名访问hobby: " +HelloWorld.hobby); HelloWorld hello=new HelloWorld(); System.out.println("通过对象名访问hobby: "+hello.hobby); hello.hobby="跳舞";//通过对象名的形式修改静态变量的值 System.out.println("通过类名访问hobby: " +HelloWorld.hobby);//再次使用类名访问静态变量,值已改变 &#125;&#125; 静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间,直到该类被卸载才会进行资源回收！ static静态方法的使用12345678910public static void main(String[] args) &#123; print();//直接调用同类中静态方法 HelloWorld.print();//直接使用类名调用静态方法 HelloWorld hello=new HelloWorld(); hello.print();//通过实例化对象再调用;&#125;//使用关键字声明静态方法public static void print() &#123; System.out.println("你好,世界!");&#125; 注意 1.静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员。123456789public class HelloWorld&#123; String name="小明";//费静态变量 static String hobby="唱歌";//静态变量hobby //在静态方法中调用非静态变量 public static void print()&#123; // System.out.println("欢迎:"+name+"!");报错,不能直接调用非静态变量 System.out.println("爱好:"+hobby+"!"); &#125;&#125; 如果希望在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量 1234567public static void print()&#123; //创建类的对象 HelloWorld hello=new HelloWorld(); //通过对象来实现在静态方法中调用非静态变量 System.out.println("欢迎:"+hello.name+"!"); System.out.println("爱好:"+hobby+"!");&#125; 2.在普通成员方法中，则可以直接访问同类的非静态变量和静态变量 123456String name="张三"; //非静态变量static String hobby="唱歌";//静态变量public void show()&#123; System.out.println("欢迎:"+name+"!"); System.out.println("爱好:"+hobby+"!");&#125; 3.静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法。 1234567891011public void show()&#123; //普通成员方法 System.out.println("你好欢迎您!");&#125;public static void print()&#123; System.out.println("欢迎来到这里");&#125;public static void main(String[] args)&#123; HelloWorld hello=new HelloWorld(); hello.show();//普通成员方法必须通过对象调用 print();//可以直接调用静态方法&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Backbone学习笔记]]></title>
    <url>%2F2017%2F12%2F17%2FJavaScript%2FBackbone-study-note%2F</url>
    <content type="text"><![CDATA[Model1.简单的对象123456Man = Backbone.Model.extend(&#123; initialize: function()&#123; console.log('你好,你创建了我!'); &#125; &#125;); var man = new Man; 2.对象赋值的两种方法:直接定义默认值和赋值定义123456789101112Man = Backbone.Model.extend(&#123; initialize: function()&#123; console.log('你好,你创建了我!'); &#125;, defaults: &#123; name:'张三', age: '38' &#125; &#125;); var man = new Man; man.set&#123;name:"李四"&#125;; //赋值定义 console.log(man.get("name")) 3.监听属性方法:bind1234567891011121314151617181920Man = Backbone.Model.extend(&#123; initialize: function()&#123; console.log('你好,你创建了我!'); //初始化时绑定监听 this.bind("change:name",function()&#123; console.log("你改变了name属性为：" + this.get("name")); &#125;); &#125;, defaults: &#123; name:'张三', age: '38' &#125;, aboutMe: function()&#123; return '我叫' + this.get('name') + ',今年' + this.get('age') + '岁'; &#125; &#125;); var man = new Man; man.aboutMe(); man.set(&#123;name:'小明'&#125;); //触发绑定的change事件，输出。 man.aboutMe(); 4.为对象添加验证规则,以及错误提示12345678910111213141516171819202122232425262728293031323334 Man = Backbone.Model.extend(&#123; initialize: function()&#123; console.log('你好,你创建了我!'); //初始化时绑定监听 this.bind("change:name",function()&#123; var name = this.get("name"); console.log("你改变了name属性为：" + name); &#125;); this.bind("invalid",function(model, error)&#123; // 当model在客户端 validation（验证）失败时触发。 console.log(error); &#125;); &#125;, defaults: &#123; name:'张三', age: '38' &#125;, validate:function(attributes, options)&#123; if(attributes.name == '') &#123; return "name不能为空！"; &#125; &#125;, aboutMe: function()&#123; return '我叫' + this.get('name') + ',今年' + this.get('age') + '岁'; &#125; &#125;); var man = new Man;// 这种方式添加错误处理也行/* man.on('invalid', function(model, error)&#123; alert(error); &#125;);*/ man.set(&#123;name:''&#125;); man.set(&#123;name:''&#125;, &#123;'validate':true&#125;); //手动触发验证, set时会触发 man.save(); //save时触发验证。根据验证规则，弹出错误提示。 5.对象的获取和保存 save() 会发送POST到模型对应的url，数据格式为json{“name”:”小明”,”age”:38},接着用fetch([options])从服务器端获取数据 fetch({url:’/man/‘}) 发送get请求到/man/这个url中，服务器返回的结果样式是对应的json格式数据123456789man1.fetch(&#123;url:'/man/', success:function(model,response)&#123; console.log('get from server success');//model为获取到的数据 console.log(model.get('name')); &#125;, error:function()&#123; //当返回格式不正确或者是非json数据时，会执行此方法 alert('error');&#125;&#125;); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 Man = Backbone.Model.extend(&#123; url:'/man/', initialize: function()&#123; console.log('你好,你创建了我!'); //初始化时绑定监听 this.bind("change:name",function()&#123; var name = this.get("name"); console.log("你改变了name属性为：" + name); &#125;); this.bind("invalid",function(model,error)&#123; console.log("error",error); &#125;); &#125;, defaults: &#123; name:'张三', age: '38' &#125;, validate:function(attributes)&#123; if(attributes.name == '') &#123; return "name不能为空！"; &#125; &#125;, aboutMe: function()&#123; return '我叫' + this.get('name') + ',今年' + this.get('age') + '岁'; &#125;&#125;);var man = new Man;;man.set(&#123;name:'小明'&#125;);man.save(); //会发送POST到模型对应的url，数据格式为json&#123;"name":"小明","age":38&#125;//然后接着就是从服务器端获取数据使用方法fetch([options])var man1 = new Man;//第一种情况，如果直接使用fetch方法，那么他会发送get请求到你model的url中，//你在服务器端可以通过判断是get还是post来进行对应的操作。man1.fetch();//第二种情况，在fetch中加入参数，如下：man1.fetch(&#123;url:'/man/'&#125;);//这样，就会发送get请求到/man/这个url中，//服务器返回的结果样式应该是对应的json格式数据，同save时POST过去的格式。//不过接受服务器端返回的数据方法是这样的：man1.fetch(&#123;url:'/man/',success:function(model,response)&#123; alert('get from server success'); //model为获取到的数据 alert(model.get('name')); &#125;,error:function()&#123; //当返回格式不正确或者是非json数据时，会执行此方法 alert('error');&#125;&#125;); collection 示例12345678910111213141516171819202122232425262728Book = Backbone.Model.extend(&#123; defaults : &#123; title:'默认标题' &#125;, initialize: function()&#123; console.log('你好,你创建了我!'); &#125; &#125;); BookShelf = Backbone.Collection.extend(&#123; model : Book &#125;); var book1 = new Book(&#123;title : 'book1'&#125;); var book2 = new Book(&#123;title : 'book2'&#125;); var book3 = new Book(&#123;title : 'book3'&#125;); //var bookShelf = new BookShelf([book1, book2, book3]); //实例化集合,参数为数组,或者使用add var bookShelf = new BookShelf; bookShelf.add(book1); bookShelf.add(book2); bookShelf.add(book3); bookShelf.remove(book3); //基于underscore这个js库，还可以使用each的方法获取collection中的数据 bookShelf.each(function(book)&#123; console.log(book.get('title')); &#125;); 2.使用fetch从服务器端获取数据,使用reset渲染12345678910111213141516171819showAllBooks = function()&#123; bookShelf.each(function(book)&#123; //将book数据渲染到页面。 document.writeln(book.get('title')); &#125;); &#125; bookShelf.bind('reset', showAllBooks); bookShelf.url = '/books/'; //注意这里 bookShelf.fetch(&#123; reset: true, success:function(collection,response, options)&#123; collection.each(function(book)&#123; console.log(book.get('title')); &#125;); &#125;, error:function(collection, response, options)&#123; console.log('error'); &#125; &#125;); 创建collection推送到server端创建数据，其实就是调用collection的create方法，POST对应的Model对象（json数据）到配置好的url上。之后会返回一个model的实例，如下面代码中的onebook。12345678var NewBooks = Backbone.Collection.extend(&#123; model: Book, url: '/books/'&#125;);var books = new NewBooks;var onebook = books.create(&#123;title: "I'm coming",&#125;);]]></content>
      <categories>
        <category>Framework</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Backbone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中extends和implements的区别]]></title>
    <url>%2F2017%2F12%2F11%2FJava%2FJava%E4%B8%ADextends%E5%92%8Cimplements%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在类的声明中,通过关键字extends来创建一个类的子类。一个类通过关键字implements声明自己使用一个或者多个接口。 extends 是继承父类(只要那个类不是声明为final或者那个类定义为abstract的就能继承), 继承之后可以使用父类的方法, 也可以重写父类的方法,可以实现父类，也可以调用父类初始化 this.parent()。而且会覆盖父类定义的变量或者函数。这样的好处是：架构师定义好接口，让工程师实现就可以了。整个项目开发效率和开发成本大大降低。 implements 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用;实现父类，子类不可以覆盖父类的方法或者变量。即使子类定义与父类相同的变量或者函数，也会被父类取代掉。 这两种实现的具体使用，是要看项目的实际情况，需要实现，不可以修改implements，只定义接口需要具体实现，或者可以被修改扩展性好，用extends。 接口实现的注意点： 实现一个接口就是要实现该接口的所有的方法(抽象类除外)。 接口中的方法都是抽象的。 多个无关的类可以实现同一个接口，一个类可以实现多个无关的接口。 JAVA中不支持多重继承，但是可以用接口来实现，这样就要用到implements，继承只能继承一个类，但implements可以实现多个接口，用逗号分开就行了 比如 ：class A extends B implements C,D,E]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[get和post推荐使用场景]]></title>
    <url>%2F2017%2F12%2F10%2FJava%2Fget%E5%92%8Cpost%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[查询数据时用GET,因为通常查询条件较少; 提交数据(表单)时用POST,因为通常提交的数据较多.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM渲染流程]]></title>
    <url>%2F2017%2F11%2F28%2FJavaScript%2FDOM%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[1.解析HTML，构建DOM树（构建DOM节点）。 2.构建渲染树（解析样式信息，包括外部的css文件、style标签中的样式）。渲染树由一些包含有各种属性的矩形组成，他们将会按照正确的顺序显 示到屏幕上。 3.布局渲染树（布局DOM节点），执行布局的过程，将确定每个节点在屏幕上的确切坐标。 4.绘制渲染树（绘制DOM节点，即遍历渲染树），使用UI后端层来绘制每个节点。 1.HTML标签元素经过HTML解析,依据DOM标准生成DOM树, 2.CSS样式代码经过CSS解析成样式规则,Webkit使用attachment连接DOM节点和可视化信息来构建渲染树; 3.渲染树由渲染对象构成,并使用layout来表示元素布局 4.最后遍历渲染树,最后在浏览器上绘制页面]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[58同城面试总结]]></title>
    <url>%2F2017%2F11%2F15%2FWeb%2F58%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前言:面试中问了一些基础的问题,非常能反映基本功是否扎实,很佩服58的工程师! 记录两个印象比较深的两道CSS面试题,面试官对效果实现都是希望多种方法实现,平时的积累需要灵活应用: 1.左固定一个宽度div,右边div宽度自适应,如何实现?听到这个问题我还挺开心的,因为前两天还写过,当时也是试了几次才写出来,只是没有在意和及时总结。现场回答的非常不好，比较惭愧,回到家第一件事就把这个题模拟了一下： 利用绝对定位和padding-left实现1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Document&lt;/title&gt;&lt;style&gt; *&#123; margin:0; padding:0; &#125; .box&#123; width:100%; position:relative; &#125; .left&#123; width:300px; position:absolute; z-index: 10; min-height:300px; background:#f00; &#125; .right&#123; width:100%; position:absolute; padding-left: 300px; box-sizing: border-box; min-height:300px; background:#ff0; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt; &lt;div class="left"&gt;我属于左边&lt;/div&gt; &lt;div class="right"&gt;我属于右边&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2. 写一个弹窗,怎么居中弹窗里的元素?这个问题平时写的比较多,但疏于整理现场只回答了一个方法,面试官希望有更多方法,现场另举了弹性布局,回来后整理了下,主要有以下四种方法: 1.居中浮动元素: 1.1 利用margin负值 123456789.son &#123; width:600px ; height:300px; margin: -150px 0 0 -300px; position:absolute;/*父元素relative*/ background-color:pink; left:50%; top:50%;&#125; 1.2 利用translate 12345678910111213141516.father &#123; width: 600px; height: 600px; position: relative; background-color: yellow;&#125;.son &#123; width: 200px; height: 200px; background-color: blue; position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%);&#125; 1.3 利用弹性布局` 12345678910111213.father &#123; width: 600px; height: 600px; background-color: yellow; display: flex; justify-content: center; align-items: center;&#125;.son &#123; width: 200px; height: 200px; background-color: blue;&#125; 1.4 利用margin特性 1234567891011121314151617.father &#123; width: 600px; height: 600px; position: relative; background-color: yellow;&#125;.son &#123; width: 200px; height: 200px; background-color: blue; position: absolute; margin: auto; left: 0; right: 0; top: 0; bottom: 0;&#125; 2.内容居中:123456.father&#123; height: 100px; line-height:100px; text-align: center; background-color:pink;&#125; 或者:123456.father&#123; display:table-cell;/*对象作为表格单元*/ vertical-align:middle; text-align:center; background-color:pink;&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ready与load比较]]></title>
    <url>%2F2017%2F11%2F11%2FJavaScript%2Fready%E4%B8%8Eload%2F</url>
    <content type="text"><![CDATA[1.执行时间不同： $(document).ready()是指html解析完毕，dom树已经建立起来,页面内容(html,css,js,图片)还未加载完成 $(window).load()是指页面所有的加载完毕。 2.执行次数不同 $(document).ready()可以执行多次。可以写多个。 $(window).load()一个页面,只能有一个，如果出现多个，则只会调用最后一个，之前的都会被覆盖。1234567891011121314&lt;script&gt; $(document).ready(function()&#123; alert("test1");//这段代码会被执行 &#125;); $(document).ready(function()&#123; alert("test2");//这段代码会被执行 &#125;); $(window).load(function()&#123; alert("test1");//这段代码不会被执行 &#125;); $(window).load(function()&#123; alert("test2");//这段代码将被执行 &#125;);&lt;/script&gt; 3.执行效率不同 $(document).ready()执行效率相对高一些 12345678910&lt;script&gt; $(document).ready(function()&#123; $(".the_body a").attr("onclick","alert('test')"); &#125;); $(window).load(function()&#123; $(".close_btn").click(function()&#123; $("#app_down").hide(); &#125;); &#125;);&lt;/script&gt; 4.js和jQuery 序号 原生js jQuery 1 document.ready=function(){} $(document).ready(function(){})==$(function(){}) 2 window.onload=function(){} $(window).load(function(){}) 3 window.location.reload();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex-shrink 新弹性和模型属性]]></title>
    <url>%2F2017%2F11%2F09%2FCSS%2Fflex-shrink%20%20%E6%96%B0%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[语法： flex-shrink： 默认值：1 适用于：flex子项 继承性：无 动画性：是 计算值：指定值 说明：设置或检索弹性盒的收缩比率。根据弹性盒子元素所设置的收缩因子作为比率来收缩空间。示例：a,b,c将按照1:1:3的比率来收缩空间 12345678910&lt;ul class="flex"&gt; &lt;li&gt;a&lt;/li&gt; &lt;li&gt;b&lt;/li&gt; &lt;li&gt;c&lt;/li&gt;&lt;/ul&gt;&lt;style&gt;.flex&#123;display:flex;width:400px;margin:0;padding:0;list-style:none;&#125;.flex li&#123;width:200px;&#125;.flex li:nth-child(3)&#123;flex-shrink:3;&#125;&lt;/style&gt; flex-shrink的默认值为1，如果没有显示定义该属性，将会自动按照默认值1在所有因子相加之后计算比率来进行空间收缩。 本例中c显式的定义了flex-shrink，a,b没有显式定义，但将根据默认值1来计算，可以看到总共将剩余空间分成了5份，其中a占1份，b占1份，c占3分，即1:1:3 我们可以看到父容器定义为400px，子项被定义为200px，相加之后即为600px，超出父容器200px。那么这么超出的200px需要被a,b,c消化 通过收缩因子，所以加权综合可得2001+2001+200*3=1000px； 于是我们可以计算a,b,c将被移除的溢出量是多少： a被移除溢出量：(2001/1000)200，即约等于40px b被移除溢出量：(2001/1000)200，即约等于40px c被移除溢出量：(2003/1000)200，即约等于120px 最后a,b,c的实际宽度分别为：200-40=160px, 200-40=160px, 200-120=80px]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>flex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于递归计算]]></title>
    <url>%2F2017%2F02%2F23%2FJavaScript%2F%E5%85%B3%E4%BA%8E%E9%80%92%E5%BD%92%E8%AE%A1%E7%AE%97%2F</url>
    <content type="text"><![CDATA[什么是递归在一个函数中直接或间接的调用自己的过程就是递归 1234567function fun()&#123; // 自己调用自己，称为递归调用 fun(); console.log("m2");&#125;fun(); 递归的两种形式: 函数+变量 函数+函数 函数+变量用递归来求5的阶乘12345678//(n! = n * (n-1)!)//f(n)=n*f(n-1)function func(n)&#123; if(n==1)&#123; return 1; &#125; return n*func(n-1)&#125; 递归的实现1） 边界条件：决定递归何时向上返回 2） 递归前进：只要没满足递归的边界条件，就一直向下调用自己 3） 递归返回：当满足边界条件时，向上返回（将所有计算出来的值，依次返回给调用者） 函数+函数12345678910斐波拉契数列(兔子生兔子题目)--从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子对数为多少// 产量分析：1， 1， 2， 3， 5， 8， 13， 21 。。。// 第n个月的兔子总数 = 第n-1个月的兔子总数 + 第n-2个月的兔子总数// 问题： 求任意月兔子的总数function calc(n)&#123; if(n==0||n==1)&#123; return 1; &#125; return calc(n-1)+calc(n-2);&#125; 一道面试题12345678910111213141516171819202122232425262728293031var obj=&#123; //在页面渲染出value值 value:1, children:[ &#123; value:2, children:[] &#125;, &#123; value:3, children:[&#123; value:4, children:[] &#125;] &#125; ]&#125;//采用无序列表var arr=["&lt;ul&gt;"];function fun(obj)&#123; var li="&lt;li&gt;"+obj.value+"&lt;/li&gt;"; arr.push(li); obj.children.map(function(val)&#123; return fun(val) &#125;)&#125;fun(obj);arr.push("&lt;/ul&gt;");var str=arr.join("");var div=document.createElement("div");div.innerHTML=str;document.body.appendChild(div);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式----文字长度溢出显示省略号]]></title>
    <url>%2F2016%2F11%2F02%2FCSS%2FCSS%E6%A0%B7%E5%BC%8F---%E6%96%87%E5%AD%97%E9%95%BF%E5%BA%A6%E6%BA%A2%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[text-overflow省略号样式语法结构 text-overflow语法：: clip | ellipsis ```12345678910111213141516171819- text-overflow参数值和解释：clip : 不显示省略标记（...），而是简单的裁切ellipsis : 当对象内文本溢出时显示省略标记（...）- text-overflow应用说明：CSS text-overflow设置或检索是否使用一个省略号标记（...）标示对象内文本文字的溢出。要想实现显示不完内容将显示省略号代替，还需要html nobr标签完成（nobr禁止换行标签）#### text-overflow应用案例- 1、实现方法对象设置text-overflow:ellipsis;省略号样式```csswidth:280px;display: inline-block;text-overflow:ellipsis; white-space:nowrap; /*规定段落中的文本不进行换行*/overflow:hidden;]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习记录]]></title>
    <url>%2F2016%2F10%2F12%2FCSS%2FCSS%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[1.上外边距的溢出在某些特殊条件下，在为子元素设置上外边距时有可能会作用在父元素上 特殊条件：（同时满足） 1.父元素不能有上边框； 2.为第一个子元素设置上外边距时 解决方案： 1、 为父元素增加上边框：会影响父元素的高度 2、 使用父元素的上内边距来取代子元素的上外边距：会影响父元素的高度 3、 在子元素上增加一个空的元素即可 2.CSS Sprites雪碧图将若干副不经常变换的图片封装到一幅大图中配合背景图片以及背景图片定位将想看的图片显示出来1） 在页面中创建一个与要显示区域大小一样的元素2） 将雪碧图作为元素的背景图3） 改变图片在元素中的位置（左上移动） 3.背景简写属性——background123background：color url( ) repeat attachment position;background: red;background: url(img/mm.png) no-repeat 95% center; 4.字体属性简写方式属性：font取值：style variant(小型大写字母) weight size family注意：一定要将Family写出来，否则无效 5.伪类选择器1)目标伪类: :target对页面中的某个target元素指定样式，该样式只对在用户点击了页面中的超链接并且跳转到target元素后起作用 2) :before或::before作用:匹配到某元素的内容区域之前 特点:外边距溢出问题3) :after或::after作用:匹配到某元素内容区域之后 解决浮动元素父元素的高度问题 :after 特点：1.在父元素的内容区域之后2.增加一个“空”元素 3.必须是块级元素 4.必须设置clear:both 6.图片和行内快的vertical-align属性控制图片或行内块元素两边的文本，相对于他们的对齐方式 取值： 1. top 2. middle 3. bottom 4. baseline 基线对齐 a) 行内块：基线是在最后一行文本的底部 b) 图片：基线是在图片底部向下3px(不一定)位置处 1img&#123;vertical-align:bottom;&#125; 7. 绝对定位对元素的影响 脱离文档流，允许压在其他元素的上方 绝对定位的元素会变成块级元素. margin可以正常使用，但是margin的左右auto值会失效. 绝对定位的元素，将left，right，bottom，top四个值都设置为0 的情况下，margin:auto会让整个元素变得绝对居中 8.弹性布局8.1 属性:display取值: 1、flex：将块级元素变为弹性布局的容器 2、inline-flex：将行内元素变为弹性布局的容器 注意： 1、 容器中的项目们会自动变为块级元素，允许修改尺寸 2、 项目们的float、clear、vertical-align、全部失效 3、 容器的text-align属性也会失效 8.2 属性flex-wrap取值:1.nowrap 2.wrap 3.wrap-reverse 8.3 justify-content作用：指定项目在主轴上的对齐方式取值： 1、 flex-start在轴的起点对齐 2、 flex-end 在轴的终点对齐 3、 center 居中对齐 4、 space-between 两端对齐，项目之间的间隔都是相等的 5、 space-around 每个项目两边的空白间距是相等的 9.转换 transform取值: 1.位移:translate(x)/translate(x,y)/translateX(x)/translateY(y) 2.缩放:scale(value)/scale（x，y）/scaleX（x）/scaleY（y） 3.旋转:rotate(ndeg) 4.倾斜:skewX(ndeg)/skewY(ndeg)/skew(x)/skew(x,y) 9.1 转换原点 属性:transform-origin 取值:1. 两个值：表示原点在x轴和y轴的位置 2. 三个值：表示原点在x轴、y轴和z轴的位置 可以取数值/百分比/关键字，多个值用空格隔开 9.2 3D转换(模拟人眼睛到3D转换物体的距离，取值越大，表示离物体越远，表示离物体越近) 属性:perspective 取值:rotateX(xdeg) 以x轴为中心轴旋转 rotateY(ydeg) 以y轴为中心轴旋转 rotateZ(zdeg) 以z轴为中心轴旋转 rotate3D(x,y,z,ndeg) x,y,z 取值大于0的话，则该轴参与旋转 x,y,z 取值为0的话，则该轴不参与旋转 rotate3D(1,0,0,45deg)==&gt;rotateX(45deg) 10.过渡 属性:transition 取值:property duration timing-function delay;11.动画样式表中,通过@keyframes规则来声明动画123456789101112131415@keyframes 动画名称name&#123; 0%&#123; /*动画开始时，元素的样式*/ 属性：值; 属性: 值; &#125; 50%&#123; /*动画执行到一半时，元素的样式*/ &#125; 100%&#123; /*动画结束时，元素的样式*/ 属性: 值; 属性: 值; &#125; &#125; 11.1动画声明的浏览器兼容性Firefox：@-moz-keyframes{ } Chrome &amp; Safari: @-webkit-keyframes{ } Oprea: @-o-keyframes{ } 11.2调用动画简写属性:animation取值:name duration timing-function delay iteration-count(播放次数) direction 11.3动画填充模式:animation-fill-mode 取值: 1.none 默认值，无任何效果 2.forwards 档动画播放完成后，元素将保持在最后一个帧的状态上 3.backwards 动画播放前，在延迟时间内，动画将保持在第一帧的状态上 4.both 动画播放前后，分别应用在第一帧和最后一个帧上 11.4动画播放状态animation-play-state 取值 paused：动画暂停 running：动画播放]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>学习记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[餐饮研发员的基本素质]]></title>
    <url>%2F2016%2F07%2F12%2FFood%2F%E9%A4%90%E9%A5%AE%E7%A0%94%E5%8F%91%E5%91%98%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B4%A0%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[餐饮属于快节奏的行业，对研发员的工作是很大的挑战。 现在的餐饮都要做标准化，也要做创新，那么如何去做一位合格的餐饮研发员呢？ 首先要明确研发的定位，设定一个场景： 当一家连锁餐饮企业希望由我们作为他们的中央厨房代加工，他们有自己成熟的菜品，包括配方和工艺，但他们缺少工业化生产的工艺和经验，需要我们为他们解决以达到合作。 这里研发的价值就是：转化客户现有的产品，在保证客户口感的前提下，实现产品和工业化生产，输出工业化生产工艺标准和产品标准。 这里有两种做法： 将客户的产品在研发厨房模拟操作，做到口味相近，写出标准化生产的工艺和产品标准，再去生产车间按标准中试，产品达到客户要求则研发过程结束，产品不合格再调整工艺直到符合客户要求； 对客户的产品进行分拆：原料、配方、工艺、包装、成品。分析成品选择合适的原料，结合研发厨房和测试，确定生产加工的工艺和产品和包装，寻求产品在品质和成本之间的平衡点。 两类研发都输出产品的工业化工艺标准和产品标准，但却有本质的区别。 第一种是标准化转化工作，只能凭借自身丰富的厨政经验和生产实际经验，不断摸索尝试，达到产品输出的目的。只能针对普通要求的客户进行产品制作，专业性差。 第二种是才是研发工作，运用专业的知识从源头为客户提供解决方案。针对客户的需求选用合适的原料和合适的加工工艺，并且在源头就解决产品在输出过程中可能遇到的问题。可以针对不同层次要求的客户进行产品定制，并在研发中不断积累自身的核心产品和加工技术。 做食品研发不仅要明确方向，更要专一、沉稳！浮躁的心做不好研发工作。 餐饮的研发是食品研发中最考验研发员的工作态度的工作，承接餐饮客户的部分产品是必然，这就决定了工作节奏快，不能给你充足的时间去研究产品，以解决问题为主。而在一些项目开发中，你要深度运用自己的专业知识去挖掘。专业的事让专业的人做，研发要追求完美的产品，过程不一定全程参与，但一定要明白产品做出来的关键点也就是核心技术，这样才能掌握产品和标准，你才是产品的核心！ 不论是餐饮客户产品转化还是项目开发，作为一名合格的餐饮研发员，需要明白工作的目的，明确自己的目标，要不断去比较，不断的去总结。 研发是一门独孤求败的匠心工作，追求极致，如果你心沉浸在这里，一切的辛苦，在看到产品被人赞美的那一刻，都是值得的！]]></content>
      <categories>
        <category>food</category>
      </categories>
      <tags>
        <tag>工作感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一年四季的时令蔬菜水果表]]></title>
    <url>%2F2016%2F06%2F08%2FFood%2F%E4%B8%80%E5%B9%B4%E5%9B%9B%E5%AD%A3%E7%9A%84%E6%97%B6%E4%BB%A4%E8%94%AC%E8%8F%9C%E6%B0%B4%E6%9E%9C%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[春季（农历一~三月）蔬菜：辣椒、青椒、彩椒、洋葱、花椰菜、甜豆、豌豆、芹菜、莴苣、荠菜、油菜、菠菜、香椿、春笋、马兰头、瓠瓜、韭菜、春韭、菜心、茼蒿、豆苗、蒜苗、春笋等水果：番石榴、青枣、枇杷、桑葚、樱桃、莲雾（春末）。 夏季（农历四~六月）蔬菜：辣椒、丝瓜、苦瓜、冬瓜、菜豆、芦笋、茭白、洋葱、黄瓜、佛手瓜、南瓜、苋菜、山苏、空心菜、龙须菜、地瓜叶、竹笋、生菜、西红柿、卷心菜、茄子、豇豆、黄瓜、西红柿、东瓜、四季豆、蚕豆等水果：草莓、莲雾、桃、李、西瓜、菠萝、芒果、柠檬、百香果、火龙果、杏、荔枝、猕猴桃、香蕉、椰子、樱桃。 秋季（农历七~九月）蔬菜：秋葵、菱角、莲藕、辣椒、栗子、冬瓜、四季豆（芸豆）、地瓜叶、豆角、山药、白菜、扁豆。 菜花、胡萝卜、藕、大葱、豆角、黄瓜、西红柿、藕、茄子、百合水果：柚子、梨、柿子、木瓜、苹果、莲子、甘蔗、葡萄、火龙果、杨桃、番石榴、杏、橘子、红枣、山楂、核桃。 冬季（农历十~十二月）蔬菜：青椒、卷心菜、白菜、洋葱、花椰菜、胡萝卜、萝卜、甜豆、芹菜、菠菜、芥菜、葵年菜、莴苣、花椰菜、大白菜、油菜、油麦菜、菜心、芥菜、菠菜、黄芽白、芥蓝、荸荠、藕等水果：橙、橘子、柚子、青枣、甘蔗、释迦。 按月份排的时令蔬菜水果 1月：青菜、卷心菜、菠菜、芹菜、萝卜、慈菇等 2月：青菜、卷心菜、菠菜、芹菜、菜尖等 3月：青菜、菠菜、芹菜、菜尖、花菜等 4月：青菜、莴笋、鸡毛菜、芹菜 5月：青菜、卷心菜、莴笋、鸡毛菜、黄瓜、蚕豆、茭白、番茄等 6月：卷心菜、黄瓜、番茄、土豆、鸡毛菜、刀豆（菜豆）、茄子、南瓜等 7月：豇豆、茄子、鸡毛菜、卷心菜、冬瓜、丝瓜、毛豆、辣椒、土豆、扁豆、卷心菜、空心菜等 8月：冬瓜、豇豆、茄子、青菜、鸡毛菜、南瓜、丝瓜、毛豆、辣椒、土豆、扁豆、卷心菜、空心菜等 9月：青菜、冬瓜、萝卜、丝瓜、毛豆、豇豆、茄子、辣椒、芋艿、茭白、卷心菜、扁豆等 10月：青菜、卷心菜、菠菜、芹菜、萝卜、芋艿、茭白、花菜、茼蒿、生菜、花瓜等 11月：青菜、卷心菜、菠菜、芹菜、萝卜、莴笋、花菜、荠菜、草头、生菜、慈菇、青蒜等 12月：青菜、卷心菜、博菜、芹菜、萝卜、塌菜、荠菜、慈菇、花菜等 要吃就吃当季水果各种水果成熟时间汇总 1月(冬季) 木瓜 红香蕉 樱桃番茄 杨桃 柑橘橙 青枣 甘果蔗 草莓 番石榴 牛奶蕉 柑桔 观赏南瓜 无花果 鹤首瓜 2月(冬季) 木瓜 红香蕉 樱桃番茄杨桃 番荔枝 青枣 甘果蔗 草莓 番石榴 牛奶蕉 柑桔 观赏南瓜 鹤首瓜 3月(春季) 枇杷 红香蕉 樱桃番茄杨桃 番荔枝 青枣 甘果蔗 草莓 番石榴 牛奶蕉 柑桔 观赏南瓜 果桑 鹤首瓜 蛇瓜 4月(春季) 枇杷 红香蕉 樱桃番茄荔枝 番荔枝 蛇瓜 甘果蔗 果桑 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 澳州坚果 柠檬 5月(春季) 芒果 红香蕉 樱桃番茄荔枝 番荔枝 蛇瓜 黄皮 果桑 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 李 西瓜 桃 香瓜 柠檬 台湾莲雾 澳州坚果油梨 6月(夏季) 芒果 红香蕉 樱桃番茄荔枝 番荔枝 蒲瓜 黄皮 果桑 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 李 西瓜 桃 香瓜 柠檬 台湾莲雾 澳州坚果菠萝 火龙果油梨 7月(夏季) 芒果 红香蕉 樱桃番茄荔枝 番荔枝 蒲瓜 黄皮 番龙眼 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 李 西瓜 桃 香瓜 柠檬 台湾莲雾 澳州坚果菠萝 火龙果 油梨龙眼 百香果 菠萝蜜 8月(夏季) 芒果 红香蕉 樱桃番茄木瓜 番荔枝 蒲瓜 杨桃 番龙眼 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 日本甜柿 西瓜 黑提子 香瓜 柠檬 菠萝蜜澳州坚果 菠萝 火龙果油梨 龙眼 百香果 9月(秋季) 芒果 红香蕉 鸡蛋果木瓜 番荔枝 百香果 杨桃 番龙眼 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 日本甜柿 西瓜 黑提子 香瓜 柠檬 菠萝蜜油梨 菠萝火龙果 10月(秋季) 樱桃番茄 红香蕉 鸡蛋果木瓜 台湾甜玉米 百香果 杨桃 无花果 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 火龙果 西瓜 黑提子 人心果 柠檬菠萝 油梨 11月(秋季) 樱桃番茄 红香蕉 鸡蛋果木瓜 台湾甜玉米 百香果 杨桃 无花果 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 火龙果 台湾青枣 黑提子 人心果柠檬 菠萝油梨 12月(冬季) 樱桃番茄 红香蕉 鸡蛋果木瓜 草莓 百香果 杨桃 无花果 番石榴 牛奶蕉 鹤首瓜 观赏南瓜 果蔗 台湾青枣 黑提子 人心果 柠檬 菠萝油梨柑橘橙 按季节分的时令蔬果： 春季（农历一~三月） 蔬菜：辣椒、青椒、彩椒、洋葱、花椰菜、甜豆、豌豆、芹菜、莴苣、荠菜、油菜、菠菜、香椿、春笋、马兰头、瓠瓜。水果：番石榴、青枣、枇杷、桑葚、樱桃、莲雾（春末）。 夏季（农历四~六月） 蔬菜：辣椒、丝瓜、苦瓜、冬瓜、菜豆、芦笋、茭白、洋葱、黄瓜、佛手瓜、南瓜、苋菜、山苏、空心菜、龙须菜、地瓜叶、竹笋、生菜、西红柿、卷心菜、茄子。水果：草莓、莲雾、桃、李、西瓜、菠萝、芒果、柠檬、百香果、火龙果、杏、荔枝、猕猴桃、香蕉、椰子、樱桃。 秋季（农历七~九月） 蔬菜：秋葵、菱角、莲藕、辣椒、栗子、冬瓜、四季豆（芸豆）、地瓜叶、豆角、山药、白菜、扁豆。水果：柚子、梨、柿子、木瓜、苹果、莲子、甘蔗、葡萄、火龙果、杨桃、番石榴、杏、橘子、红枣、山楂、核桃。 冬季（农历十~十二月） 蔬菜：青椒、卷心菜、白菜、洋葱、花椰菜、胡萝卜、萝卜、甜豆、芹菜、菠菜、芥菜、葵年菜、莴苣。水果：橙、橘子、柚子、青枣、甘蔗、释迦。 吃当季当地的蔬果,自然成熟的蔬果。吃水果要分清寒热,根据自己的体质选择。 常见水果的性质： 温性水果：山楂、樱桃、石榴、荔枝、青果、木瓜、白果等 凉性水果：西瓜、甜瓜、梨、柑、桔、香蕉、桑椹、柿子、荸荠等。 中性水果：葡萄、苹果、桃、杏、菠萝、龙眼、甘蔗、乌梅等。食物的温寒性 属于寒性的食物有 苦瓜、番茄、茭白、荸荠、菱肉、百合、藕、竹笋、慈姑、魔芋、空心菜、蒲公英、败酱草、鱼腥草、马齿苋、蕨菜、苦菜、荠菜、香椿、莼菜、黑鱼、鲤鱼、河蟹、泥螺、文蛤、蛏子、海蜇、海带、紫菜、田螺、河蚌、蛤蜊、牛奶、豆豉、桑葚、甘蔗、梨、西瓜、柿子、香蕉等。 温热性食物有： 适用于风寒感冒、发热、恶寒、流涕、头痛等症象的生姜、葱白、香菜；适用于腹痛、呕吐、喜热饮等症象的干姜、红茶；适用于肢冷、畏寒、风湿性关节痛等症象的辣椒、酒等。 平性食物有： 大米、黄豆、黑芝麻、花生、土豆、白菜、圆白菜、胡萝卜、洋葱、黑木耳、柠檬猪肉、主题、鸡蛋，鱼肉中的鲤鱼、鲫鱼、泥鳅、黄鱼、鲳鱼。另外我们日常里饮用的牛奶也属于平性食物。 凉性食物有： 荞麦、玉米、白萝卜、冬瓜、蘑菇、芹菜、莴笋、油菜、橙子、苹果等等。 寒性食物有： 小米、绿豆、海带、绿豆芽、苦瓜、西红柿、黄瓜、香蕉、西瓜、甜瓜等等。食物的性是指“四性”，即寒、热、温、凉四种食性。凉性和寒性，温性和热性，在作用上有一定同性。只是在作用大小方面稍有差别。此外，有些食物其食性平和，称为平性。能减轻或消除热证的食物，属寒凉性；能减轻和消除寒证的食物属温热性。一般认为，寒凉性食物大都具有清热、泻火、解毒作用，常用于热性病证。温热性食物大多具有温中、助阳、散寒等作用，常用于寒性病证。平性食物则有健脾、开胃、补益身体的作用。 01.樱桃成熟期在5月中旬到6月中旬； 02.露地草莓在5月中下旬开始采摘，草莓的酸甜味道才浓厚； 03.杏成熟期在5月下旬至7月中旬； 04.桃从6月中旬到10月初都有成熟的； 05.李子早熟品种6月上旬就开始上市，最好吃的品种应在8、9月间成熟; 06.枣品种的成熟期在9月中下旬到10月上旬，大枣才有枣味，在此之前上市的枣又柴又木，根本没法吃； 07.有些苹果品种入伏后就成熟，即“伏苹果”，中晚期成熟的苹果，如“红星”9月底才熟，“富士”系列到10月份才能上市； 08.梨的早熟品种8月上旬成熟，如“绿宝石”，但价钱较贵，大多数梨在9月底或10月初上市； 09.柿子一般在霜降节气，也就是10月下旬才开始上市； 10.桔子分早熟的和晚熟的,一般来说早熟的在8月就可以了,晚熟的话可以晚到11月,不过这也不是绝对的,要看你是在哪个地域,还有就是当年的气候： 11.芒果开花至果实成熟时间因气候和品种而异，一般约需110～150天，6～9月间可陆续采收： 12.柚严格来讲，柚子成熟于深秋和初冬交接的时间， 13.一般的柚品种的成熟期大多集中在11-12月份，但矮晚柚的成熟期在第二年重-2月，正值春节期间； 14.红毛丹每年2月至4月开花，6月至8月为果实成熟采摘季节； 15.菠萝蜜又称木菠萝、树菠萝，海南特产的一种热带桑科常绿乔木。果实6~7月成熟，果实巨大，最重达40公斤，被称为水果之王、热带水果皇后，果实硕大，重者有20至25千克。 16.香蕉-按其种植时期，大致有三种蕉：春种蕉，每年在”雨水”前后的2至3月份种植，8至9月份抽蕾，11至12月份成熟。秋植蕉，一般于秋分前后的9至10月间种植，次年7月份抽蕾，10月中至11月初成熟。还有夏植蕉，于6至8月份种植，次年7月初抽蕾，9月底至10月份采果。以上是正常情况，若遇异常情况，尤其是遇寒害低温，则会延期成熟； 17.桃——桃从6月中旬到10月初都有成熟的； 18.榴莲成熟时间在7·8月，榴莲从树上摘下来后，十天就可成熟； 19.核桃：每年的九月份开始是山核桃的收获季节； 20.柠檬胡成熟季节在冬季； 21.杨梅的成熟期在5-6月份，南方5-6月份又是多雨季节，所以称为梅雨； 22.珍珠番石榴种后6——8个月即可开花结果，第二年即可四季开花结果，开花期集中于4——5月和8——10月，成熟期集中于7——9月和12——1月； 23.菠萝：一般热带一年可两次收获菠萝,有冬春菠萝和夏季菠萝之分,冬春菠萝在4、5月份成熟,夏季菠萝在7月份左右才可收收获； 24.龙眼就是桂圆..桂圆是龙眼干，9月至10月上旬成熟. 25.水蜜桃:依成熟期早晚分为极早熟、早熟、中熟、晚熟、极晚熟5类。果实发育期（即开花盛期至果实成熟所需天数）在80天以内的为极早熟，80～85天的为早熟，100～120天的为中熟，120～150天的为晚熟，150天以上的为极晚熟。 特早熟水蜜桃（5月底、6月上旬成熟） 五月鲜：6月下旬成熟，尖顶圆形，缝合线深而明显，色鲜红，肉脆，汁少，味酸甜。 大久保：7月下旬成熟，果大近圆形，底色黄绿，果顶有红晕，柔软多汁，芳香离核，味甜微酸，品质上等。 白凤：8月上旬成熟，近圆形，果面有鲜红色条纹，皮薄易剥，果肉白中透绿，多汁粘核，味甘甜，品质上等。 巨红水蜜桃：7月上旬成熟，大久保芽变选育而成，单果重200克，含糖量高，有清淡桃香，离皮、离核，品质上等。魁桃：又称红蜜，7月重旬成熟，色淡黄托着鲜红，皮薄肉细，汁多而稠，甘甜如蜜，品质上等 26.番荔枝又称佛头果一年可开花3次，开花至采收需时60~70天，以6月上旬结果最多，5月下旬所结的果最优； 27.荔枝成熟季节在5月初至6月底； 葡萄的正常成熟期是在七八月份，冬天也能吃上葡萄，．．研制了一年两熟的葡萄栽培技术，并开始大面积栽种，预计每次产量可达6万吨； 28.枇杷秋冬开花，春末夏初果实成熟； 29.木瓜一般几时都有； 30.椰子树一年四季都开花，但椰子只在每年最热的时候成熟，椰子的特殊性情使得它对高温特别依恋，所以在热带…； 31.火龙果高产，同时产果期长达6个月，分12至15批成熟火龙果从开花到果实成熟，约35天，当果实由绿色逐渐变红色，果实微香、鲜艳时，就可采收 32.无花果成熟季节在9－10月； 33.芭蕉每年2月至4月开花，6月至8月为果实成熟采摘季节； 34.人心果每年2月至4月开花，6月至8月为果实成熟采摘季节； 35.薄桃在年均温度在20度以上可开花，结果，一般盛花期3－4月，夏、秋季也有零星的花朵开放。果实于5-7月成熟。]]></content>
      <categories>
        <category>food</category>
      </categories>
      <tags>
        <tag>蔬菜</tag>
        <tag>水果</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈餐饮的标准化]]></title>
    <url>%2F2016%2F05%2F12%2FFood%2F%E6%B5%85%E8%B0%88%E9%A4%90%E9%A5%AE%E7%9A%84%E6%A0%87%E5%87%86%E5%8C%96%2F</url>
    <content type="text"><![CDATA[对于餐饮，我其实第一感觉就是不喜欢，因为不规范。 餐饮从业者大部分都是厨师，他们有丰富的厨艺和从业经验，可以说他们炒一个菜是分分钟的事。但是，并不是每一位厨师都是大师，更多的是一个厨子。 当前餐饮连锁店都倡导标准化转化，厨师也做起了研发，一道“西红柿炒鸡蛋”可以分解成几种原料形式，分别打包在独立包装，用时拆包混合就行。似乎看起来很简单，但实际做的时候没有那么简单。做一锅一人份的和一锅100人份的西红柿炒鸡蛋的配方和工艺完全不一样，加工的时间、加热的温度、所需要的原辅料添加重量、添加的顺序都需要重新计算，不再是适量、少许、火候、爆香等传统厨师用语来衡量，必须由准确的数据来定量每一道工序，普通的厨师做得到吗？ 现在的餐饮必然会是厨师+食品专业技术人员结合，由厨师做出一道菜，专业人员负责从食材的选择、工艺记录、产品标准制定等整个过程。不仅仅是这样，专业人员还需要研究这道菜在做出来后的风味变化，采用什么的工艺、包装以及储存条件才能让菜品风味保存更久，口感达到最佳的一个状态。这个就需要科学的理论支持。 现在我们总是自以为是，以为自己什么都会，厨师可以去研究专业理论，食品专业的人可以去做菜。真正的资源最大化利用是取长补短，由食品专业的人科普食品加工知识，厨师传授做菜的经验。 一道“西红柿炒鸡蛋”可以有几十种口味，但一份工艺只会产出一种口味或者说几种相近的口味，这就是标准化的能力。 现在的研发厨师不一定会编制这样的工艺，但都懂这样的标准化工艺带来的好处。但进一步的说,如何将这样标准化的菜品提升，可能才是餐饮标准化的核心技术。 菜品进一步分解： 选择不同的食材、采用不同的工艺技术，做出不同等级的菜品； 利用食品添加剂，改善菜品最终的成色和口感； 通过杀菌技术和包装技术，最大程度的延长货架期和保留风味； 总结菜品的加工规律，利用数据分析菜品加工变化，优化菜品加工工艺； 知识是为人服务的并指引正确方向的，资源也是要共享的，餐饮的标准化一定是厨师传授专业人员做菜过程，专业人员用科学的方法指引厨师做菜提升菜品品质。]]></content>
      <categories>
        <category>food</category>
      </categories>
      <tags>
        <tag>工作感想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苹果为什么会褐变]]></title>
    <url>%2F2016%2F04%2F19%2FFood%2F%E8%8B%B9%E6%9E%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E8%A4%90%E5%8F%98%2F</url>
    <content type="text"><![CDATA[当切开的苹果不及时吃掉，它就会由白色苹果慢慢变成暗淡的棕褐色苹果，影响你的食欲。最好的消息是它依然是安全的苹果，你可以吃掉它。导致苹果变色的原因是酶促褐变，当植物组织内存在的酶与多酚类物质结合在氧气的环境下产生的分子反应，产生的黑色素。 不仅苹果有这种现象，其他水果如梨、香蕉、鳄梨、茄子和土豆都存在酶促褐变，因为他们都存在酶的底物————酚类化合物。 切块的苹果让细胞组织破碎，原本分开的酚类物质和酶相结合，同时当你切开苹果时，酚类物质与酶的混合物就会暴露在空气中，就会产生氧化褐变过程。这个过程持续时间越长，褐变程度越深，直到酚类物质消耗完，这时苹果也就变成棕色的了。 酶只是普通的蛋白质，但是它在自然界中有特殊的功能。大多数化学反应需要较高的活化能才能进行，而酶可以降低化学反应的活化能促使一些反应发生。酶是一种催化剂，它能加快化学反应速率。本身酶在反应过程中不被消耗，也不影响反应的化学平衡。但它会不断催化化学反应进行。有些反应是不可逆的，如水果切块的酶促褐变反应， 但酶在食品中也有重要的积极作用，举个例子：凝乳酶可以促使液态来凝结成奶酪，乳糖酶可以分解我们人体内的乳糖（除非你有乳糖不耐症），食品工业中还利用酶含量来判断海鲜的新鲜度、巴氏杀菌奶的安全以及其他积极应用。此外，酶促褐变反应还有利于茶、咖啡和葡萄干形成理想的色泽。]]></content>
      <categories>
        <category>food</category>
      </categories>
      <tags>
        <tag>保鲜知识</tag>
      </tags>
  </entry>
</search>
