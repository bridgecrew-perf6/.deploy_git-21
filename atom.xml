<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>靖风行&#39;S blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.haohome.top/"/>
  <updated>2019-01-28T06:30:25.458Z</updated>
  <id>http://blog.haohome.top/</id>
  
  <author>
    <name>Yifoo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript设计模式之迭代器模式</title>
    <link href="http://blog.haohome.top/2019/01/27/JavaScript/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.haohome.top/2019/01/27/JavaScript/JavaScript设计模式之迭代器模式/</id>
    <published>2019-01-26T16:00:00.000Z</published>
    <updated>2019-01-28T06:30:25.458Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>迭代器模式是指在不暴露对象内部结构的同时,可以<strong>顺序</strong>的访问聚合对象的内部元素</p></blockquote><p>迭代器主要解决不同的方式来遍历整个整合对象</p><p>业务场景:</p><ul><li>根据不同浏览器获取相应的上传组件对象</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(...)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="keyword">if</span>(supportFlash())&#123;</span><br><span class="line">        <span class="keyword">return</span> flashUpload</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h5Upload</span><br><span class="line">      &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果浏览器支持上传控件,会优先选用上传控件,如果没有则判断是否支持flash,如果连flash也没有安装,则采用h5原生的上传方式</p></blockquote><a id="more"></a><p>为了得到一个upload对象,程序使用了try…catch和if语句,造成阅读困难,同时违反开放封闭原则</p><p>如果每一种获取upload对象方法封装成独立的函数里,再使用迭代器遍历这些函数组成的集合,从而获取到可用的upload对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getActiveObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ActiveXObject(...)</span><br><span class="line">    &#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">var</span> getFlashObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(supportFlash())&#123;</span><br><span class="line">      <span class="keyword">return</span> flashUpload</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> getH5Upload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h5Uplaod</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>迭代器只需要做以下工作:</p><ul><li>提供一个可以遍历集合的方法,使得按照一定的优先级顺序遍历迭代</li><li>如果正在被迭代的函数返回一个对象,则表示找到了正确的upload对象,如果返回false,则迭代器继续工作</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> iteratorUploadObj = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">var</span> i = <span class="number">0</span>, fn; fn = <span class="built_in">arguments</span>[ i++ ]; )&#123;</span><br><span class="line">        <span class="keyword">var</span> uploadObj = fn();</span><br><span class="line">        <span class="keyword">if</span> ( uploadObj !== <span class="literal">false</span> )&#123;</span><br><span class="line">            <span class="keyword">return</span> uploadObj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> uploadObj = iteratorUploadObj(getActiveObj,getFlashObj,getH5Upload)</span><br></pre></td></tr></table></figure><p>这样的迭代模式使得获取不同上传对象的方法独立,很方便后续的维护,比如添加了一个上传控件方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newUploadPlugin = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(supportPlugin())&#123;</span><br><span class="line">    <span class="keyword">return</span> uploadPluginObj</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> uploadObj = iteratorUploadObj(newUploadPlugin,getActiveObj,getFlashObj,getH5Upload)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;迭代器模式是指在不暴露对象内部结构的同时,可以&lt;strong&gt;顺序&lt;/strong&gt;的访问聚合对象的内部元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;迭代器主要解决不同的方式来遍历整个整合对象&lt;/p&gt;
&lt;p&gt;业务场景:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据不同浏览器获取相应的上传组件对象&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; getUploadObj = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ActiveXObject(...)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt;(e)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(supportFlash())&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; flashUpload&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; h5Upload&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;如果浏览器支持上传控件,会优先选用上传控件,如果没有则判断是否支持flash,如果连flash也没有安装,则采用h5原生的上传方式&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JS" scheme="http://blog.haohome.top/tags/JS/"/>
    
      <category term="设计模式" scheme="http://blog.haohome.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>自己动手实现一个前端路由</title>
    <link href="http://blog.haohome.top/2018/11/18/JavaScript/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1/"/>
    <id>http://blog.haohome.top/2018/11/18/JavaScript/自己动手实现一个前端路由/</id>
    <published>2018-11-17T16:00:00.000Z</published>
    <updated>2018-11-19T13:08:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>单页面应用利用了JavaScript动态变换网页内容,避免了页面重载;路由则提供了浏览器地址变化,网页内容也跟随变化,两者结合起来则为我们提供了体验良好的单页面web应用</p></blockquote><h2 id="前端路由实现方式"><a href="#前端路由实现方式" class="headerlink" title="前端路由实现方式"></a>前端路由实现方式</h2><p>路由需要实现三个功能:</p><p>​    ①浏览器地址变化,切换页面;</p><p>​    ②点击浏览器【后退】、【前进】按钮，网页内容跟随变化；</p><p>​    ③刷新浏览器，网页加载当前路由对应内容</p><p>在单页面web网页中,单纯的浏览器地址改变,网页不会重载,如单纯的hash网址改变网页不会变化,因此我们的路由主要是通过监听事件,并利用js实现动态改变网页内容,有两种实现方式:</p><p><code>hash</code>路由: 监听浏览器地址hash值变化,执行相应的js切换网页<br><code>history</code>路由: 利用history API实现url地址改变,网页内容改变</p><a id="more"></a><h2 id="hash路由"><a href="#hash路由" class="headerlink" title="hash路由"></a>hash路由</h2><p>首先定义一个<code>Router</code>类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(obj) &#123;</span><br><span class="line">    <span class="comment">// 路由模式</span></span><br><span class="line">    <span class="keyword">this</span>.mode = obj.mode</span><br><span class="line">    <span class="comment">// 配置路由</span></span><br><span class="line">    <span class="keyword">this</span>.routes = &#123;</span><br><span class="line">      <span class="string">'/index'</span>: <span class="string">'views/index/index'</span>,</span><br><span class="line">      <span class="string">'/index/detail'</span>: <span class="string">'views/index/detail/detail'</span>,</span><br><span class="line">      <span class="string">'/index/detail/more'</span>: <span class="string">'views/index/detail/more/more'</span>,</span><br><span class="line">      <span class="string">'/subscribe'</span>: <span class="string">'views/subscribe/subscribe'</span>,</span><br><span class="line">      <span class="string">'/proxy'</span>: <span class="string">'views/proxy/proxy'</span>,</span><br><span class="line">      <span class="string">'/state'</span>: <span class="string">'views/state/stateDemo'</span>,</span><br><span class="line">      <span class="string">'/state/sub'</span>: <span class="string">'views/state/components/subState'</span>,</span><br><span class="line">      <span class="string">'/dom'</span>: <span class="string">'views/visualDom/visualDom'</span>,</span><br><span class="line">      <span class="string">'/error'</span>: <span class="string">'views/error/error'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.init()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由初始化<code>init()</code>时监听<code>load</code>,<code>hashchange</code>两个事件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="keyword">this</span>.hashRefresh.bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.hashRefresh.bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>浏览器地址hash值变化直接通过a标签链接实现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">id</span>=<span class="string">"nav"</span> <span class="attr">class</span>=<span class="string">"nav-tab"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">'tab'</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'nav-item'</span> <span class="attr">href</span>=<span class="string">"#/index"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'nav-item'</span> <span class="attr">href</span>=<span class="string">"#/subscribe"</span>&gt;</span>观察者<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'nav-item'</span> <span class="attr">href</span>=<span class="string">"#/proxy"</span>&gt;</span>代理<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'nav-item'</span> <span class="attr">href</span>=<span class="string">"#/state"</span>&gt;</span>状态管理<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">'nav-item'</span> <span class="attr">href</span>=<span class="string">"#/dom"</span>&gt;</span>虚拟DOM<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span> <span class="attr">class</span>=<span class="string">'container'</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">class</span>=<span class="string">'main'</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>hash值变化后,回调方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash路由刷新执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">hashRefresh() &#123;</span><br><span class="line">  <span class="comment">// 获取当前路径,去掉查询字符串,默认'/index'</span></span><br><span class="line">  <span class="keyword">var</span> currentURL = location.hash.slice(<span class="number">1</span>).split(<span class="string">'?'</span>)[<span class="number">0</span>] || <span class="string">'/index'</span>;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentURL]</span><br><span class="line">  <span class="keyword">this</span>.controller(<span class="keyword">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 组件控制器</span></span><br><span class="line"><span class="comment">  * @param &#123;string&#125; name </span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">controller(name) &#123;</span><br><span class="line">  <span class="comment">// 获得相应组件</span></span><br><span class="line">  <span class="keyword">var</span> Component = <span class="built_in">require</span>(<span class="string">'../'</span> + name).default;</span><br><span class="line">  <span class="comment">// 判断是否已经配置挂载元素,默认为$('#main')</span></span><br><span class="line">  <span class="keyword">var</span> controller = <span class="keyword">new</span> Component($(<span class="string">'#main'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑到存在多级页面嵌套路由的存在,需要对嵌套路由进行处理:</p><ul><li>直接子页面路由时,按父路由到子路由的顺序加载页面</li><li>父页面已经加载,再加载子页面时,父页面保留,只加载子页面</li></ul><p>改造后的路由刷新方法为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">hashRefresh() &#123;</span><br><span class="line">  <span class="comment">// 获取当前路径,去掉查询字符串,默认'/index'</span></span><br><span class="line">  <span class="keyword">var</span> currentURL = location.hash.slice(<span class="number">1</span>).split(<span class="string">'?'</span>)[<span class="number">0</span>] || <span class="string">'/index'</span>;  </span><br><span class="line">  <span class="comment">// 多级链接拆分为数组,遍历依次加载</span></span><br><span class="line">  <span class="keyword">this</span>.currentURLlist = currentURL.slice(<span class="number">1</span>).split(<span class="string">'/'</span>)</span><br><span class="line">  <span class="keyword">this</span>.url = <span class="string">""</span></span><br><span class="line">  <span class="keyword">this</span>.currentURLlist.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 导航菜单激活显示</span></span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.navActive(item)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.url += <span class="string">"/"</span> + item</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="keyword">this</span>.routes[<span class="keyword">this</span>.url]</span><br><span class="line">    <span class="comment">// 404页面处理</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.name) &#123;</span><br><span class="line">      location.href = <span class="string">'#/error'</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于嵌套路由的处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.oldURL &amp;&amp; <span class="keyword">this</span>.oldURL[<span class="number">0</span>]==<span class="keyword">this</span>.currentURLlist[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.handleSubRouter(item,index)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.controller(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 记录链接数组,后续处理子级组件</span></span><br><span class="line">  <span class="keyword">this</span>.oldURL = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>.currentURLlist))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 处理嵌套路由</span></span><br><span class="line"><span class="comment">  * @param &#123;string&#125; item 链接list中当前项</span></span><br><span class="line"><span class="comment">  * @param &#123;number&#125; index 链接list中当前索引</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">handleSubRouter(item,index)&#123;</span><br><span class="line">  <span class="comment">// 新路由是旧路由的子级</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.oldURL.length &lt; <span class="keyword">this</span>.currentURLlist.length) &#123;</span><br><span class="line">    <span class="comment">// 相同路由部分不重新加载</span></span><br><span class="line">    <span class="keyword">if</span> (item !== <span class="keyword">this</span>.oldURL[index]) &#123;</span><br><span class="line">      <span class="keyword">this</span>.controller(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新路由是旧路由的父级</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.oldURL.length &gt; <span class="keyword">this</span>.currentURLlist.length) &#123;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">Math</span>.min(<span class="keyword">this</span>.oldURL.length, <span class="keyword">this</span>.currentURLlist.length)</span><br><span class="line">    <span class="comment">// 只重新加载最后一个路由</span></span><br><span class="line">    <span class="keyword">if</span> (index == len - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.controller(<span class="keyword">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样,一个hash路由组件就实现了</p><p>使用时,只需new一个Router实例即可:<code>new Router({mode:&#39;hash&#39;})</code></p><h2 id="history-路由"><a href="#history-路由" class="headerlink" title="history 路由"></a>history 路由</h2><p><code>window.history</code>属性指向 History 对象,是浏览器的一个属性,表示当前窗口的浏览历史,History 对象保存了当前窗口访问过的所有页面地址。更多了解History对象,可参考阮一峰老师的介绍:<a href="https://wangdoc.com/javascript/bom/history.html" target="_blank" rel="noopener"> History 对象</a></p><blockquote><p>webpack开发环境下,需要在devServer对象添加以下配置:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; historyApiFallback: &#123;</span><br><span class="line">&gt;   rewrites: [</span><br><span class="line">&gt;     &#123; <span class="attr">from</span>: <span class="regexp">/.*/</span>, <span class="attr">to</span>: path.posix.join(config.dev.assetsPublicPath, <span class="string">'index.html'</span>) &#125;,</span><br><span class="line">&gt;   ],</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>history路由主要是通过<code>history.pushState()</code>方法向浏览记录中添加一条历史记录,并同时触发js回调加载页面</p><p>当【前进】、【后退】时，会触发<code>history.popstate</code> 事件,加载<code>history.state</code>中存放的路径</p><p>history路由实现与hash路由的步骤类似,由于需要配置路由模式切换,页面中所有的a链接都采用了hash类型链接,history路由初始化时,需要拦截a标签的默认跳转:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * history模式劫持 a链接</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> bindLink() &#123;</span><br><span class="line">   $(<span class="string">'#nav'</span>).on(<span class="string">'click'</span>, <span class="string">'a.nav-item'</span>, <span class="keyword">this</span>.handleLink.bind(<span class="keyword">this</span>))</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * history 处理a链接</span></span><br><span class="line"><span class="comment">  * @param  e 当前对象Event</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> handleLink(e) &#123;</span><br><span class="line">   e.preventDefault();</span><br><span class="line">   <span class="comment">// 获取元素路径属性</span></span><br><span class="line">   <span class="keyword">let</span> href = $(e.target).attr(<span class="string">'href'</span>)</span><br><span class="line">   <span class="comment">// 对非路由链接直接跳转</span></span><br><span class="line">   <span class="keyword">if</span> (href.slice(<span class="number">0</span>, <span class="number">1</span>) !== <span class="string">'#'</span>) &#123;</span><br><span class="line">     <span class="built_in">window</span>.location.href = href</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">let</span> path = href.slice(<span class="number">1</span>)</span><br><span class="line">     history.pushState(&#123;</span><br><span class="line">       path: path</span><br><span class="line">     &#125;, <span class="literal">null</span>, path)</span><br><span class="line">     <span class="comment">// 加载相应页面</span></span><br><span class="line">     <span class="keyword">this</span>.loadView(path.split(<span class="string">'?'</span>)[<span class="number">0</span>])</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>history路由初始化需要绑定<code>load</code>、<code>popstate</code>事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.bindLink()</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="keyword">this</span>.loadView.bind(<span class="keyword">this</span>, location.pathname));</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'popstate'</span>, <span class="keyword">this</span>.historyRefresh.bind(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure><p>浏览是【前进】或【后退】时,触发<code>popstate</code>事件,执行回调函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * history模式刷新页面</span></span><br><span class="line"><span class="comment">  * @param  e  当前对象Event</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">historyRefresh(e) &#123;</span><br><span class="line">  <span class="keyword">const</span> state = e.state || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> path = state.path.split(<span class="string">'?'</span>)[<span class="number">0</span>] || <span class="literal">null</span></span><br><span class="line">  <span class="keyword">if</span> (path) &#123;</span><br><span class="line">    <span class="keyword">this</span>.loadView(path)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>history路由模式首次加载页面时,可以默认一个页面,这时可以用<code>history.replaceState</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.mode === <span class="string">'history'</span> &amp;&amp; currentURL === <span class="string">'/'</span>) &#123;</span><br><span class="line">  history.replaceState(&#123;<span class="attr">path</span>: <span class="string">'/'</span>&#125;, <span class="literal">null</span>, <span class="string">'/'</span>)</span><br><span class="line">  currentURL = <span class="string">'/index'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于404页面的处理,也类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">history.replaceState(&#123;<span class="attr">path</span>: <span class="string">'/error'</span>&#125;, <span class="literal">null</span>, <span class="string">'/error'</span>)</span><br><span class="line"><span class="keyword">this</span>.loadView(<span class="string">'/error'</span>)</span><br></pre></td></tr></table></figure><p><a href="https://www.haohome.top/webpack-spa/" target="_blank" rel="noopener">点击预览</a></p><p>更多源码请访问<a href="https://github.com/yifoo/webpack-demo" target="_blank" rel="noopener">Github</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;单页面应用利用了JavaScript动态变换网页内容,避免了页面重载;路由则提供了浏览器地址变化,网页内容也跟随变化,两者结合起来则为我们提供了体验良好的单页面web应用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前端路由实现方式&quot;&gt;&lt;a href=&quot;#前端路由实现方式&quot; class=&quot;headerlink&quot; title=&quot;前端路由实现方式&quot;&gt;&lt;/a&gt;前端路由实现方式&lt;/h2&gt;&lt;p&gt;路由需要实现三个功能:&lt;/p&gt;
&lt;p&gt;​    ①浏览器地址变化,切换页面;&lt;/p&gt;
&lt;p&gt;​    ②点击浏览器【后退】、【前进】按钮，网页内容跟随变化；&lt;/p&gt;
&lt;p&gt;​    ③刷新浏览器，网页加载当前路由对应内容&lt;/p&gt;
&lt;p&gt;在单页面web网页中,单纯的浏览器地址改变,网页不会重载,如单纯的hash网址改变网页不会变化,因此我们的路由主要是通过监听事件,并利用js实现动态改变网页内容,有两种实现方式:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hash&lt;/code&gt;路由: 监听浏览器地址hash值变化,执行相应的js切换网页&lt;br&gt;&lt;code&gt;history&lt;/code&gt;路由: 利用history API实现url地址改变,网页内容改变&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://blog.haohome.top/tags/jQuery/"/>
    
      <category term="router" scheme="http://blog.haohome.top/tags/router/"/>
    
  </entry>
  
  <entry>
    <title>Vue项目总结</title>
    <link href="http://blog.haohome.top/2018/10/31/Program/Vue%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.haohome.top/2018/10/31/Program/Vue项目总结/</id>
    <published>2018-10-30T16:00:00.000Z</published>
    <updated>2019-01-28T06:37:03.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>最近做了一个内嵌在APP的H5项目,起初是准备自己选择vue框架和UI库搭建项目框架,后来发现已经有项目组采用了一个muse-ui库.为了APP的页面整体统一性,我只好clone了小伙伴的项目,在其基础上继续开发.</p><p>项目开发过程中遇到了不少坑,这个迭代开发结束就来逐步总结下.</p><a id="more"></a><p>闲话不多说,开始正题:</p><h2 id="2-关于muse-ui"><a href="#2-关于muse-ui" class="headerlink" title="2. 关于muse-ui"></a>2. 关于muse-ui</h2><p>这个框架采用material风格,对vue的支持就很友好,图标也是Google官方推荐的<code>Material Icons</code>字体包,用起来也很方便。官方有详细的安装介绍,<code>import</code>后采用<code>Vue.use()</code>即可:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> MuseUI <span class="keyword">from</span> <span class="string">'muse-ui'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'muse-ui/dist/muse-ui.css'</span></span><br><span class="line">Vue.use(MuseUI)</span><br></pre></td></tr></table></figure><p>我们的项目采用的是muse2.1版本,官方现在已经是3.0版本的了,2.1版本的API文档写的不是详细,所以当遇到坑时就头疼了.</p><h2 id="3-基于muse-ui封装表单组件"><a href="#3-基于muse-ui封装表单组件" class="headerlink" title="3. 基于muse-ui封装表单组件"></a>3. 基于muse-ui封装表单组件</h2><p>由于我们项目此次主要是表单,里面有大量的<code>input</code>、<code>textarea</code>、<code>select</code>等表单的应用场景,我们选择了对muse-ui表单组件进行二次封装,以利于ui组件适用于本项目移动端的样式,同时表单组件可随处复用。</p><h4 id="3-1-组件数据双向绑定v-model"><a href="#3-1-组件数据双向绑定v-model" class="headerlink" title="3.1 组件数据双向绑定v-model"></a>3.1 组件数据双向绑定v-model</h4><p>数据双向绑定是vue中比较实用的一个功能,如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'formInput'</span>, &#123;</span><br><span class="line">   data:&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">      val:<span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`&lt;input v-model='val'&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>而在父组件中,如何去实现实时获取子组件<code>formInput</code>的<code>value</code>呢?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'parent'</span>,&#123;</span><br><span class="line">    data:&#123;</span><br><span class="line">        <span class="keyword">return</span>&#123;</span><br><span class="line">        inputVal:<span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    template: <span class="string">`&lt;form-input v-model="inputVal"&gt;&lt;/form-input&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>vue的父子组件传递有一个口诀:<code>props down,events up</code>即父组件通过<code>props</code>向子组件传值,子组件通过<code>evens</code>向父组件传值,另外在官方文档中有这样的介绍:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;searchText&quot;&gt;</span><br><span class="line">&lt;!-- 等价于 --&gt;</span><br><span class="line">&lt;input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event.target.value&quot;&gt;</span><br></pre></td></tr></table></figure><p>当用在组件上时:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;custom-input</span><br><span class="line">  v-bind:value=&quot;searchText&quot;</span><br><span class="line">  v-on:input=&quot;searchText = $event&quot;&gt;</span><br><span class="line">&lt;/custom-input&gt;</span><br><span class="line">即</span><br><span class="line">&lt;custom-input v-model=&quot;searchText&quot;&gt;&lt;/custom-input&gt;</span><br></pre></td></tr></table></figure><p>为了能正常传值,组件内的 <code>&lt;input&gt;</code> 必须：</p><ul><li>将其 <code>value</code> 特性绑定到一个名叫 <code>value</code> 的 prop 上</li><li>在其 <code>input</code> 事件被触发时，将新的值通过自定义的 <code>input</code> 事件抛出</li></ul><p>这段相当于让自定义组件通过<code>input</code>事件触发父组件的自定义事件,并传值给父组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'custom-input'</span>, &#123;</span><br><span class="line">  props: [<span class="string">'value'</span>],</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      v-bind:value="value"</span></span><br><span class="line"><span class="string">      v-on:input="$emit('input', $event.target.value)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就能达到我们想要的目的了.</p><p>在单选框和复选框这类可能会将<code>value</code>用作不同的特性,vue提供了另一种方式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'base-checkbox'</span>, &#123;</span><br><span class="line">  model: &#123;</span><br><span class="line">    prop: <span class="string">'checked'</span>,</span><br><span class="line">    event: <span class="string">'change'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  props: &#123;</span><br><span class="line">    checked: <span class="built_in">Boolean</span></span><br><span class="line">  &#125;,</span><br><span class="line">  template: <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;input</span></span><br><span class="line"><span class="string">      type="checkbox"</span></span><br><span class="line"><span class="string">      v-bind:checked="checked"</span></span><br><span class="line"><span class="string">      v-on:change="$emit('change', $event.target.checked)"</span></span><br><span class="line"><span class="string">    &gt;</span></span><br><span class="line"><span class="string">  `</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 组件上</span></span><br><span class="line">&lt;base-checkbox v-model=<span class="string">"lovingVue"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">base-checkbox</span>&gt;</span></span></span><br><span class="line"><span class="xml">// lovingVue 的值将会传入这个名为 checked 的 prop</span></span><br><span class="line"><span class="xml">// ! 需要在组件的 props 选项里声明 checked 这个 prop。</span></span><br></pre></td></tr></table></figure><h4 id="3-2-列表遍历v-for删除指定元素"><a href="#3-2-列表遍历v-for删除指定元素" class="headerlink" title="3.2 列表遍历v-for删除指定元素"></a>3.2 列表遍历v-for删除指定元素</h4><p>有时数组列表渲染我们比较喜欢采用数组本身的下标索引作为v-for绑定的key值如:</p><iframe width="100%" height="300" src="//jsrun.net/jqXKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>在做图片上传的时候,需要添加上传进度和删除图片,彼此间互不干扰,这就需要每个组件都需要具备独立的功能:</p><blockquote><ul><li>图片预览</li><li>图片自动压缩</li><li>图片上传</li><li>上传进度动态展示</li><li>删除图片</li><li>上传失败错误图标</li><li>点击错误图标重传</li></ul></blockquote><p>我写了两个组件,一个是图片<code>single</code>组件,一个是图片<code>list</code>组件,在实际运行的时候发现,删除某一张图片会自动删除最后一张图片,通过<code>console.log</code>控制台打印索引<code>index</code>,删除的索引是正确的,百思不得其解!最后百度才发现问题出在了循环<code>v-for</code>的<code>:key</code>上了</p><p>为方便理解,先举个例子:</p><iframe width="100%" height="300" src="//jsrun.net/z8hKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p><code>single</code>图片组件具备了上述功能,选择一个图片后在<code>list</code>组件及时<code>push</code>一个图片的对象<code>this.arr.push(item)</code>,这样页面就能通过<code>v-for</code>动态渲染,但使用后发现直接删除<code>arr</code>某个元素就只会删除集合最后一个元素.</p><p>这是由于列表的生成是通过绑定的arr数组来生成的，当arr删除掉一项时，列表的dom对象自然也会减少一项。但是由于v-for循环的是子组件，子组件内部显示数据并未绑定arr数组里的属性，因此子组件的显示数据并未按新数组重新渲染，体现出来的结果就是最后一个元素被删掉了</p><p>针对<code>arr</code>添加唯一性的索引就能解决这个问题,<code>this.arr.push({ id: this.id, data: item });</code>,将<code>:key</code>绑定到<code>id</code></p><blockquote><p>由于v-for循环的是子组件，子组件内部显示数据并未绑定fileList数组里的属性,子组件的显示数据并未按新数组重新渲染,<strong>体现出来的结果</strong>就是最后一个元素被删掉了。</p></blockquote><h2 id="4-移动端拍照图片压缩上传"><a href="#4-移动端拍照图片压缩上传" class="headerlink" title="4. 移动端拍照图片压缩上传"></a>4. 移动端拍照图片压缩上传</h2><p>移动端图片上传存在两个问题:</p><ol><li><p>图片压缩</p><p>当前手机拍出来的照片像素高、尺寸大，而且使用 base64 编码的照片会比原照片大，用 canvas 来渲染这照片的速度会相对比较慢，那么上传的时候进行压缩就非常有必要的</p><p>图片压缩可以有两个阶段可以控制：</p><ul><li>控制<code>canvas</code>画布大小</li><li><code>canvas</code>转<code>blob</code>对象或<code>base64</code>,控制质量比例</li></ul><p><strong>Tips:</strong></p><p>1.1 <code>canvas</code>转<code>blob</code>对象:<code>canvas.toBlob(callback, type, radio)</code></p><blockquote><p> callback: 回调函数，可获得一个单独的<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Blob" target="_blank" rel="noopener"><code>Blob</code></a>对象参数<br> type: 指定图片格式，默认格式为<code>image/png</code><br> radio: 当请求图片格式为<code>image/jpeg</code>或者<code>image/webp</code>时用来指定图片展示质量</p></blockquote><p>Blob 对象相当于一个容器，可以用于存放二进制数据。它有两个属性，size 属性表示字节长度，type 属性表示 MIME 类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">canvas.toBlob(<span class="function"><span class="keyword">function</span>(<span class="params">blob</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> url = URL.createObjectURL(blob);</span><br><span class="line">  <span class="keyword">var</span> newImg = <span class="keyword">new</span> Image();</span><br><span class="line">  newImg.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    URL.revokeObjectURL(url)<span class="comment">// URL.revokeObjectURL():释放一个之前通过调用 URL.createObjectURL() 创建的已经存在的 URL 对象。当你结束使用某个 URL 对象时，应该通过调用这个方法来让浏览器知道不再需要保持这个文件的引用,避免消耗资源</span></span><br><span class="line">  &#125;;</span><br><span class="line">  newImg.src=url;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//生成JPEG格式的图片</span></span><br><span class="line">canvas.toBlob(<span class="function"><span class="keyword">function</span>(<span class="params">blob</span>)</span>&#123;...&#125;, <span class="string">"image/jpeg"</span>, <span class="number">0.95</span>); <span class="comment">// JPEG at 95% quality</span></span><br></pre></td></tr></table></figure><p><code>canvas.toBlob</code>方法在低版本的<code>ios</code>存在兼容性问题,需要添加一下代码实现兼容:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!HTMLCanvasElement.prototype.toBlob) &#123;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(HTMLCanvasElement.prototype, <span class="string">'toBlob'</span>, &#123;</span><br><span class="line"> value: <span class="function"><span class="keyword">function</span> (<span class="params">callback, type, quality</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> binStr = atob( <span class="keyword">this</span>.toDataURL(type, quality).split(<span class="string">','</span>)[<span class="number">1</span>] ),</span><br><span class="line">len = binStr.length,</span><br><span class="line">arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(len);</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;len; i++ ) &#123;</span><br><span class="line">   arr[i] = binStr.charCodeAt(i);</span><br><span class="line"> &#125;</span><br><span class="line">  callback( <span class="keyword">new</span> Blob( [arr], &#123;<span class="attr">type</span>: type || <span class="string">'image/png'</span>&#125; ) );</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.2 <code>canvas</code>转<code>base64</code>:直接调用方法<code>canvas.toDataURL(type, radio)</code></p><blockquote><p>type: 图片格式，默认为 <code>image/png</code></p><p>radio: 当请求图片格式为<code>image/jpeg</code>或者<code>image/webp</code>时用来指定图片展示质量</p><p>与转blob对象不同的是,<code>canvas.toDataURL</code>直接返回base64 的图片</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newImg = <span class="keyword">new</span> Image();</span><br><span class="line">newImg.src=canvas.toDataURL(<span class="string">"image/png"</span>,<span class="number">0.8</span>);</span><br></pre></td></tr></table></figure></li><li><p>上传进度展示</p><p>文件上传需要用到<code>XMLHttpRequest:progress</code>方法,在<code>axios</code>的api中提供了现成的<code>onUploadProgress</code>方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.$axios(&#123;</span><br><span class="line">  url:<span class="string">'/upload'</span></span><br><span class="line">  method: <span class="string">"post"</span>,</span><br><span class="line">  data: data,</span><br><span class="line">  onUploadProgress: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (event.lengthComputable) &#123;</span><br><span class="line">      self.radio = (event.loaded / event.total) * <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当上传存在跨域的时候,浏览器在跨域请求前会默认发个<code>options</code>请求来验证是否跨域,这是后端服务器需要处理<code>options</code>请求</p><blockquote><p><code>OPTIONS</code> 方法用来查询针对请求 URI 指定的资源支持的方法。</p></blockquote><p><img src="https://haohome.top/18-11-8/51395595.jpg" width="50%"></p><p>| 请求 | OPTIONS*HTTP/1.1      |<br>| —- | ————————————————- |<br>|    Host|www.zhongguo.com/upload                                                        |<br>| 响应 | HTTP/1.1 200 OK                                   |<br>| Allow | GET, POST, HEAD, OPTIONS(返回服务器支持的方法) |</p><p>如果后端未对<code>OPTIONS</code>请求做处理,前端文件<code>post</code>上传文件会失败的</p><p><strong>当后端对<code>OPTIONS</code>请求做出响应200时,前端才会继续发送<code>post</code>请求</strong>,这就是我们在调试时看到文件上传时会默认发<code>OPTIONS</code>和<code>post</code>两个请求的原因</p></li><li><p>拍照图片旋转</p><p>在手机上通过H5网页<code>input</code>标签拍照上传图片，有一些手机会出现图片旋转了90°的问题,这些手机竖着拍的时候才会出现这种问题，横拍出来的照片就正常显示。因此，可以通过获取手机拍照角度来对照片进行旋转，从而解决这个问题。</p><p><code>Orientation</code>:通过这个参数可以识别图片的拍摄角度,手机拍出来的图片会带有这个参数</p><p>| 旋转角度  | 参数值 |<br>| :——-: | :—-: |<br>|    0°     |   1    |<br>| 顺时针90° |   6    |<br>| 逆时针90° |   8    |<br>|   180°    |   3    |</p><p>想要获取 <code>Orientation</code> 参数，可以通过 <code>exif.js</code> 库来操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue项目可直接安装</span></span><br><span class="line">npm i exif-js -D</span><br><span class="line"><span class="comment">//在图片组件中直接引入</span></span><br><span class="line"><span class="keyword">import</span> Exif <span class="keyword">from</span> <span class="string">'exif-js'</span></span><br><span class="line">Exif.getData(file, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> Orientation = Exif.getTag(<span class="keyword">this</span>, <span class="string">'Orientation'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在对图片进行<code>canvas</code>绘图时,就可以针对<code>Orientation</code>参数做判断处理:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Orientation &amp;&amp; Orientation != <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (Orientation) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>:     <span class="comment">// 旋转90度</span></span><br><span class="line">      canvas.width = imgHeight;</span><br><span class="line">      canvas.height = imgWidth;</span><br><span class="line">      ctx.rotate(<span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line">      <span class="comment">// (0,-imgHeight) 从旋转原理图那里获得的起始点</span></span><br><span class="line">      ctx.drawImage(img, <span class="number">0</span>, -imgHeight, imgWidth, imgHeight);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:     <span class="comment">// 旋转180度</span></span><br><span class="line">      ctx.rotate(<span class="built_in">Math</span>.PI);</span><br><span class="line">      ctx.drawImage(img, -imgWidth, -imgHeight, imgWidth, imgHeight);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:     <span class="comment">// 旋转-90度</span></span><br><span class="line">      canvas.width = imgHeight;</span><br><span class="line">      canvas.height = imgWidth;</span><br><span class="line">      ctx.rotate(<span class="number">3</span> * <span class="built_in">Math</span>.PI / <span class="number">2</span>);</span><br><span class="line">      ctx.drawImage(img, -imgWidth, <span class="number">0</span>, imgWidth, imgHeight);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  canvas.width = imgWidth;</span><br><span class="line">  canvas.height = imgHeight;</span><br><span class="line">  ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, imgWidth, imgHeight)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo: <a href="./图片上传与压缩.md">图片上传与压缩</a></p></li></ol><h2 id="5-webkit-overflow-scrolling的坑"><a href="#5-webkit-overflow-scrolling的坑" class="headerlink" title="5. -webkit-overflow-scrolling的坑"></a>5. -webkit-overflow-scrolling的坑</h2><p>项目中有一个获取数据后纯展示的页面,在ios平台上滑动不流畅,经过查询才了解到在ios的safari浏览器和app内核浏览器中，当一个h5页面内容超出屏幕高度，我们手指去滑动屏幕的时候，只要手势一离开屏幕，滚动立刻结束,按照教程我按下面设置了:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">   <span class="attribute">-webkit-overflow-scrolling</span>: touch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果在app中出现了fixed 定位元素失效</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;最近做了一个内嵌在APP的H5项目,起初是准备自己选择vue框架和UI库搭建项目框架,后来发现已经有项目组采用了一个muse-ui库.为了APP的页面整体统一性,我只好clone了小伙伴的项目,在其基础上继续开发.&lt;/p&gt;
&lt;p&gt;项目开发过程中遇到了不少坑,这个迭代开发结束就来逐步总结下.&lt;/p&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://blog.haohome.top/categories/Framework/"/>
    
    
      <category term="JS" scheme="http://blog.haohome.top/tags/JS/"/>
    
      <category term="vue" scheme="http://blog.haohome.top/tags/vue/"/>
    
      <category term="项目总结" scheme="http://blog.haohome.top/tags/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>跨域问题解决方案汇总</title>
    <link href="http://blog.haohome.top/2018/10/22/Interview/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B1%87%E6%80%BB/"/>
    <id>http://blog.haohome.top/2018/10/22/Interview/跨域问题解决方案汇总/</id>
    <published>2018-10-21T16:00:00.000Z</published>
    <updated>2018-10-22T01:17:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。但是有时候跨域请求资源是合理的需求，本文尝试从多篇文章中汇总至今存在的所有跨域请求解决方案。</p><h2 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h2><p>首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。而有关跨域请求受到限制的原因可以参考如下 MDN 文档片段：</p><blockquote><p>跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。</p></blockquote><a id="more"></a><h2 id="解决方法汇总"><a href="#解决方法汇总" class="headerlink" title="解决方法汇总"></a>解决方法汇总</h2><p>以下我们由简及深介绍各种存在的跨域请求解决方案，包括 <code>document.domain, location.hash, window.name, window.postMessage, JSONP, WebSocket, CORS</code>。</p><h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p><code>document.domain</code> 的作用是用来获取/设置当前文档的原始域部分，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于文档 www.example.xxx/good.html</span></span><br><span class="line"><span class="built_in">document</span>.domain=<span class="string">"www.example.xxx"</span></span><br><span class="line"><span class="comment">// 对于URI http://developer.mozilla.org/en/docs/DOM </span></span><br><span class="line"><span class="built_in">document</span>.domain=<span class="string">"developer.mozilla.org"</span></span><br></pre></td></tr></table></figure><blockquote><p>如果当前文档的域无法识别，那么 domain 属性会返回 null。</p><p>在根域范围内，Mozilla允许你把domain属性的值设置为它的上一级域。例如，在 developer.mozilla.org 域内，可以把domain设置为 “mozilla.org” 但不能设置为 “mozilla.com” 或者”org”。</p></blockquote><p>因此，若两个源所用协议、端口一致，主域相同而二级域名不同的话，可以借鉴该方法解决跨域请求。</p><p>比如若我们在 <a href="http://a.github.io" target="_blank" rel="noopener">http://a.github.io</a> 页面执行以下语句：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain = <span class="string">"github.io"</span></span><br></pre></td></tr></table></figure><p>那么之后页面对 <code>github.io</code> 发起请求时页面则会成功通过对 <code>github.io</code> 的同源检测。比较直接的一个操作是，当我们在 <code>a.github.io</code> 页面中利用 iframe 去加载 <code>github.io</code> 时，通过如上的赋值后，我们可以在 <code>a.github.io</code> 页面中去操作 iframe 里的内容。</p><p>我们同时考虑另一种情况：存在两个子域名 <code>a.github.io</code> 以及 <code>b.github.io</code>， 其中前者域名下网页 a.html 通过 iframe 引入了后者域名下的 b.html，此时在 a.html 中是无法直接操作 b.html 的内容的。</p><p>同样利用 <code>document.domain</code>，我们在两个页面中均加入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.domain=<span class="string">'github.io'</span></span><br></pre></td></tr></table></figure><p>这样在以上的 a.html 中就可以操作通过 iframe 引入的 b.html 了。</p><p><strong>document.domain</strong> 的优点在于解决了主语相同的跨域请求，但是其缺点也是很明显的：比如一个站点受到攻击后，另一个站点会因此引起安全漏洞；若一个页面中引入多个 iframe，想要操作所有的 iframe 则需要设置相同的 domain。</p><h3 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h3><p><code>location.hash</code> 是一个可读可写的字符串，该字符串是 URL 的锚部分（从 # 号开始的部分）。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于页面 http://example.com:1234/test.htm#part2</span></span><br><span class="line">location.hash = <span class="string">"#part2"</span></span><br></pre></td></tr></table></figure><p>同时，由于我们知道改变 hash 并不会导致页面刷新，所以可以利用 hash 在不同源间传递数据。</p><p>假设 <code>github.io</code> 域名下 a.html 和 <code>shaonian.eu</code> 域名下 b.html 存在跨域请求，那么利用 location.hash 的一个解决方案如下：</p><ul><li><p>a.html 页面中创建一个隐藏的 iframe， src 指向 b.html，其中 src 中可以通过 hash 传入参数给 b.html</p></li><li><p>b.html 页面在处理完传入的 hash 后通过修改 a.html 的 hash 值达到将数据传送给 a.html 的目的</p></li><li><p>a.html 页面添加一个定时器，每隔一定时间判断自身的 location.hash 是否变化，以此响应处理</p></li></ul><p>以上步骤中需要注意第二点：如何在 iframe 页面中修改 父亲页面的 hash 值。由于在 IE 和 Chrome 下，两个不同域的页面是不允许 <code>parent.location.hash</code> 这样赋值的，所以对于这种情况，我们需要在父亲页面域名下添加另一个页面来实现跨域请求，具体如下：</p><ul><li><p>假设 a.html 中 iframe 引入了 b.html, 数据需要在这两个页面之间传递，且 c.html 是一个与 a.html 同源的页面</p></li><li><p>a.html 通过 iframe 将数据通过 hash 传给 b.html</p></li><li><p>b.html 通过 iframe 将数据通过 hash 传给 c.html</p></li><li><p>c.html 通过 <code>parent.parent.location.hash</code> 设置 a.html 的 hash 达到传递数据的目的</p></li></ul><p><strong>location.bash</strong> 方法的优点在于可以解决域名完全不同的跨域请求，并且可以实现双向通讯；而缺点则包括以下几点：</p><ul><li><p>利用这种方法传递的数据量受到 url 大小的限制，传递数据类型有限</p></li><li><p>由于数据直接暴露在 url 中则存在安全问题</p></li><li><p>若浏览器不支持 <code>onhashchange</code> 事件，则需要通过轮训来获知 url 的变化</p></li><li><p>有些浏览器会在 hash 变化时产生历史记录，因此可能影响用户体验</p></li></ul><h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><p>该属性用于获取/设置窗口的名称。其特征在于：一个窗口的生命周期内，窗口载入的所有页面共享该值，且都具有对该属性的读写权限。这意味着如果不修改该值，那么在不同页面加载之后该值也不会变，且其支持长达 2MB 的存储量。</p><p>利用该特性我们可以将跨域请求用如下步骤解决：</p><ul><li><p>在 a.github.io/a.html 中创建 iframe 指向 b.github.io/b.html (页面会将自身的 window.name 附在 iframe 上)</p></li><li><p>给 a.github.io/a.html 添加监听 iframe 的 onload 事件，在该事件中将 iframe 的 src 设置为本地域的代理文件（代理文件和a.html处于同一域下，可以相互通信），同时可以传出 iframe 的 name 值</p></li><li><p>获取数据后销毁 iframe，释放内存，同时也保证了安全</p></li></ul><p><strong>window.name</strong> 的优势在于巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p><h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p>HTML5 为了解决这个问题，引入了一个全新的 API：跨文档通信 API（Cross-document messaging）。这个 API 为 window 对象新增了一个 window.postMessage 方法，允许跨窗口通信，不论这两个窗口是否同源。</p><p>API 的详细使用方法请见 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage" target="_blank" rel="noopener">MDN</a>。</p><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>JSONP, 全称 JSON with Padding，是使用 AJAX 实现的请求不同源的跨域。其基本原理：网页通过添加一个 <code>&lt;script&gt;</code> 元素，向服务器请求 JSON 数据，这种做法不受同源政策限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</p><p>以下为一个例子，由于 test.js 返回的内容直接作为代码运行，所以只要 a.html 中定义了 <code>callback</code> 函数, 它就会立即被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前页面 a.com/a.html</span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"><span class="comment">//回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    alert(data.message);</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">" src="</span>http:<span class="comment">//b.com/test.js"&gt;&lt;/script&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test.js</span></span><br><span class="line"><span class="comment">// 调用callback函数，并以json数据形式作为阐述传递，完成回调</span></span><br><span class="line">callback(&#123;<span class="attr">message</span>:<span class="string">"success"</span>&#125;);</span><br></pre></td></tr></table></figure><p>为了保证 script 的灵活，我们可以通过 JavaScript 动态创建 script 标签，并通过 HTTP 参数向服务器传入回调函数名，案例如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    <span class="comment">// 添加&lt;script&gt;标签的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addScriptTag</span>(<span class="params">src</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">        script.setAttribute(<span class="string">"type"</span>,<span class="string">"text/javascript"</span>);</span><br><span class="line">        script.src = src;</span><br><span class="line">        <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 搜索apple，将自定义的回调函数名result传入callback参数中</span></span><br><span class="line">        addScriptTag(<span class="string">"http://ajax.googleapis.com/ajax/services/search/web?v=1.0&amp;q=apple&amp;callback=result"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义的回调函数result</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">result</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 我们就简单的获取apple搜索结果的第一条记录中url数据</span></span><br><span class="line">        alert(data.responseData.results[<span class="number">0</span>].unescapedUrl);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure><p>jQuery 有相应的 JSONP 的实现方法，见 <a href="http://api.jquery.com/jquery.getjson/" target="_blank" rel="noopener">API</a>。</p><p><strong>JSONP</strong>的优点在于简单适用，老式浏览器全部支持，服务器改造小。不需要XMLHttpRequest或ActiveX的支持；但缺点是只支持 GET 请求。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>WebSocket 协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><blockquote><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。</p></blockquote><p>跨域资源共享（ CORS ）机制允许 Web 应用服务器进行跨域访问控制，从而使跨域数据传输得以安全进行。其需要服务端和客户端同时支持。</p><blockquote><p>跨域资源共享标准（ cross-origin sharing standard ）允许在下列场景中使用跨域 HTTP 请求：</p><p>由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求</p><p>Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用</p><p>WebGL 贴图</p><p>使用 drawImage 将 Images/video 画面绘制到 canvas</p><p>样式表（使用 CSSOM）</p><p>Scripts (未处理的异常)</p></blockquote><p>CORS 存在以下三种主要场景，分别是<strong>简单请求，预检请求和附带身份凭证的请求</strong>。</p><ul><li><strong>简单请求</strong>：若只使用 GET, HEAD 或者 POST 请求，且除 CORS 安全的首部字段集合外，无人为设置该集合之外的其他首部字段，同时 Content-Type 值属于下列之一，那么该请求则可以被视为简单请求：</li></ul><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">application/x-www-<span class="keyword">form</span>-urlencoded</span><br><span class="line">multipart/<span class="keyword">form</span>-<span class="keyword">data</span></span><br><span class="line">text/plain</span><br></pre></td></tr></table></figure><p>此情况下，若服务端返回的 <code>Access-Control-Allow-Origin: *</code> ，则表明该资源可以被任意外域访问。若要指定仅允许来自某些域的访问，需要将 <code>*</code> 设定为该域，例如：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-<span class="string">Origin:</span> <span class="string">http:</span><span class="comment">//foo.example</span></span><br></pre></td></tr></table></figure><ul><li><strong>预检请求</strong>：与前述简单请求不同，该要求必须首先使用 OPTIONS   方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。当请求满足以下三个条件任意之一时，<br>即应首先发送预检请求：</li></ul><ol><li>使用了 PUT, DELETE, CONNECT, OPTIONS, TRACE, PATCH 中任一的 HTTP 方法</li><li>人为设置了对 CORS 安全的首部字段集合之外的其他首部字段</li><li>Content-Type 的值不属于下列之一</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">application/x-www-form-urlencoded</span><br><span class="line">multipart/form-data</span><br><span class="line">text/plain</span><br></pre></td></tr></table></figure><p>预检请求完成之后（通过 OPTIONS 方法实现），才发送实际请求。一个示范 HTTP 请求如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://bar.other/resources/post-here/'</span>;</span><br><span class="line"><span class="keyword">var</span> body = <span class="string">'&lt;?xml version="1.0"?&gt;&lt;person&gt;&lt;name&gt;Arun&lt;/name&gt;&lt;/person&gt;'</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(invocation)</span><br><span class="line">    &#123;</span><br><span class="line">      invocation.open(<span class="string">'POST'</span>, url, <span class="literal">true</span>);</span><br><span class="line">      invocation.setRequestHeader(<span class="string">'X-PINGOTHER'</span>, <span class="string">'pingpong'</span>);</span><br><span class="line">      invocation.setRequestHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/xml'</span>);</span><br><span class="line">      invocation.onreadystatechange = handler;</span><br><span class="line">      invocation.send(body); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>附带身份凭证的请求</strong>：这种方式的特点在于能够在跨域请求时向服务器发送凭证请求，例如 Cookies (withCredentials 标志设置为 true)。</li></ul><p>一般而言，对于跨域 XMLHttpRequest 或 Fetch 请求，浏览器不会发送身份凭证信息。如果要发送凭证信息，需要设置 XMLHttpRequest 的某个特殊标志位。但是需要注意的是，如果服务器端的响应中未携带 <code>Access-Control-Allow-Credentials: true</code>，浏览器将不会把响应内容返回给请求的发送者。</p><blockquote><p>附带身份凭证的请求与通配符</p><p>对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为“*”。</p><p>这是因为请求的首部中携带了 Cookie 信息，如果 Access-Control-Allow-Origin 的值为“*”，请求将会失败。而将 Access-Control-Allow-Origin 的值设置为 <a href="http://foo.example，则请求将成功执行。" target="_blank" rel="noopener">http://foo.example，则请求将成功执行。</a></p><p>另外，响应首部中也携带了 Set-Cookie 字段，尝试对 Cookie 进行修改。如果操作失败，将会抛出异常。</p></blockquote><p>MDN 引例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> invocation = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">'http://bar.other/resources/credentialed-content/'</span>;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callOtherDomain</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(invocation) &#123;</span><br><span class="line">    invocation.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</span><br><span class="line">    invocation.withCredentials = <span class="literal">true</span>;</span><br><span class="line">    invocation.onreadystatechange = handler;</span><br><span class="line">    invocation.send(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实由上我们知道，<strong>CORS</strong> 的优点也非常明显：CORS支持所有类型的HTTP请求，是跨域HTTP请求的根本解决方案。</p><p>以上就是所有的跨域请求解决方案，根据实际生产环境，总有一款适合你。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://github.com/wengjq/Blog/issues/2" target="_blank" rel="noopener">https://github.com/wengjq/Blog/issues/2</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS</a></li><li><p><a href="http://www.cnblogs.com/zichi/p/4620656.html" target="_blank" rel="noopener">http://www.cnblogs.com/zichi/p/4620656.html</a></p><h2 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h2></li><li><p><a href="https://sites.google.com/site/amitsciscozone/home/security/ssl-connection-setup" target="_blank" rel="noopener">https://sites.google.com/site/amitsciscozone/home/security/ssl-connection-setup</a></p></li><li><a href="http://robertheaton.com/2014/03/27/how-does-https-actually-work/" target="_blank" rel="noopener">http://robertheaton.com/2014/03/27/how-does-https-actually-work/</a></li><li><a href="http://www.cnblogs.com/lixiansen/p/5618541.html" target="_blank" rel="noopener">http://www.cnblogs.com/lixiansen/p/5618541.html</a></li><li><a href="http://harttle.com/2016/01/22/doctype.html" target="_blank" rel="noopener">http://harttle.com/2016/01/22/doctype.html</a></li><li><a href="http://jerryzou.com/posts/cookie-and-web-storage/" target="_blank" rel="noopener">http://jerryzou.com/posts/cookie-and-web-storage/</a></li><li><a href="https://www.zhihu.com/question/20653055/answer/17786008" target="_blank" rel="noopener">https://www.zhihu.com/question/20653055/answer/17786008</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes</a></li><li><a href="http://blog.csdn.net/NJUPT_T/article/details/50700209" target="_blank" rel="noopener">http://blog.csdn.net/NJUPT_T/article/details/50700209</a></li><li><a href="http://web.jobbole.com/84826/" target="_blank" rel="noopener">http://web.jobbole.com/84826/</a></li><li><a href="http://web.jobbole.com/85340/" target="_blank" rel="noopener">http://web.jobbole.com/85340/</a></li></ul><p>文章参考了以上资源，同时参照 <a href="https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers" target="_blank" rel="noopener">https://github.com/markyun/My-blog/tree/master/Front-end-Developer-Questions/Questions-and-Answers</a> 的部分问题列表重新归纳了详细问题答案。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;同源策略限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。但是有时候跨域请求资源是合理的需求，本文尝试从多篇文章中汇总至今存在的所有跨域请求解决方案。&lt;/p&gt;
&lt;h2 id=&quot;跨域请求&quot;&gt;&lt;a href=&quot;#跨域请求&quot; class=&quot;headerlink&quot; title=&quot;跨域请求&quot;&gt;&lt;/a&gt;跨域请求&lt;/h2&gt;&lt;p&gt;首先需要了解的是同源和跨源的概念。对于相同源，其定义为：如果协议、端口（如果指定了一个）和主机对于两个页面是相同的，则两个页面具有相同的源。只要三者之一任意一点有不同，那么就为不同源。当一个资源从与该资源本身所在的服务器的域或端口不同的域或不同的端口请求一个资源时，资源会发起一个跨域 HTTP 请求。而有关跨域请求受到限制的原因可以参考如下 MDN 文档片段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;跨域不一定是浏览器限制了发起跨站请求，而也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器无论是否跨域！注意：有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如  Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Interview" scheme="http://blog.haohome.top/categories/Interview/"/>
    
    
      <category term="JS" scheme="http://blog.haohome.top/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JavaScript之this</title>
    <link href="http://blog.haohome.top/2018/10/21/JavaScript/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B9%8Bthis/"/>
    <id>http://blog.haohome.top/2018/10/21/JavaScript/你不知道的JavaScript之this/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-10-21T15:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识this"><a href="#初识this" class="headerlink" title="初识this"></a>初识this</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello, I'm "</span> + identify.call( <span class="keyword">this</span> );</span><br><span class="line"><span class="built_in">console</span>.log( greeting );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> me = &#123;</span><br><span class="line">name: <span class="string">"Kyle"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> you = &#123;</span><br><span class="line">name: <span class="string">"Reader"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">identify.call( me ); <span class="comment">// KYLE</span></span><br><span class="line">identify.call( you ); <span class="comment">// READER</span></span><br><span class="line"></span><br><span class="line">speak.call( me ); <span class="comment">// Hello, I'm KYLE</span></span><br><span class="line">speak.call( you ); <span class="comment">// Hello, I'm READER</span></span><br></pre></td></tr></table></figure><p>这个代码片段允许 <code>identify()</code> 和 <code>speak()</code> 函数对多个 <em>环境</em> 对象（<code>me</code> 和 <code>you</code>）进行复用，而不是针对每个对象定义函数的分离版本。</p><a id="more"></a><p>如果不用this,也可以明确的将环境对象传递给 <code>identify()</code> 和 <code>speak()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identify</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> context.name.toUpperCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">speak</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> greeting = <span class="string">"Hello, I'm "</span> + identify( context );</span><br><span class="line"><span class="built_in">console</span>.log( greeting );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identify( you ); <span class="comment">// READER</span></span><br><span class="line">speak( me ); <span class="comment">// Hello, I'm KYLE</span></span><br></pre></td></tr></table></figure><p><code>this</code> 机制提供了更优雅的方式来隐含地“传递”一个对象引用，导致更加干净的API设计和更容易的复用。</p><p>将执行环境作为一个明确参数传递，通常比传递 <code>this</code> 执行环境要乱。</p><blockquote><p><strong>this可以自动引用执行环境对象</strong></p></blockquote><p>看下面这段代码,追踪foo被调用了几次:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );<span class="comment">// 追踪 `foo` 被调用了多少次</span></span><br><span class="line"><span class="keyword">this</span>.count++;</span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">foo( i );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `foo` 被调用了多少次？</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 0 -- 这他妈怎么回事……？</span></span><br></pre></td></tr></table></figure><p><code>foo.count</code> <em>依然</em> 是 <code>0</code>, 即便四个 <code>console.log</code> 语句明明告诉我们 <code>foo(..)</code> 实际上被调用了四次。源于对于 <code>this</code>（在 <code>this.count++</code> 中）的含义进行了 <em>过于字面化</em> 的解释。</p><p>当代码执行 <code>foo.count = 0</code> 时，它确实向函数对象 <code>foo</code> 添加了一个 <code>count</code> 属性。但是对于函数内部的 <code>this.count</code> 引用，<code>this</code> 其实 <em>根本就不</em> 指向那个函数对象，即便属性名称一样，但根对象也不同，因而产生了混淆。</p><p>创建另一个对象来持有 <code>count</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line"><span class="comment">// 追踪 `foo` 被调用了多少次</span></span><br><span class="line">data.count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">count: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">foo( i );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `foo` 被调用了多少次？</span></span><br><span class="line"><span class="built_in">console</span>.log( data.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>看到这里,你应该知道this的指向，this指向了window，这涉及到了<strong>词法作用域</strong></p><p>为了从函数对象内部引用它自己，一般来说通过 this 是不够的。你通常需要通过一个指向它的词法标识符（变量）得到函数对象的引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">foo.count = <span class="number">4</span>; <span class="comment">// `foo` 引用它自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout( <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">// 匿名函数（没有名字）不能引用它自己</span></span><br><span class="line">&#125;, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line">第一个函数，称为“命名函数”，foo 是一个引用，可以用于在它内部引用自己。</span><br><span class="line">而在第二个例子中,传递给 setTimeout(..) 的回调函数没有名称标识符（所以被称为“匿名函数”），所以没有合适的办法引用函数对象自己。</span><br></pre></td></tr></table></figure><ul><li>通过命名函数调用自己,每个地方都是用<code>foo</code> 标识符作为对函数的引用(完全依靠foo的词法作用域):</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line">foo.count++;<span class="comment">// 追踪 `foo` 被调用了多少次</span></span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">foo( i );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><ul><li>利用call强迫this指向foo</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="string">"foo: "</span> + num );</span><br><span class="line"><span class="comment">// 注意：由于 `foo` 的被调用方式（见下方），`this` 现在确实是 `foo`</span></span><br><span class="line"><span class="keyword">this</span>.count++; <span class="comment">// 追踪 `foo` 被调用了多少次</span></span><br><span class="line">&#125;</span><br><span class="line">foo.count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">5</span>) &#123;</span><br><span class="line">foo.call( foo, i );<span class="comment">// 使用 `call(..)`，我们可以保证 `this` 指向函数对象(`foo`)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo: 6</span></span><br><span class="line"><span class="comment">// foo: 7</span></span><br><span class="line"><span class="comment">// foo: 8</span></span><br><span class="line"><span class="comment">// foo: 9</span></span><br><span class="line"><span class="built_in">console</span>.log( foo.count ); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><h2 id="解惑this"><a href="#解惑this" class="headerlink" title="解惑this"></a>解惑this</h2><h3 id="调用点（Call-site）"><a href="#调用点（Call-site）" class="headerlink" title="调用点（Call-site）"></a>调用点（Call-site）</h3><p>函数在代码中被调用的位置（<strong>不是被声明的位置</strong>）</p><p> <strong>调用栈（call-stack）</strong>: 使我们到达当前执行位置而被调用的所有方法的堆栈</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈是: `baz`</span></span><br><span class="line">    <span class="comment">// 我们的调用点是 global scope（全局作用域）</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"baz"</span> );</span><br><span class="line">    bar(); <span class="comment">// &lt;-- `bar` 的调用点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈是: `baz` -&gt; `bar`</span></span><br><span class="line">    <span class="comment">// 我们的调用点位于 `baz`</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"bar"</span> );</span><br><span class="line">    foo(); <span class="comment">// &lt;-- `foo` 的 call-site</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用栈是: `baz` -&gt; `bar` -&gt; `foo`</span></span><br><span class="line">    <span class="comment">// 我们的调用点位于 `bar`</span></span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"foo"</span> );</span><br><span class="line">&#125;</span><br><span class="line">baz(); <span class="comment">// &lt;-- `baz` 的调用点</span></span><br></pre></td></tr></table></figure><h3 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h3><h4 id="默认绑定（Default-Binding"><a href="#默认绑定（Default-Binding" class="headerlink" title="默认绑定（Default Binding)"></a>默认绑定（Default Binding)</h4><p>该规则源于函数调用最常见的情况:独立函数调用。可以认为这种 <code>this</code> 规则是在没有其他规则适用时的默认规则。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// 2  独立函数的调用,相当于window.foo(),对此方法调用的this实施了默认绑定,使this指向全局对象window</span></span><br></pre></td></tr></table></figure><p>如果 <code>strict mode</code> 在这里生效，那么对于 <em>默认绑定</em> 来说全局对象是不合法的，所以 <code>this</code> 将被设置为 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">foo(); <span class="comment">// TypeError: `this` is `undefined`</span></span><br></pre></td></tr></table></figure><p><strong>有一个重要的细节:</strong> 即便所有的 <code>this</code> 绑定规则都是完全基于调用点的,如果<code>foo()</code>的内容没有在<code>strict mode</code>下执行,对于 <em>默认绑定</em> 来说全局对象是 <strong>唯一</strong> 合法的；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line">foo(); <span class="comment">// 2</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><blockquote><p><code>foo()</code> 的调用点的 <code>strict mode</code> 状态与此无关。</p></blockquote><h4 id="隐含绑定（Implicit-Binding"><a href="#隐含绑定（Implicit-Binding" class="headerlink" title="隐含绑定（Implicit Binding)"></a>隐含绑定（Implicit Binding)</h4><p>调用点是否有一个环境对象（<code>context object</code>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line">obj.foo(); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p> <code>foo()</code> 被声明然后作为引用属性添加到 <code>obj</code> 上，<code>obj</code>通过函数引用调用<code>foo()</code>,<code>foo()</code>内的this就指代调用对象obj;</p><blockquote><p>可以这样理解:this是在函数执行时自动创建的一个关键词,会自动指向正在调用当前函数的对象</p></blockquote><h4 id="隐含丢失（Implicitly-Lost）"><a href="#隐含丢失（Implicitly-Lost）" class="headerlink" title="隐含丢失（Implicitly Lost）"></a>隐含丢失（Implicitly Lost）</h4><p>当一个 <em>隐含绑定</em> 丢失了它的绑定，这通常意味着它会退回到 <em>默认绑定</em>， 根据 <code>strict mode</code> 的状态，其结果不是全局对象就是 <code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = obj.foo; <span class="comment">// 函数引用！</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` 也是一个全局对象的属性</span></span><br><span class="line">bar(); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure><p>这里bar仅仅是对foo的一个应用而已,调用点是bar(),因此默认绑定适用这里;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doFoo</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line"><span class="comment">// `fn` 只不过 `foo` 的另一个引用</span></span><br><span class="line">fn(); <span class="comment">// &lt;-- 调用点!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span>,</span><br><span class="line">foo: foo</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"oops, global"</span>; <span class="comment">// `a` 也是一个全局对象的属性</span></span><br><span class="line">doFoo( obj.foo ); <span class="comment">// "oops, global"</span></span><br></pre></td></tr></table></figure><p>看到这里,可以看出this的指向是由函数对象的调用点决定的</p><h4 id="明确绑定（Explicit-Binding）"><a href="#明确绑定（Explicit-Binding）" class="headerlink" title="明确绑定（Explicit Binding）"></a>明确绑定（Explicit Binding）</h4><p>如果你想强制一个函数调用使用某个特定对象作为 <code>this</code> 绑定,通过call或apply方法,用于指定this</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line">foo.call( obj ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>通过 <code>foo.call(..)</code> 使用 <em>明确绑定</em> 来调用 <code>foo</code>，允许我们强制函数的 <code>this</code> 指向 <code>obj</code>。</p><p>如果你传递一个简单基本类型值（<code>string</code>，<code>boolean</code>，或 <code>number</code> 类型）作为 <code>this</code> 绑定，那么这个基本类型值会被包装在它的对象类型中（分别是 <code>new String(..)</code>，<code>new Boolean(..)</code>，或 <code>new Number(..)</code>）。这通常称为“封箱（boxing）”。</p><p><strong>硬绑定（Hard Binding）</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">foo.call( obj );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 2</span></span><br><span class="line">setTimeout( bar, <span class="number">100</span> ); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// `bar` 将 `foo` 的 `this` 硬绑定到 `obj`</span></span><br><span class="line"><span class="comment">// 所以它不可以被覆盖</span></span><br><span class="line">bar.call( <span class="built_in">window</span> ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>我们创建了一个函数 <code>bar()</code>，在它的内部手动调用 <code>foo.call(obj)</code>，由此强制 <code>this</code> 绑定到 <code>obj</code> 并调用 <code>foo</code>。无论你过后怎样调用函数 <code>bar</code>，它总是手动使用 <code>obj</code> 调用 <code>foo</code>。这种绑定即明确又坚定，所以我们称之为 <em>硬绑定（hard binding）</em></p><p>用 <em>硬绑定</em> 将一个函数包装起来的最典型的方法，是为所有传入的参数和传出的返回值创建一个通道：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">something</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( <span class="keyword">this</span>.a, something );</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.a + something;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">a: <span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> foo.apply( obj, <span class="built_in">arguments</span> );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = bar( <span class="number">3</span> ); <span class="comment">// 2 3</span></span><br><span class="line"><span class="built_in">console</span>.log( b ); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p><strong>API 调用的“环境”</strong></p><p>许多库中的函数，和许多在 JavaScript 语言以及宿主环境中的内建函数，都提供一个可选参数，通常称为“环境（context）”，这种设计作为一种替代方案来确保你的回调函数使用特定的 <code>this</code> 而不必非得使用 <code>bind(..)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( el, <span class="keyword">this</span>.id );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">id: <span class="string">"awesome"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 `obj` 作为 `this` 来调用 `foo(..)`</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach( foo, obj ); <span class="comment">// 1 awesome  2 awesome  3 awesome</span></span><br></pre></td></tr></table></figure><p>从内部来说，几乎可以确定这种类型的函数是通过 <code>call(..)</code> 或 <code>apply(..)</code> 来使用 <em>明确绑定</em> </p><h4 id="new-绑定（new-Binding）"><a href="#new-绑定（new-Binding）" class="headerlink" title="new 绑定（new Binding）"></a><code>new</code> 绑定（<code>new</code> Binding）</h4><p>当在函数前面被加入 <code>new</code> 调用时:</p><ol><li>创建一个新的空对象</li><li>自动让新的子对象继承构造函数继承原型对象</li><li>调用构造函数，将构造函数中的this执行正在创建的新的空对象中强行添加新成员将新对象地址返回给变量</li><li>将新对象地址返回给变量保存</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.a = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> foo( <span class="number">2</span> );</span><br><span class="line"><span class="built_in">console</span>.log( bar.a ); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>以上就是函数调用中的四种 <code>this</code> 绑定规则,通常需要找到调用点然后考察哪一种规则适用于它。但四种规则是有优先级的,</p><h4 id="判定-this"><a href="#判定-this" class="headerlink" title="判定 this"></a>判定 <code>this</code></h4><ol><li><p>函数是通过 <code>new</code> 被调用的吗（<strong>new 绑定</strong>）？如果是，<code>this</code> 就是新构建的对象。</p><p><code>var bar = new foo()</code></p></li><li><p>函数是通过 <code>call</code> 或 <code>apply</code> 被调用（<strong>明确绑定</strong>），甚至是隐藏在 <code>bind</code> <em>硬绑定</em> 之中吗？如果是，<code>this</code> 就是那个被明确指定的对象。</p><p><code>var bar = foo.call( obj2 )</code></p></li><li><p>函数是通过环境对象（也称为拥有者或容器对象）被调用的吗（<strong>隐含绑定</strong>）？如果是，<code>this</code> 就是那个环境对象。</p><p><code>var bar = obj1.foo()</code></p></li><li><p>否则，使用默认的 <code>this</code>（<strong>默认绑定</strong>）。如果在 <code>strict mode</code> 下，就是 <code>undefined</code>，否则是 <code>global</code> 对象。</p><p><code>var bar = foo()</code></p></li></ol><p>以上，就是理解对于普通的函数调用来说的 <code>this</code> 绑定规则 <em>所需的全部</em>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初识this&quot;&gt;&lt;a href=&quot;#初识this&quot; class=&quot;headerlink&quot; title=&quot;初识this&quot;&gt;&lt;/a&gt;初识this&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;identify&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name.toUpperCase();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;speak&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; greeting = &lt;span class=&quot;string&quot;&gt;&quot;Hello, I&#39;m &quot;&lt;/span&gt; + identify.call( &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( greeting );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; me = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	name: &lt;span class=&quot;string&quot;&gt;&quot;Kyle&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; you = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	name: &lt;span class=&quot;string&quot;&gt;&quot;Reader&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;identify.call( me ); &lt;span class=&quot;comment&quot;&gt;// KYLE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;identify.call( you ); &lt;span class=&quot;comment&quot;&gt;// READER&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;speak.call( me ); &lt;span class=&quot;comment&quot;&gt;// Hello, I&#39;m KYLE&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;speak.call( you ); &lt;span class=&quot;comment&quot;&gt;// Hello, I&#39;m READER&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个代码片段允许 &lt;code&gt;identify()&lt;/code&gt; 和 &lt;code&gt;speak()&lt;/code&gt; 函数对多个 &lt;em&gt;环境&lt;/em&gt; 对象（&lt;code&gt;me&lt;/code&gt; 和 &lt;code&gt;you&lt;/code&gt;）进行复用，而不是针对每个对象定义函数的分离版本。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JS" scheme="http://blog.haohome.top/tags/JS/"/>
    
      <category term="YDKJS" scheme="http://blog.haohome.top/tags/YDKJS/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JavaScript之词法作用域与动态作用域</title>
    <link href="http://blog.haohome.top/2018/10/20/JavaScript/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B9%8B%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://blog.haohome.top/2018/10/20/JavaScript/你不知道的JavaScript之词法作用域与动态作用域/</id>
    <published>2018-10-19T16:00:00.000Z</published>
    <updated>2018-10-21T15:38:43.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>在写代码的过程中,我们经常分不清作用域中变量的值指向什么,主要原因是我们分不清楚是应该按照函数的调用顺序还是按照函数位置的嵌套顺序查找变量.作用域有两种工作模式:词法作用域和动态作用域,词法作用域也叫静态作用域.</p><blockquote><ul><li>词法作用域关心函数在<strong>何处声明</strong>，作用域链基于作用域嵌套 </li><li>动态作用域关心函数在<strong>何处调用</strong>，作用域链基于调用栈</li></ul></blockquote><a id="more"></a><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p><a href="https://www.cnblogs.com/xiaohuochai/p/5700095.html" target="_blank" rel="noopener">词法作用域是定义在词法阶段的作用域，是由写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变</a>.</p><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">    bar();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">100</span>;</span><br><span class="line">foo();  <span class="comment">// 100</span></span><br></pre></td></tr></table></figure><p>因为bar函数是在全局声明的，所以是输出全局变量a的值</p><p>词法作用域中又分为函数作用域和块级作用域,JavaScript没有动态作用域,它是基于函数作用域的,但同时也有块级作用域,如with关键字、try-catch语句的catch子句、let关键字（ES6）、const关键字（ES6）</p><h2 id="动态作用域"><a href="#动态作用域" class="headerlink" title="动态作用域"></a>动态作用域</h2><p>我们经常会把词法作用域和this机制弄混淆,这是因为this机制从某种程度上与动态作用域类似.</p><p>动态作用域并不关心函数和作用域是如何声明以及在任何处声明的，只关心它们从何处调用</p><p>继续拿上面的例子,如果处于动态作用域,变量a应首先在bar()中查找,没有找到会顺着调用栈在调用bar()函数的地方也就是foo()函数中查找,找到赋值a为1,所以输出1</p><blockquote><p>两种作用域的区别，简而言之，词法作用域是在定义时确定的，而动态作用域是在运行时确定的</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;在写代码的过程中,我们经常分不清作用域中变量的值指向什么,主要原因是我们分不清楚是应该按照函数的调用顺序还是按照函数位置的嵌套顺序查找变量.作用域有两种工作模式:词法作用域和动态作用域,词法作用域也叫静态作用域.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;词法作用域关心函数在&lt;strong&gt;何处声明&lt;/strong&gt;，作用域链基于作用域嵌套 &lt;/li&gt;
&lt;li&gt;动态作用域关心函数在&lt;strong&gt;何处调用&lt;/strong&gt;，作用域链基于调用栈&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JS" scheme="http://blog.haohome.top/tags/JS/"/>
    
      <category term="YDKJS" scheme="http://blog.haohome.top/tags/YDKJS/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的JavaScript之闭包</title>
    <link href="http://blog.haohome.top/2018/10/18/JavaScript/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>http://blog.haohome.top/2018/10/18/JavaScript/你不知道的JavaScript之闭包/</id>
    <published>2018-10-17T16:00:00.000Z</published>
    <updated>2018-10-21T14:58:07.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><blockquote><p>闭包是函数和声明该函数的词法环境的组合。(来自:<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">MDN</a>)</p><p>另一种定义:<strong>是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另外一个函数。</strong></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Mozilla"</span>; <span class="comment">// name 是一个被 init 创建的局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// displayName() 是内部函数,一个闭包</span></span><br><span class="line">        alert(name); <span class="comment">// 使用了父函数中声明的变量</span></span><br><span class="line">    &#125;</span><br><span class="line">    displayName();</span><br><span class="line">&#125;</span><br><span class="line">init();<span class="comment">// 弹出Mozilla</span></span><br></pre></td></tr></table></figure><ul><li><code>init()</code> 创建了一个局部变量 <code>name</code> 和一个名为 <code>displayName()</code> 的函数。</li><li><code>displayName()</code> 内没有自己的局部变量，然而它可以访问到外部函数的变量name;</li><li>但是，如果有同名变量 <code>name</code> 在 <code>displayName()</code> 中被定义，则会优先使用 <code>displayName()</code> 中定义的 <code>name</code> 。</li></ul><p>这个<em>词法作用域</em>的例子介绍了引擎是如何解析函数嵌套中的变量的</p><a id="more"></a><p>闭包是由函数以及创建该函数的词法环境组合而成,<strong>这个环境包含了这个闭包创建时所能访问的所有局部变量</strong>。函数<code>displayName()</code>具有一个涵盖<code>init()</code>作用域的闭包</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeFunc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Mozilla"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> displayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunc = makeFunc();</span><br><span class="line">myFunc();</span><br></pre></td></tr></table></figure><ul><li><p><code>myFunc</code> 是执行 <code>makeFunc</code> 时创建的 <code>displayName</code> 函数实例的引用，而 <code>displayName</code> 实例<strong>仍</strong>可访问其词法作用域中的变量(闭包环境)，即可以访问到 <code>name</code> 。</p></li><li><p>当 <code>myFunc</code> 被调用时，<code>name</code> 仍可被访问，其值 <code>Mozilla</code> 就被传递到<code>alert</code>中。</p></li></ul><p>再看一个例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">4</span>)); <span class="comment">// 14</span></span><br></pre></td></tr></table></figure><ul><li><p>我们定义了 <code>makeAdder(x)</code> 函数，它接受一个参数 <code>x</code> ，并返回一个新的函数</p></li><li><p>返回的函数接受一个参数 <code>y</code>，并返回<code>x+y</code>的值</p></li></ul><p><code>makeAdder</code> 是一个函数工厂 ,其创建了两个新函数,新函数执行时其参数<code>y</code>与<code>makeAdder</code>形成的闭包环境中的参数<code>x</code>相加;</p><p>而<code>add5</code> 和 <code>add10</code> 都是闭包,它们共享相同的函数定义，但是保存了不同的词法环境。在 <code>add5</code>的环境中，<code>x</code> 为 5。而在 <code>add10</code> 中，<code>x</code> 则为 10。</p><p>这就是闭包: 它允许将函数与其所操作的某些数据（环境）关联起来,类似于面向对象,允许对象的属性与一个或多个方法关联</p><h2 id="2-一个常见的错误-循环和闭包"><a href="#2-一个常见的错误-循环和闭包" class="headerlink" title="2. 一个常见的错误:循环和闭包"></a>2. 一个常见的错误:循环和闭包</h2><iframe width="100%" height="200" src="//jsrun.net/w2hKp/embedded/js,result/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>这是一道经典的面试题,<code>setTimeout</code>定时器是一个异步回调的方法,当执行定时器回调函数时,回调函数内部的i都通过词法作用域共享变量i,而此时<code>for</code>循环已经终止,i值为6,因此每个打印出来的都为6</p><p>而如果希望打印的是1,2,3,4,5,通过声明并立即执行一个函数来创建作用域,循环中的每个迭代都给自己捕获一个<code>i</code>的副本储存,结果就能实现,如:</p><iframe width="100%" height="200" src="//jsrun.net/N2hKp/embedded/js,result/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>ES6语法中let会创建块级作用域,很简单就能实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;,i * <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-用闭包模拟私有方法-模块模式"><a href="#3-用闭包模拟私有方法-模块模式" class="headerlink" title="3.用闭包模拟私有方法(模块模式)"></a>3.用闭包模拟私有方法(模块模式)</h2><p>在java的编程语言中,是支持方法声明为私有的,即他们只能被同一个类中的其他方法所调用,JavaScript不支持(typescript支持),但js是可以通过闭包的方式模拟私有方法;</p><p><strong>私有化方法有利于限制对代码的访问</strong>,还提供了管理全局命名空间的能力,避免非核心方法影响了代码的公共接口部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">-1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> count1= Counter()</span><br><span class="line"><span class="built_in">console</span>.log(count1.value());<span class="comment">//0</span></span><br><span class="line">count1.increment();</span><br><span class="line">count1.increment();</span><br><span class="line"><span class="built_in">console</span>.log(count1.value());<span class="comment">//2</span></span><br><span class="line">count1.decrement();</span><br><span class="line">count1.log(Counter.value());<span class="comment">//1</span></span><br><span class="line"><span class="keyword">var</span> count2 = Counter()</span><br><span class="line"><span class="built_in">console</span>.log(count2.value())<span class="comment">//0</span></span><br></pre></td></tr></table></figure><p><code>Counter()</code>形成了闭包环境(可认为是模块),返回三个对象方法:<code>increment</code>、<code>decrement</code> 和 <code>value</code>,这三个公共函数具有涵盖实例内部作用域的闭包,其本质也可看做是<strong>模块的公共API</strong>,通过它访问闭包环境内的私有属性和方法:<code>privateCounter</code> 的变量和名为 <code>changeBy</code> 的函数;</p><blockquote><p>通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值。</p></blockquote><p>当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创造了可以观察和实践闭包的条件。</p><p>对于模块模式,需要具备两个必要条件:</p><ol><li>必须有外部的封闭函数,形成私有作用域,该函数必须至少被调用一次(每次调用都会创建一个新的模块实例)</li><li>封闭函数必须返回至少一个内部函数,即模块的公共API,以访问或者修改私有的状态</li></ol><p>上一个示例代码中有一个叫作<code>Counter()</code>的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对这个模式进行简单的改进来实现<strong>单例模式</strong>：</p><blockquote><p>采用匿名函数自调</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> privateCounter = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">changeBy</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    privateCounter += val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    increment: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    decrement: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      changeBy(<span class="number">-1</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> privateCounter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(count.value());<span class="comment">//0</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-简介&quot;&gt;&lt;a href=&quot;#1-简介&quot; class=&quot;headerlink&quot; title=&quot;1. 简介&quot;&gt;&lt;/a&gt;1. 简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;闭包是函数和声明该函数的词法环境的组合。(来自:&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MDN&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;另一种定义:&lt;strong&gt;是指有权访问另外一个函数作用域中的变量的函数。创建闭包的常见方式就是在一个函数内部创建另外一个函数。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;init&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name = &lt;span class=&quot;string&quot;&gt;&quot;Mozilla&quot;&lt;/span&gt;; &lt;span class=&quot;comment&quot;&gt;// name 是一个被 init 创建的局部变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;displayName&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123; &lt;span class=&quot;comment&quot;&gt;// displayName() 是内部函数,一个闭包&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        alert(name); &lt;span class=&quot;comment&quot;&gt;// 使用了父函数中声明的变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    displayName();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;init();		&lt;span class=&quot;comment&quot;&gt;// 弹出Mozilla&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;init()&lt;/code&gt; 创建了一个局部变量 &lt;code&gt;name&lt;/code&gt; 和一个名为 &lt;code&gt;displayName()&lt;/code&gt; 的函数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;displayName()&lt;/code&gt; 内没有自己的局部变量，然而它可以访问到外部函数的变量name;&lt;/li&gt;
&lt;li&gt;但是，如果有同名变量 &lt;code&gt;name&lt;/code&gt; 在 &lt;code&gt;displayName()&lt;/code&gt; 中被定义，则会优先使用 &lt;code&gt;displayName()&lt;/code&gt; 中定义的 &lt;code&gt;name&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个&lt;em&gt;词法作用域&lt;/em&gt;的例子介绍了引擎是如何解析函数嵌套中的变量的&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JS" scheme="http://blog.haohome.top/tags/JS/"/>
    
      <category term="YDKJS" scheme="http://blog.haohome.top/tags/YDKJS/"/>
    
  </entry>
  
  <entry>
    <title>iTerm终端设置代理</title>
    <link href="http://blog.haohome.top/2018/10/10/Mac&amp;PC/iTerm%20%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <id>http://blog.haohome.top/2018/10/10/Mac&amp;PC/iTerm 终端设置代理/</id>
    <published>2018-10-09T16:00:00.000Z</published>
    <updated>2018-10-20T07:21:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>某些站点必须爬墙才能访问，但在mac上设置的全局代理，对终端又不起作用，终端需要单独设置代理。<br>在终端中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ALL_PROXY=socks5://127.0.0.1:1086/</span><br></pre></td></tr></table></figure><p>如果是http的代理:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:1087/</span><br><span class="line">export https_proxy=http://127.0.0.1:1087/</span><br></pre></td></tr></table></figure><p>如果需要开机自动设置，把上面的代码加到~/.bash_profile里</p><p><code>source  ~/.bash_profile</code> 使文件生效</p><p>测试当前终端标签/窗口是否走代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl ip.gs</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;某些站点必须爬墙才能访问，但在mac上设置的全局代理，对终端又不起作用，终端需要单独设置代理。&lt;br&gt;在终端中执行：&lt;/p&gt;
&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span c
      
    
    </summary>
    
      <category term="Mac&amp;PC" scheme="http://blog.haohome.top/categories/Mac-PC/"/>
    
    
      <category term="电脑技巧" scheme="http://blog.haohome.top/tags/%E7%94%B5%E8%84%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式之适配器模式</title>
    <link href="http://blog.haohome.top/2018/10/07/JavaScript/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.haohome.top/2018/10/07/JavaScript/JavaScript设计模式之适配器模式/</id>
    <published>2018-10-06T16:00:00.000Z</published>
    <updated>2018-10-07T06:52:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>适配器模式的作用是解决两个软件实体间的接口不兼容的问题.</p><p>这在实际开发过程中会经常遇到,比如后端返回的数据api接口与前端实际需求有差异,我们就需要对数据api接口进行转换一下再使用,这就需要适配器;而在vue中最直接的提现就是computed属性</p><p>举个例子:     当向谷歌地图和百度地图都发出显示请求时,两个地图都以各自的方式展示</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoogleMap</span></span>&#123;</span><br><span class="line">    show()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染谷歌地图'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaiduMap</span></span>&#123;</span><br><span class="line">    show()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染百度地图'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderMap</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(map)&#123;</span><br><span class="line">    <span class="keyword">if</span> ( map.show <span class="keyword">instanceof</span> <span class="built_in">Function</span> )&#123;</span><br><span class="line">            map.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> baiduMap = <span class="keyword">new</span> BaiduMap()</span><br><span class="line"><span class="keyword">let</span> baidu = <span class="keyword">new</span> RenderMap(baiduMap)</span><br><span class="line"><span class="keyword">let</span> googleMap = <span class="keyword">new</span> GoogleMap()</span><br><span class="line"><span class="keyword">let</span> google = <span class="keyword">new</span> RenderMap(googleMap)</span><br></pre></td></tr></table></figure><a id="more"></a><p>这段程序正常运行的关键是,两个地图类都提供了show的方法,假如google提供的不是show而是display方法,那我们可通过增加新的适配器来解决:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoogleMap</span></span>&#123;</span><br><span class="line">    display()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log( <span class="string">'开始渲染谷歌地图'</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoogleAdapter</span></span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(googleMap)&#123;</span><br><span class="line"><span class="keyword">this</span>.googleMap = googleMap</span><br><span class="line">&#125;</span><br><span class="line">show()&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.googleMap.display()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g = <span class="keyword">new</span> GoogleMap()</span><br><span class="line"><span class="keyword">let</span> googleMap = <span class="keyword">new</span> GoogleAdapter(g)</span><br><span class="line"><span class="keyword">let</span> google = <span class="keyword">new</span> RenderMap(googleMap)</span><br></pre></td></tr></table></figure><p>适配器模式主要用来解决两个已有接口之间不匹配的问题，它不考虑这些接口是怎样实现的，也不考虑它们将来可能会如何演化。适配器模式不需要改变已有的接口，就能够使它们协同作用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;适配器模式的作用是解决两个软件实体间的接口不兼容的问题.&lt;/p&gt;
&lt;p&gt;这在实际开发过程中会经常遇到,比如后端返回的数据api接口与前端实际需求有差异,我们就需要对数据api接口进行转换一下再使用,这就需要适配器;而在vue中最直接的提现就是computed属性&lt;/p&gt;
&lt;p&gt;举个例子:     当向谷歌地图和百度地图都发出显示请求时,两个地图都以各自的方式展示&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;GoogleMap&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    show()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&#39;开始渲染谷歌地图&#39;&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;BaiduMap&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    show()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&#39;开始渲染百度地图&#39;&lt;/span&gt; );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;RenderMap&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(map)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; ( map.show &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt; )&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            map.show();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; baiduMap = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BaiduMap()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; baidu = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RenderMap(baiduMap)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; googleMap = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; GoogleMap()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; google = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; RenderMap(googleMap)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JS" scheme="http://blog.haohome.top/tags/JS/"/>
    
      <category term="设计模式" scheme="http://blog.haohome.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript设计模式之单例模式</title>
    <link href="http://blog.haohome.top/2018/10/06/JavaScript/JavaScript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.haohome.top/2018/10/06/JavaScript/JavaScript设计模式之单例模式/</id>
    <published>2018-10-05T16:00:00.000Z</published>
    <updated>2018-10-07T06:50:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>单例模式是保证一个类仅有一个实例，并提供一个访问它的全局访问点</p><blockquote><p>实现方式:用一个变量来标志当前是否已经为某个类创建过对象,若是,则在下一次获取该类实例时,直接返回之前创建的对象</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(instance)&#123;</span><br><span class="line">        <span class="keyword">this</span>.instance = instance</span><br><span class="line">    &#125;</span><br><span class="line">    login()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'登录框弹窗'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">SingleObject.getInstance = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="keyword">this</span>.instance)&#123;</span><br><span class="line">      <span class="keyword">this</span>.instance = <span class="keyword">new</span> SingleObject()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.instance</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj1 = SingleObject.getInstance()</span><br><span class="line">obj1.login()</span><br><span class="line"><span class="keyword">let</span> obj2 = SingleObject.getInstance()</span><br><span class="line">obj2.login()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'obj1===obj2'</span>,obj1===obj2)</span><br></pre></td></tr></table></figure><p>通过<code>SingleObject.getInstance</code>来获取SingleObject类的唯一对象</p><a id="more"></a><p> 应用场景: 网站的登录框通常只有一个实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginForm</span></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'hide'</span><span class="comment">// 默认隐藏</span></span><br><span class="line">    &#125;</span><br><span class="line">    show()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state === <span class="string">'show'</span>)&#123;</span><br><span class="line">            alert(<span class="string">'已经显示'</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'show'</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'登录框显示成功'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    hide()&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.state === <span class="string">'hide'</span>)&#123;</span><br><span class="line">            alert(<span class="string">'已经隐藏'</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'hide'</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'登录框隐藏成功'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">LoginForm.getInstance = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> instance</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'外部'</span>,instance)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'内部'</span>,instance)</span><br><span class="line">        <span class="keyword">if</span>(!instance)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LoginForm()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="keyword">let</span> login1 = LoginForm.getInstance()</span><br><span class="line">login1.show()</span><br><span class="line"><span class="keyword">let</span> login2 = LoginForm.getInstance()</span><br><span class="line">login2.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;单例模式是保证一个类仅有一个实例，并提供一个访问它的全局访问点&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现方式:用一个变量来标志当前是否已经为某个类创建过对象,若是,则在下一次获取该类实例时,直接返回之前创建的对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;SingleObject&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(instance)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.instance = instance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    login()&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;登录框弹窗&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SingleObject.getInstance = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.instance)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.instance = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; SingleObject()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.instance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj1 = SingleObject.getInstance()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj1.login()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; obj2 = SingleObject.getInstance()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;obj2.login()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;obj1===obj2&#39;&lt;/span&gt;,obj1===obj2)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;通过&lt;code&gt;SingleObject.getInstance&lt;/code&gt;来获取SingleObject类的唯一对象&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JS" scheme="http://blog.haohome.top/tags/JS/"/>
    
      <category term="设计模式" scheme="http://blog.haohome.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Mac下使用iTerm2让SSH记录远程服务器账号和密码</title>
    <link href="http://blog.haohome.top/2018/10/05/Mac&amp;PC/Mac%E4%B8%8B%E4%BD%BF%E7%94%A8iTerm2%E8%AE%A9SSH%E8%AE%B0%E5%BD%95%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B4%A6%E5%8F%B7%E5%92%8C%E5%AF%86%E7%A0%81/"/>
    <id>http://blog.haohome.top/2018/10/05/Mac&amp;PC/Mac下使用iTerm2让SSH记录远程服务器账号和密码/</id>
    <published>2018-10-04T16:00:00.000Z</published>
    <updated>2018-11-14T14:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>iTerm2和Macbook自带的Terminal差不多，但是功能更强大，强烈推荐使用。</p><p> 下面说下，如何让iTerm2记住远程服务器SSH登录账号和密码。</p><p> 第一步：打开Finder，在菜单栏找到『前往』→ 『前往文件夹…』，输入：~/.ssh/ 然后回车</p><p> 第二步：新建一个文件，命名为example吧，里面写入内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set user root</span><br><span class="line">set host 114.114.114.114</span><br><span class="line">set password ********</span><br><span class="line"> </span><br><span class="line">spawn ssh $user@$host</span><br><span class="line">expect "*assword:*"</span><br><span class="line">send "$password\r"</span><br><span class="line">interact</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p> 第三步：到官方<a href="http://www.iterm2.com/" target="_blank" rel="noopener">http://www.iterm2.com/</a>下载并打开iTerm2，菜单栏找到『Profiles』→『Open Profiles…』,打开面板上，点击右下角『Edit  Profiles…』</p><p> 第四步：在打开面板，左边应该是选中默认default，右边找到Command，默认应该是Login shell，选中Command，里面输入：expect ~/.ssh/example</p><p> 第五步，下次打开iTerm2，是不是默认就登录上服务器了？极大提升效率。<br> 按照以上方法，可以配置profile,对应很多个服务器。这样每次启动可以选择默认操作，然后再profile下拉选中中执行对应的VPS profile，则可以实现自动登录！</p><blockquote><p>Tips:  如果重新添加相同ip的实例,需要在~/.ssh/known_hosts 里删除该ip的ssh-rsa码</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;iTerm2和Macbook自带的Terminal差不多，但是功能更强大，强烈推荐使用。&lt;/p&gt;
&lt;p&gt; 下面说下，如何让iTerm2记住远程服务器SSH登录账号和密码。&lt;/p&gt;
&lt;p&gt; 第一步：打开Finder，在菜单栏找到『前往』→ 『前往文件夹…』，输入：~/.ssh
      
    
    </summary>
    
      <category term="Mac&amp;PC" scheme="http://blog.haohome.top/categories/Mac-PC/"/>
    
    
      <category term="电脑技巧" scheme="http://blog.haohome.top/tags/%E7%94%B5%E8%84%91%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>图片上传与压缩</title>
    <link href="http://blog.haohome.top/2018/09/30/Program/%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E4%B8%8E%E5%8E%8B%E7%BC%A9/"/>
    <id>http://blog.haohome.top/2018/09/30/Program/图片上传与压缩/</id>
    <published>2018-09-29T16:00:00.000Z</published>
    <updated>2018-09-30T15:20:24.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> 最近在做关于移动端图片上传方面,项目中主要需要实现图片的本地预览、压缩和上传</p></blockquote><p><img src="https://haohome.top/18-9-30/10762358.jpg" width="300"></p><h2 id="1-图片选择和预览"><a href="#1-图片选择和预览" class="headerlink" title="1. 图片选择和预览"></a>1. 图片选择和预览</h2><p>添加<code>accept</code>属性,控制选择文件的类型为拍照和图像文件,设置multiple支持图片文件多选,监听<code>input</code>的<code>change</code>事件获取选择对象文件,每个文件都是Blob类型</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file2"</span>&gt;</span>多个图片上传<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">accept</span>=<span class="string">"image/gif,image/jpeg,image/png"</span> <span class="attr">multiple</span> <span class="attr">id</span>=<span class="string">'file2'</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"preview2"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// 模拟jQuery</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> $ = <span class="function"><span class="params">selector</span> =&gt;</span> <span class="built_in">document</span>.querySelector(selector)</span></span><br><span class="line"><span class="actionscript"><span class="comment">// 多个图片</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> file2 = $(<span class="string">"#file2"</span>)</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> preview2 = $(<span class="string">'#preview2'</span>)</span></span><br><span class="line"><span class="actionscript">file2.onchange = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> fileList = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>.files)</span></span><br><span class="line"><span class="javascript">    fileList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> domImg = <span class="keyword">new</span> Image();</span></span><br><span class="line"><span class="undefined">        domImg.src = URL.createObjectURL(item)</span></span><br><span class="line"><span class="undefined">        preview2.appendChild(domImg)</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-图片的压缩"><a href="#2-图片的压缩" class="headerlink" title="2. 图片的压缩"></a>2. 图片的压缩</h2><p>当前手机拍照质量月来越高,带来的问题就是大小也越来越大,直接上传原图,上传速度会很低,甚至很可能上传失败,而且后续加载也影响速度</p><p>下面是封装了一个压缩图片的方法,实现的原理是,利用canvas将图片绘制出来,并导出canvas图片.主要通过图片的缩放和控制canvas导出图片质量来实现图片的体积压缩</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 压缩图片</span></span><br><span class="line"><span class="comment">     * @param &#123;file&#125; 输入图片</span></span><br><span class="line"><span class="comment">     * @param &#123;quality&#125; 图片质量</span></span><br><span class="line"><span class="comment">     * @returns &#123;Promise&#125; resolved promise 返回压缩后的新图片</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compressImg</span>(<span class="params">file, quality</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">      img.src = URL.createObjectURL(file)</span><br><span class="line">      img.onerror = <span class="function"><span class="params">error</span> =&gt;</span> reject(error)</span><br><span class="line">      img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">          <span class="keyword">var</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">          <span class="keyword">var</span> canvasWidth = <span class="built_in">document</span>.documentElement.clientWidth * <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line">          <span class="keyword">var</span> canvasHeight = <span class="built_in">document</span>.documentElement.clientHeight * <span class="built_in">window</span>.devicePixelRatio</span><br><span class="line">          <span class="comment">// 水平方向想缩放比</span></span><br><span class="line">          <span class="keyword">var</span> scaleX = canvasWidth / img.width</span><br><span class="line">          <span class="keyword">var</span> scaleY = canvasHeight / img.height</span><br><span class="line">          <span class="comment">// 取缩放比更小的比例</span></span><br><span class="line">          <span class="keyword">var</span> scale = <span class="built_in">Math</span>.min(scaleX, scaleY)</span><br><span class="line">          <span class="comment">// 画布上绘制的图片尺寸</span></span><br><span class="line">          <span class="keyword">const</span> imageWidth = img.width * scale</span><br><span class="line">          <span class="keyword">const</span> imageHeight = img.height * scale</span><br><span class="line">          canvas.width = imageWidth</span><br><span class="line">          canvas.height = imageHeight</span><br><span class="line">          ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, imageWidth, imageHeight)</span><br><span class="line">          canvas.toBlob(<span class="function"><span class="params">file</span> =&gt;</span> resolve(file), <span class="string">"image/jpeg"</span>, quality);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">file2.onchange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fileList = <span class="built_in">Array</span>.prototype.slice.call(<span class="keyword">this</span>.files)</span><br><span class="line">    fileList.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">        compressImg(imgfile, <span class="number">.5</span>).then(<span class="function"><span class="params">blobFile</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> domImg = <span class="keyword">new</span> Image();</span><br><span class="line">            domImg.src = URL.createObjectURL(blobFile)</span><br><span class="line">            preview2.appendChild(domImg)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-图片上传"><a href="#3-图片上传" class="headerlink" title="3. 图片上传"></a>3. 图片上传</h2><p>文件上传是通过<code>FormData</code>创建表单数据，并发起 ajax <code>POST</code>请求;</p><blockquote><p>发送<code>FormData</code>数据时，浏览器会自动设置<code>Content-Type</code>为合适的值</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上传图片</span></span><br><span class="line"><span class="comment">     * @param &#123;File&#125; file 待上传的文件</span></span><br><span class="line"><span class="comment">     * @return &#123;Promise&#125; </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params">file,url</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 准备表单数据</span></span><br><span class="line">        <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">        formData.append(<span class="string">'file'</span>, file)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 提交请求</span></span><br><span class="line">        <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        xhr.open(<span class="string">'POST'</span>, url)</span><br><span class="line">        xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">this</span>.readyState === XMLHttpRequest.DONE &amp;&amp; <span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">            resolve(<span class="built_in">JSON</span>.parse(<span class="keyword">this</span>.responseText))</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reject(<span class="keyword">this</span>.responseText)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        xhr.send(formData)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>最后奉上JSrun的demo:</p><iframe width="100%" height="300" src="//jsrun.net/kyhKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; 最近在做关于移动端图片上传方面,项目中主要需要实现图片的本地预览、压缩和上传&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://haohome.top/18-9-30/10762358.jpg&quot; width=&quot;300&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-图片选择和预览&quot;&gt;&lt;a href=&quot;#1-图片选择和预览&quot; class=&quot;headerlink&quot; title=&quot;1. 图片选择和预览&quot;&gt;&lt;/a&gt;1. 图片选择和预览&lt;/h2&gt;&lt;p&gt;添加&lt;code&gt;accept&lt;/code&gt;属性,控制选择文件的类型为拍照和图像文件,设置multiple支持图片文件多选,监听&lt;code&gt;input&lt;/code&gt;的&lt;code&gt;change&lt;/code&gt;事件获取选择对象文件,每个文件都是Blob类型&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Data类型的url简介</title>
    <link href="http://blog.haohome.top/2018/09/28/HTML5&amp;CSS/Data%E7%B1%BB%E5%9E%8B%E7%9A%84Url%E7%AE%80%E4%BB%8B/"/>
    <id>http://blog.haohome.top/2018/09/28/HTML5&amp;CSS/Data类型的Url简介/</id>
    <published>2018-09-27T16:00:00.000Z</published>
    <updated>2018-09-28T05:20:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-定义和语法"><a href="#1-定义和语法" class="headerlink" title="1. 定义和语法"></a>1. 定义和语法</h2><p><strong>Data URLs</strong>，即前缀为 <code>data:</code> 协议的的URL，其允许内容创建者向文档中嵌入小文件。(<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/data_URIs" target="_blank" rel="noopener">MDN</a>)</p><p>这样的好处是减少外部资源的载入,减少http请求</p><p>Data URLs 由四个部分组成：前缀(<code>data:</code>)、指示数据类型的MIME类型、如果非文本则为可选的<code>base64</code>标记、数据本身：</p><blockquote><p><code>data:[&lt;mediatype&gt;][;base64],&lt;data&gt;</code></p><ul><li><code>mediatype</code>是个 MIME 类型的字符串，例如 “<code>image/jpeg</code>“ 表示 JPEG 图像文件,如果被省略，则默认值为 <code>text/plain;charset=US-ASCII</code></li></ul></blockquote><p>实例:</p><blockquote><p><code>data:,Hello%2C%20World!</code>简单的 text/plain 类型数据</p><p><code>data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D</code>上一条示例的 base64 编码版本</p><p><code>data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E</code>一个HTML文档源代码 <code>&lt;h1&gt;Hello, World&lt;/h1&gt;</code></p><p><code>data:text/html,&lt;script&gt;alert(&#39;hi&#39;);&lt;/script&gt;</code>一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。</p></blockquote><a id="more"></a><h2 id="2-data-url的优缺点"><a href="#2-data-url的优缺点" class="headerlink" title="2. data url的优缺点"></a>2. data url的优缺点</h2><p>优点:</p><blockquote><ul><li>当访问外部资源很麻烦或受限时(这个比较鸡肋)</li><li>当图片是在服务器端用程序动态生成，每个访问用户显示的都不同时（场景较少）</li><li>当图片的体积太小，<strong>占用一个HTTP会话</strong>不是很值得时（雪碧图可以出场了）</li></ul></blockquote><p>缺点:</p><blockquote><ul><li>Base64编码的数据体积通常是<strong>原数据的体积4/3</strong>，也就是Data URL形式的图片会比二进制格式的图片体积大1/3</li><li>Data URL形式的图片<strong>不会被浏览器缓存</strong>，这意味着每次访问这样页面时都被下载一次</li></ul></blockquote><h2 id="3-在css中使用"><a href="#3-在css中使用" class="headerlink" title="3.在css中使用"></a>3.在css中使用</h2><p>浏览器会css文件以提高访问效率,所以浏览器也可以缓存css中的data url数据,</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line"><span class="attribute">background-image</span>: <span class="built_in">url</span>(<span class="string">"data:image/gif;b ase64,R0lGODlhAwADAIAAAP///8zMzCH5BAAAAAAALAAAAAADAAMAAAIEBHIJBQA7"</span>);</span><br><span class="line"><span class="attribute">border</span>: <span class="number">1px</span> solid gray;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图片不是很大,而且不会是重复在css中使用,适合用data url形式展现</p><p>更多请阅读<a href="https://www.99css.com/492/" target="_blank" rel="noopener">Data URI&amp;MHTML: 用还是不用？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-定义和语法&quot;&gt;&lt;a href=&quot;#1-定义和语法&quot; class=&quot;headerlink&quot; title=&quot;1. 定义和语法&quot;&gt;&lt;/a&gt;1. 定义和语法&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Data URLs&lt;/strong&gt;，即前缀为 &lt;code&gt;data:&lt;/code&gt; 协议的的URL，其允许内容创建者向文档中嵌入小文件。(&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/data_URIs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MDN&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;这样的好处是减少外部资源的载入,减少http请求&lt;/p&gt;
&lt;p&gt;Data URLs 由四个部分组成：前缀(&lt;code&gt;data:&lt;/code&gt;)、指示数据类型的MIME类型、如果非文本则为可选的&lt;code&gt;base64&lt;/code&gt;标记、数据本身：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;data:[&amp;lt;mediatype&amp;gt;][;base64],&amp;lt;data&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mediatype&lt;/code&gt;是个 MIME 类型的字符串，例如 “&lt;code&gt;image/jpeg&lt;/code&gt;“ 表示 JPEG 图像文件,如果被省略，则默认值为 &lt;code&gt;text/plain;charset=US-ASCII&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;实例:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;data:,Hello%2C%20World!&lt;/code&gt;简单的 text/plain 类型数据&lt;/p&gt;
&lt;p&gt;&lt;code&gt;data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D&lt;/code&gt;上一条示例的 base64 编码版本&lt;/p&gt;
&lt;p&gt;&lt;code&gt;data:text/html,%3Ch1%3EHello%2C%20World!%3C%2Fh1%3E&lt;/code&gt;一个HTML文档源代码 &lt;code&gt;&amp;lt;h1&amp;gt;Hello, World&amp;lt;/h1&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;data:text/html,&amp;lt;script&amp;gt;alert(&amp;#39;hi&amp;#39;);&amp;lt;/script&amp;gt;&lt;/code&gt;一个会执行 JavaScript alert 的 HTML 文档。注意 script 标签必须封闭。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://blog.haohome.top/categories/HTML5/"/>
    
    
      <category term="html5" scheme="http://blog.haohome.top/tags/html5/"/>
    
      <category term="wiki" scheme="http://blog.haohome.top/tags/wiki/"/>
    
  </entry>
  
  <entry>
    <title>浏览器兼容性</title>
    <link href="http://blog.haohome.top/2018/09/26/Program/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.haohome.top/2018/09/26/Program/浏览器兼容性总结/</id>
    <published>2018-09-25T16:00:00.000Z</published>
    <updated>2018-09-28T01:28:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-视频截取第一帧"><a href="#1-视频截取第一帧" class="headerlink" title="1. 视频截取第一帧"></a>1. 视频截取第一帧</h2><ul><li>问题: 在加载h5 的视频时,PC端一半都会默认加载首帧显示,而在移动端就会显示空白或者一片黑</li></ul><blockquote><p><strong>解决方案</strong>: 在上传本地视频时,监听视频加载事件,获取第一帧图片,利用canvas绘制出图片并存储,作为移动端视频video的poster</p><p>onloadeddata事件:  浏览器加载声频、视频当前帧结束后触发的事件(与下一帧是否下载完成无关)<br>在音频和视频加载过程中,能够触发的事件如下:</p><ol><li>开始读入媒体数据时触发的事件(<a href="http://www.webkkl.com/api-v/onloadstart.php" target="_blank" rel="noopener">onloadstart</a>)</li><li>更改声频、视频的时长时(<a href="http://www.webkkl.com/api-v/ondurationchange.php" target="_blank" rel="noopener">ondurationchange</a>)</li><li>浏览器已加载声频、视频的元数据时触发的事件(<a href="http://www.webkkl.com/api-v/onloadedmetadata.php" target="_blank" rel="noopener">onloadedmetadata</a>)</li><li>浏览器加载声频、视频当前帧结束后(<a href="http://www.webkkl.com/api-v/onloadeddata.php" target="_blank" rel="noopener">onloadeddata</a>)</li><li>浏览器正在下载媒体数据时(<a href="http://www.webkkl.com/api-v/onprogress.php" target="_blank" rel="noopener">onprogress</a>)</li><li>浏览器可以播放媒体数据时(<a href="http://www.webkkl.com/api-v/oncanplay.php" target="_blank" rel="noopener">oncanplay</a>)</li><li>当浏览器可以在不因缓冲而停顿的情况下播放时(<a href="http://www.webkkl.com/api-v/oncanplaythrough.php" target="_blank" rel="noopener">oncanplaythrough</a>)</li></ol></blockquote><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;h1&gt;视频获取第一帧&lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">  &lt;hr&gt;</span></span><br><span class="line"><span class="regexp">  &lt;div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;p&gt;本地上传&lt;/</span>p&gt;</span><br><span class="line">      &lt;label <span class="keyword">for</span>=<span class="string">"file"</span>&gt;选择视频&lt;<span class="regexp">/label&gt; </span></span><br><span class="line"><span class="regexp">      &lt;input type="file" name="" id="file""&gt;&lt;br&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">      &lt;p&gt;外链&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input type="text" id='link'&gt;&lt;button id="btn"&gt;提交&lt;/</span>button&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  &lt;hr&gt;</span></span><br><span class="line"><span class="regexp">  &lt;video id='video'  preload="meta" style='display:none' crossorigin="anonymous"&gt;&lt;/</span>video&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;首帧图片显示&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;img src="" alt="" id="img"&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">&lt;p&gt;外链视频: https:<span class="comment">//haohome.top/movie.mp4&lt;/p&gt;</span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> video = <span class="built_in">document</span>.getElementById(<span class="string">"video"</span>)</span><br><span class="line">    <span class="keyword">var</span> file = <span class="built_in">document</span>.getElementById(<span class="string">"file"</span>)</span><br><span class="line">    <span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>)</span><br><span class="line">    <span class="keyword">var</span> link = <span class="built_in">document</span>.getElementById(<span class="string">"link"</span>)</span><br><span class="line">    file.addEventListener(<span class="string">"change"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> file  = <span class="keyword">this</span>.files[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">var</span> src = URL.createObjectURL(file)</span><br><span class="line">      <span class="keyword">var</span> newFile = <span class="keyword">new</span> FileReader(file)</span><br><span class="line">      video.src = src</span><br><span class="line">    &#125;)</span><br><span class="line">    btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      video.src =link.value</span><br><span class="line">    &#125;</span><br><span class="line">     video.addEventListener(<span class="string">"loadeddata"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>);</span><br><span class="line">      canvas.width = <span class="keyword">this</span>.videoWidth;</span><br><span class="line">      canvas.height = <span class="keyword">this</span>.videoHeight;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        canvas.getContext(<span class="string">'2d'</span>).drawImage(video, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height);</span><br><span class="line">        <span class="keyword">var</span> imgSrc = <span class="string">''</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          imgSrc = canvas.toDataURL(<span class="string">"image/png"</span>);</span><br><span class="line">          img.src = imgSrc</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">          <span class="built_in">document</span>.write(<span class="string">"只能截取当前域名视频图片! "</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="number">200</span>)</span><br><span class="line">    &#125;, <span class="literal">false</span>);</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br></pre></td></tr></table></figure><iframe width="100%" height="300" src="//jsrun.net/PqhKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p><strong>当采用链接视频时,会存在视频的跨域问题,需要在video上添加属性crossOrigin=’Anonymous’ 即可</strong>(IE由于安全性问题,会报SecurityError)</p><blockquote><p>Tips:</p><p>获取本地地址两种方法:</p><ol><li><p><code>URL.createObjectURL</code>: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">var</span> src = URL.createObjectURL(file)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>&gt;</p><blockquote><ol><li><p><strong><code>FileReader</code></strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="keyword">var</span> fr=<span class="keyword">new</span> FileReader();</span><br><span class="line">&gt;    fr.onload=<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">&gt;     <span class="keyword">var</span> src =<span class="keyword">this</span>.result;</span><br><span class="line">&gt;    &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>当前监听video视频获取首帧图片时,采用了延时200ms,是为了给视频加载以一定时间</p></li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-视频截取第一帧&quot;&gt;&lt;a href=&quot;#1-视频截取第一帧&quot; class=&quot;headerlink&quot; title=&quot;1. 视频截取第一帧&quot;&gt;&lt;/a&gt;1. 视频截取第一帧&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;问题: 在加载h5 的视频时,PC端一半都会默认加载首帧显示,而在移动端就会显示空白或者一片黑&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;: 在上传本地视频时,监听视频加载事件,获取第一帧图片,利用canvas绘制出图片并存储,作为移动端视频video的poster&lt;/p&gt;
&lt;p&gt;onloadeddata事件:  浏览器加载声频、视频当前帧结束后触发的事件(与下一帧是否下载完成无关)&lt;br&gt;在音频和视频加载过程中,能够触发的事件如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开始读入媒体数据时触发的事件(&lt;a href=&quot;http://www.webkkl.com/api-v/onloadstart.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;onloadstart&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;更改声频、视频的时长时(&lt;a href=&quot;http://www.webkkl.com/api-v/ondurationchange.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ondurationchange&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;浏览器已加载声频、视频的元数据时触发的事件(&lt;a href=&quot;http://www.webkkl.com/api-v/onloadedmetadata.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;onloadedmetadata&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;浏览器加载声频、视频当前帧结束后(&lt;a href=&quot;http://www.webkkl.com/api-v/onloadeddata.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;onloadeddata&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;浏览器正在下载媒体数据时(&lt;a href=&quot;http://www.webkkl.com/api-v/onprogress.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;onprogress&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;浏览器可以播放媒体数据时(&lt;a href=&quot;http://www.webkkl.com/api-v/oncanplay.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;oncanplay&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;当浏览器可以在不因缓冲而停顿的情况下播放时(&lt;a href=&quot;http://www.webkkl.com/api-v/oncanplaythrough.php&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;oncanplaythrough&lt;/a&gt;)&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
      <category term="兼容性" scheme="http://blog.haohome.top/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>hashchange事件</title>
    <link href="http://blog.haohome.top/2018/08/28/Program/hashchange%E4%BA%8B%E4%BB%B6/"/>
    <id>http://blog.haohome.top/2018/08/28/Program/hashchange事件/</id>
    <published>2018-08-27T16:00:00.000Z</published>
    <updated>2018-08-28T09:28:17.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在写公司的后台管理系统，因为需求需要刷新后保持原来页面,原有的单页面组件跳转方式不能满足，所以在原有项目基础上增加了路由功能,目前比较简单的路由切换就是通过监听hash变化，实现不同页面的加载。</p></blockquote><p>当 一个窗口地址的 hash （URL 中 # 后面的部分）改变时就会触发 hashchange 事件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onhashchange = handleHashChange;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"hashchange"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//hash变化的处理逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><a id="more"></a><p>hashchange 事件回调函数对象主要有两个参数会用到:</p><ul><li><p>newURL: 当前页面新的URL</p></li><li><p>oldURL: 当前页面旧的URL</p></li></ul><p>但在IE浏览器里,这两个属性不被支持,需要在绑定hashchange事件前添加以下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!<span class="built_in">window</span>.HashChangeEvent)(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> lastURL=<span class="built_in">document</span>.URL;</span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"hashchange"</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(event,<span class="string">"oldURL"</span>,&#123;<span class="attr">enumerable</span>:<span class="literal">true</span>,<span class="attr">configurable</span>:<span class="literal">true</span>,<span class="attr">value</span>:lastURL&#125;);</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(event,<span class="string">"newURL"</span>,&#123;<span class="attr">enumerable</span>:<span class="literal">true</span>,<span class="attr">configurable</span>:<span class="literal">true</span>,<span class="attr">value</span>:<span class="built_in">document</span>.URL&#125;);</span><br><span class="line">lastURL=<span class="built_in">document</span>.URL;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在写公司的后台管理系统，因为需求需要刷新后保持原来页面,原有的单页面组件跳转方式不能满足，所以在原有项目基础上增加了路由功能,目前比较简单的路由切换就是通过监听hash变化，实现不同页面的加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当 一个窗口地址的 hash （URL 中 # 后面的部分）改变时就会触发 hashchange 事件:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.onhashchange = handleHashChange;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.addEventListener(&lt;span class=&quot;string&quot;&gt;&quot;hashchange&quot;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;event&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//hash变化的处理逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
      <category term="hash" scheme="http://blog.haohome.top/tags/hash/"/>
    
      <category term="兼容性" scheme="http://blog.haohome.top/tags/%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>JS判断当前文本输入状态</title>
    <link href="http://blog.haohome.top/2018/08/28/Program/js%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E7%8A%B6%E6%80%81/"/>
    <id>http://blog.haohome.top/2018/08/28/Program/js判断当前文本输入状态/</id>
    <published>2018-08-27T16:00:00.000Z</published>
    <updated>2018-08-28T09:28:25.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在重构我的网址导航页面,这是我认识前端网页的启蒙项目,网上找的模板,然后修改链接、微调样式，成为了最初的网页导航1.0。</p></blockquote><p>在搜索的时候，我们需要按<code>Enter</code>键实现直接跳转搜索，因此添加了按键监听事件。但问题出现了:</p><ul><li><p>绑定<code>keyup</code>事件会将输入法中的英文文字输入到文字框并直接触发搜索按钮</p></li><li><p>单纯按键监听，并没有判断中文输入状态</p></li></ul><a id="more"></a><p>网上查了一些资料：</p><ol><li><p>键盘事件:<br>当一个键盘被按下并松开时,每个浏览器都会触发三个事件:<code>keydown、keypress、keyup</code><br><code>keydown</code>事件发生在按键被按下的时候，接着触发<code>keypress</code>，松开按键的时候触发<code>keyup</code>事件</p><p>还有一个事件就是<code>input</code>:input事件能够检测用户的每一次输入</p><p>以上事件在英文状态下没有问题,但在中文状态下,依然捕获到的是英文,如下图:</p><p><img src="https://haohome.top/18-8-28/85753032.jpg" alt="image"></p></li><li><p>中文输入法</p><blockquote><p><code>firfox</code>：输入触发<code>keydown</code>，回车确认输入触发<code>keyup</code><br><code>chrome</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入只触发<code>keydown</code><br><code>IE</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入触发<code>keydown</code>，<code>keyup</code><br><code>Safari</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入触发<code>keydown</code>，<code>keyup</code><br><code>opera</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入触发<code>keydown</code>，<code>keyup</code><br>在<code>input</code>、<code>textarea</code>中，中文输入法时：没有触发<code>keypress</code>事件<br><code>keypress</code>事件：对中文输入法支持不好，无法响应中文输入；无法响应系统功能键</p></blockquote></li></ol><iframe width="100%" height="300" src="//jsrun.net/bmgKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p><strong>解决方案</strong>:</p><ol><li><p>利用<code>change</code>事件:</p><p>监听输入框最终内容变化识别,当文本输入状态完成,并且<code>input</code>失去焦点再触发<code>enter</code>事件</p><blockquote><p>通常情况下,文本框中文输入状态时,按下回车会触发相应的按钮,此时<code>input</code>会失去焦点并触发<code>change</code>事件,此时将输入状态传给按钮事件,即可判断并执行相应事件</p></blockquote></li><li><p>利用<code>compositionstart</code>和<code>compositionend</code>事件(事件不兼容旧浏览器)</p><p><code>compositionstart</code>:事件触发于一段文字的输入之前</p><p><code>compositionend</code>事件:当文本段落的组成完成或取消时, <code>compositionend</code>事件将被激发</p><p>简单来说，非直接输入法如中文输入开始时，触发<code>compositionstart</code>事件，结束时触发<code>compositionend</code>事件</p><p>两类解决方案都可以监听到当前输入框的输入状态,结合input事件，就能对所有的输入进行实时的检测了</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doing=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> doSomething=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//我要干点啥</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'testInput'</span>).addEventListener(<span class="string">'compositionstart'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    doing=<span class="literal">true</span>;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'testInput'</span>).addEventListener(<span class="string">'input'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!doing)&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'testInput'</span>).addEventListener(<span class="string">'compositionend'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    doing=<span class="literal">false</span>;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近在重构我的网址导航页面,这是我认识前端网页的启蒙项目,网上找的模板,然后修改链接、微调样式，成为了最初的网页导航1.0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在搜索的时候，我们需要按&lt;code&gt;Enter&lt;/code&gt;键实现直接跳转搜索，因此添加了按键监听事件。但问题出现了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;绑定&lt;code&gt;keyup&lt;/code&gt;事件会将输入法中的英文文字输入到文字框并直接触发搜索按钮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;单纯按键监听，并没有判断中文输入状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
      <category term="input" scheme="http://blog.haohome.top/tags/input/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收机制与内存管理</title>
    <link href="http://blog.haohome.top/2018/07/11/JavaScript/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.haohome.top/2018/07/11/JavaScript/垃圾回收机制与内存管理/</id>
    <published>2018-07-10T16:00:00.000Z</published>
    <updated>2018-07-18T15:02:39.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-垃圾回收机制"><a href="#1-垃圾回收机制" class="headerlink" title="1. 垃圾回收机制"></a>1. 垃圾回收机制</h2><p>JavaScript是一门高级语言,具有自动垃圾回收机制(Garbage Collecatio), js创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放,其主要原理为:</p><blockquote><p> 垃圾收集器会<strong>定期（周期性）</strong>找出那些不在继续使用的变量，然后释放其内存。</p></blockquote><p>JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照<strong>固定的时间间隔周期性的执行</strong>。</p><ul><li>任何程序语言,内存生命周期都是一致的:<ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放/归还 </li></ol></li></ul><a id="more"></a><p><strong>JavaScript的内存分配</strong></p><ol><li><p>在<strong>定义变量时就完成了内存分配</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"hello"</span>; <span class="comment">// 给字符串分配内存</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></span><br></pre></td></tr></table></figure></li><li><p>通过函数调用分配内存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 分配一个 Date 对象</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// 分配一个 DOM 元素</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>当内存不再需要使用时释放</strong></p><p>不再使用的变量也就是内存生命周期的结束,只可能是局部变量,局部变量只在函数的执行过程中存在,<strong>全局变量的生命周期直至浏览器卸载页面才会结束</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'hanzichi'</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'hanzichi'</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = fn1();</span><br><span class="line"><span class="keyword">var</span> b = fn2();</span><br></pre></td></tr></table></figure><blockquote><p>上面定义了两个function，分别叫做fn1和fn2:</p><ul><li>当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象<code>{name: &#39;hanzichi&#39;, age: 10}</code>,当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；</li><li>在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。</li></ul></blockquote><p>所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，垃圾回收算法主要依赖于引用的概念。</p><blockquote><p>在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。</p><p>例如:一个Javascript对象具有对它<a href="https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">原型</a>的引用（隐式引用）和对它属性的引用（显式引用）。</p></blockquote><h3 id="1-1-标记清除"><a href="#1-1-标记清除" class="headerlink" title="1.1 标记清除"></a>1.1 标记清除</h3><p>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span> ;    <span class="comment">//被标记 ，进入环境  </span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span> ;    <span class="comment">//被标记 ，进入环境</span></span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//执行完毕 之后 a、b又被标离开环境，被回收。</span></span><br></pre></td></tr></table></figure><h3 id="1-2-引用计数"><a href="#1-2-引用计数" class="headerlink" title="1.2 引用计数"></a>1.2 引用计数</h3><p>引用计数的含义是跟踪记录每个值被引用的次数。</p><p>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = &#123;&#125; ; <span class="comment">//a的引用次数为0 </span></span><br><span class="line">    <span class="keyword">var</span> b = a ; <span class="comment">//a的引用次数加1，为1 </span></span><br><span class="line">    <span class="keyword">var</span> c =a; <span class="comment">//a的引用次数再加1，为2</span></span><br><span class="line">    <span class="keyword">var</span> b =&#123;&#125;; <span class="comment">//a的引用次数减1，为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 引用计数这种方式在老式浏览器中采用,在循环引用是会出现<strong>内存泄露</strong>问题:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">  a.pro = b;</span><br><span class="line">  b.pro = a;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><ul><li>标记清除: fn()执行完毕后，两个对象都已经离开环境,内存回收;</li><li>引用计数: fn()执行完毕后,a和b的引用次数都是2,不会被垃圾回收器回收内存;如果fn函数被大量调用，就会造成<strong>内存泄露</strong>。(在IE7与IE8上，内存直线上升)</li></ul><p>IE中有一部分对象并不是原生js对象。例如，其<strong>内存泄露</strong>DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使<strong>IE的js引擎采用标记清除策略</strong>来实现，但js访问的<strong>COM对象依然是基于引用计数策略</strong>的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">"element"</span>);</span><br><span class="line">    obj.onclick=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>obj</code>引用了<code>document.getElementById(“element”)</code>，而<code>document.getElementById(“element”)</code>的onclick方法会引用外部环境中德变量，自然也包括obj，是不是很隐蔽?</p><p>最简单的方式就是自己手工解除循环引用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">"element"</span>);</span><br><span class="line">   obj.onclick=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">   obj=<span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变</p></blockquote><h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h2><h3 id="2-1-合理的方案"><a href="#2-1-合理的方案" class="headerlink" title="2.1 合理的方案"></a>2.1 合理的方案</h3><p>当前比较合理的方案是标记清除:</p><blockquote><ol><li>遍历所有可访问的对象;</li><li>回收已不可访问的对象</li></ol></blockquote><h3 id="2-2-GC的缺陷"><a href="#2-2-GC的缺陷" class="headerlink" title="2.2 GC的缺陷"></a>2.2 GC的缺陷</h3><p>和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-垃圾回收机制&quot;&gt;&lt;a href=&quot;#1-垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;1. 垃圾回收机制&quot;&gt;&lt;/a&gt;1. 垃圾回收机制&lt;/h2&gt;&lt;p&gt;JavaScript是一门高级语言,具有自动垃圾回收机制(Garbage Collecatio), js创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放,其主要原理为:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 垃圾收集器会&lt;strong&gt;定期（周期性）&lt;/strong&gt;找出那些不在继续使用的变量，然后释放其内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照&lt;strong&gt;固定的时间间隔周期性的执行&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何程序语言,内存生命周期都是一致的:&lt;ol&gt;
&lt;li&gt;分配你所需要的内存&lt;/li&gt;
&lt;li&gt;使用分配到的内存（读、写）&lt;/li&gt;
&lt;li&gt;不需要时将其释放/归还 &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="你不知道的JavaScript" scheme="http://blog.haohome.top/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>点击事件重复请求</title>
    <link href="http://blog.haohome.top/2018/05/29/JavaScript/%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/"/>
    <id>http://blog.haohome.top/2018/05/29/JavaScript/点击事件重复请求/</id>
    <published>2018-05-28T16:00:00.000Z</published>
    <updated>2018-05-30T13:27:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>当我们针对某个按钮绑定点击事件后，就可以随时通过点击鼠标来触发按钮的点击事件，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">$(<span class="string">'ele'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">num++;</span><br><span class="line">    <span class="comment">//执行的业务逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样num值会不断增加，依赖于num值的业务逻辑就会出错；<br>一般出现的场景有：</p><blockquote><ol><li>ajax请求;</li><li>问卷答题</li></ol></blockquote><p>接下来我们根据这些场景来分析下;</p><a id="more"></a><h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><h3 id="1-ajax提交"><a href="#1-ajax提交" class="headerlink" title="1. ajax提交"></a>1. ajax提交</h3><iframe width="100%" height="200px" src="//jsrun.net/ejZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>当用户短时间内重复点击登录按钮时,会触发多次的表单提交;<br>解决方案: 当点击提交按钮后,给按钮添加disabled属性,事件完成后再<code>removeAttr(&#39;disabled&#39;)</code></p><iframe width="100%" height="200px" src="//jsrun.net/tjZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><h3 id="2-问卷答题"><a href="#2-问卷答题" class="headerlink" title="2. 问卷答题"></a>2. 问卷答题</h3><iframe width="100%" height="200px" src="//jsrun.net/RjZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>当选择一个答案时,重复点击,机会造成num重复增加,可能会造成中间某些选题未答直接跳到后面的答题，而添加一个name数组判断是否重复就可以避免该问题;</p><iframe width="100%" height="200px" src="//jsrun.net/rjZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决重复点击问题可以归结为标记作用位点，有两种方法:</p><ol><li>点击触发请求后，作用点设为disabled属性，请求（或者包括请求后具体的业务流程处理）后，移除disabled属性；</li><li>记录作用点，判断作用点是否重复，重复则直接return</li></ol><p>其实ajax还有一个更好的方法来避免重复提交,我们知道js是单线程执行事件的,所以可以根据此原理定义事件序列，重新封装ajax方法来避免。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;当我们针对某个按钮绑定点击事件后，就可以随时通过点击鼠标来触发按钮的点击事件，如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;&#39;ele&#39;&lt;/span&gt;).on(&lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	num++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//执行的业务逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样num值会不断增加，依赖于num值的业务逻辑就会出错；&lt;br&gt;一般出现的场景有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;ajax请求;&lt;/li&gt;
&lt;li&gt;问卷答题&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们根据这些场景来分析下;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
      <category term="event" scheme="http://blog.haohome.top/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>Vuex入门基础</title>
    <link href="http://blog.haohome.top/2018/05/14/JavaScript/Vuex%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.haohome.top/2018/05/14/JavaScript/Vuex入门基础/</id>
    <published>2018-05-13T16:00:00.000Z</published>
    <updated>2018-05-15T13:58:59.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Vuex-概念"><a href="#1-Vuex-概念" class="headerlink" title="1. Vuex 概念"></a>1. Vuex 概念</h2><p>Vuex 是一个<strong>状态管理模式</strong>,它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>每一个 Vuex 应用的核心就是 store(仓库)，在store中包含组件中的共享<strong>状态</strong><code>state</code>和改变状态的<strong>方法</strong><code>mutations</code>。</p><p><strong>store仓库</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>1) Vuex 的状态存储是响应式的<br>2) 不能直接改变 store 中的状态,需显式地<strong>提交 (commit) mutation</strong></p></blockquote><a id="more"></a><h2 id="2-State单一状态树"><a href="#2-State单一状态树" class="headerlink" title="2. State单一状态树"></a>2. State单一状态树</h2><p>用一个对象包含全部的应用层级状态</p><p>Vuex 通过 <code>store</code> 选项，将状态从根组件“注入”到每一个子组件中,子组件需调用 <code>Vue.use(Vuex)</code>：</p><p>根组件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根组件:</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store, <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>子组件: 通过<code>computed</code>(计算属性)返回<code>this.$store.state.count</code>来获取相应数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count<span class="comment">//获取根组件的state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h3><p>简化生成计算属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    computed: mapState (&#123;</span><br><span class="line">        count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line">        countAlias: <span class="string">'count'</span>,    <span class="comment">// 别名 `count` 等价于 state =&gt; state.count</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以更简化:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">'count'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="3-Getter-从-store-中的-state-派生出状态"><a href="#3-Getter-从-store-中的-state-派生出状态" class="headerlink" title="3. Getter 从 store 中的 state 派生出状态"></a>3. Getter 从 store 中的 state 派生出状态</h2><p>如果我们需要对<code>state</code>对象进行做处理计算，如对列表进行过滤并计数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    doneTodosCount () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多个组件都要进行这样的处理，那么就要在多个组件中复制该函数,这样效率低下。</p><p>Vuex中<code>getters</code>对象，可以方便我们在<code>store</code>中做集中的处理,Getters接受<code>state</code>作为第一个参数：:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Getter 会暴露为 <code>store.getters</code> 对象，可以以属性的形式访问这些值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span></span><br></pre></td></tr></table></figure><p>Getter 也可以接受其他 getter 作为第二个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.getters.doneTodosCount <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="mapGetters辅助函数"><a href="#mapGetters辅助函数" class="headerlink" title="mapGetters辅助函数"></a>mapGetters辅助函数</h3><p>与<code>mapState</code>类似，都能达到简化代码的效果<br><code>mapGetters</code>辅助函数仅仅是将store中的getters映射到局部计算属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 使用对象展开运算符将 getters 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">'doneTodosCount'</span>,</span><br><span class="line">      <span class="string">'anotherGetter'</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可写作:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: mapGetters([</span><br><span class="line">    <span class="string">'doneTodosCount'</span>,</span><br><span class="line">    <span class="string">'anotherGetter'</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>所以在Vue的<code>computed</code>计算属性中会存在两种辅助函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    computed: &#123;</span><br><span class="line">        mapState(&#123; ... &#125;),</span><br><span class="line">        mapGetter(&#123; ... &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Mutation-更改-Vuex-的-store-中的状态"><a href="#4-Mutation-更改-Vuex-的-store-中的状态" class="headerlink" title="4. Mutation 更改 Vuex 的 store 中的状态"></a>4. Mutation 更改 Vuex 的 store 中的状态</h2><p>每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;<span class="comment">//type:'increment'</span></span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>要唤醒一个 mutation handler，你需要调用 <strong>store.commit</strong> 方法调用<code>mutation type</code>: <code>store.commit(&#39;increment&#39;)</code></p><h3 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h3><p> 向 <code>store.commit</code> 传入第二个参数,也就是mutation的<code>payload</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>单单传入一个<code>n</code>，可能并不能满足我们的业务需要，这时候我们可以选择传入一个<code>payload</code>对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutation: &#123;</span><br><span class="line">    increment (state, payload) &#123;</span><br><span class="line">        state.totalPrice += payload.price + payload.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h3><p>提交 mutation 的另一种方式是直接使用包含 <code>type</code> 属性的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="mapMutations函数"><a href="#mapMutations函数" class="headerlink" title="mapMutations函数"></a>mapMutations函数</h3><p>使用<code>mapMutations</code>辅助函数将组件中的<code>methods</code>映射为<code>store.commit</code>调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">'increment'</span> <span class="comment">// 映射 this.increment() 为 this.$store.commit('increment')</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 映射 this.add() 为 this.$store.commit('increment')</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Action"><a href="#5-Action" class="headerlink" title="5.Action"></a>5.Action</h2><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><p>在vuex中,mutation是同步事件:<code>store.commit(&#39;increment&#39;)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p><h3 id="分发Action"><a href="#分发Action" class="headerlink" title="分发Action"></a>分发Action</h3><p>Action 通过 <code>store.dispatch</code> 方法触发：<code>store.dispatch(&#39;increment&#39;)</code>;</p><p>Actions 支持同样的载荷方式和对象方式进行分发：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'incrementAsync'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="在组件中分发Action"><a href="#在组件中分发Action" class="headerlink" title="在组件中分发Action"></a>在组件中分发Action</h3><p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h3><p>Action 通常是异步的，如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p><p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在另外一个 action 中也可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们利用 <a href="https://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="noopener">async / await</a>，我们可以如下组合 action：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Vuex-概念&quot;&gt;&lt;a href=&quot;#1-Vuex-概念&quot; class=&quot;headerlink&quot; title=&quot;1. Vuex 概念&quot;&gt;&lt;/a&gt;1. Vuex 概念&lt;/h2&gt;&lt;p&gt;Vuex 是一个&lt;strong&gt;状态管理模式&lt;/strong&gt;,它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&lt;/p&gt;
&lt;p&gt;每一个 Vuex 应用的核心就是 store(仓库)，在store中包含组件中的共享&lt;strong&gt;状态&lt;/strong&gt;&lt;code&gt;state&lt;/code&gt;和改变状态的&lt;strong&gt;方法&lt;/strong&gt;&lt;code&gt;mutations&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;store仓库&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Vue &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;vue&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Vuex &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;vuex&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Vue.use(Vuex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; store = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Vuex.Store(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    state: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mutations: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        increment (state) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            state.count++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;1) Vuex 的状态存储是响应式的&lt;br&gt;2) 不能直接改变 store 中的状态,需显式地&lt;strong&gt;提交 (commit) mutation&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
      <category term="vue" scheme="http://blog.haohome.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Node.js的web服务器路由重构</title>
    <link href="http://blog.haohome.top/2018/05/02/JavaScript/Node.js%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B7%AF%E7%94%B1%E9%87%8D%E6%9E%84/"/>
    <id>http://blog.haohome.top/2018/05/02/JavaScript/Node.js的web服务器路由重构/</id>
    <published>2018-05-02T15:32:00.000Z</published>
    <updated>2018-05-04T13:38:57.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://haohome.top/18-5-3/35609573.jpg" width="40%"></p><p>Node使JavaScript操作服务器成为可能，同时其带来了强大的文件操作方法。我们在创建一个服务器时，会遇到路由切换的问题，当前express等库是可以识别不同路由并执行不同操作的，最近在回顾Node.js的一些用法，这里就尝试采用原生的方法重构一个路由功能。</p><p>原始路由方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> server=http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(req.url==<span class="string">'/index'</span>)&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    res.write(<span class="string">'&lt;h1&gt;这是首页&lt;/h1&gt;'</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.url==<span class="string">'/products'</span>)&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    res.write(<span class="string">'&lt;h1&gt;这是产品页&lt;/h1&gt;'</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.url==<span class="string">'/detail'</span>)&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    res.write(<span class="string">'&lt;h1&gt;这是详情页&lt;/h1&gt;'</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">404</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    res.write(<span class="string">'&lt;h1&gt;这是404页&lt;/h1&gt;'</span>)</span><br><span class="line">  res.end(<span class="string">'欢迎来到NodeJs'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始监听3000端口'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>这样的路由方法看似结构清晰，但实际情况比这复杂的多，有大量的路由和相应的页面响应方法，就会显得臃肿了。</p><p>其实，我们可以采用ES6的模块语法，使创建服务器、路由控制、地址处理方法执行分别处于不同模块，最终在一个入口文件中引入：</p><p>服务器模块:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="comment">//1.http创建服务器并监听端口方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startServer</span>(<span class="params">route,handle</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> onRequest=<span class="function"><span class="keyword">function</span>(<span class="params">req,resp</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//路由处理</span></span><br><span class="line">    route(handle,req.url,resp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//http创建服务器</span></span><br><span class="line">  <span class="keyword">var</span> server= http.createServer(onRequest)</span><br><span class="line">  <span class="comment">//服务器监听3000端口</span></span><br><span class="line">  server.listen(<span class="number">3000</span>,<span class="string">'127.0.0.1'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'运行在3000端口'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.导出路由模块</span></span><br><span class="line"><span class="built_in">module</span>.exports.startServer = startServer;</span><br></pre></td></tr></table></figure><p>地址处理方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">//网站默认图标</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">favicon</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">'/favicon.ico'</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首页</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">'/index.html'</span>,<span class="string">'utf8'</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品页</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">products</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">'/products.html'</span>,<span class="string">'utf8'</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//详情页</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detail</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">'/detail.html'</span>,<span class="string">'utf8'</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将不同页面的方法导出</span></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">  index:index,</span><br><span class="line">  products:products,</span><br><span class="line">  detail:detail,</span><br><span class="line">  favicon:favicon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由模块:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">//1.路由处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle,url,resp</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> handle[url] ===<span class="string">'function'</span>)&#123;</span><br><span class="line">    resp.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    handle[url](resp);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    resp.writeHead(<span class="number">404</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    fs.createReadStream(__dirname+<span class="string">'/404.html'</span>,<span class="string">'utf8'</span>).pipe(resp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.route=route;</span><br></pre></td></tr></table></figure><p>入口app.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server=<span class="built_in">require</span>(<span class="string">'./server'</span>);</span><br><span class="line"><span class="keyword">var</span> router=<span class="built_in">require</span>(<span class="string">'./router'</span>)</span><br><span class="line"><span class="keyword">var</span> handler = <span class="built_in">require</span>(<span class="string">'./handler'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.匹配url地址,</span></span><br><span class="line"><span class="keyword">var</span> handle = &#123;&#125;;</span><br><span class="line">handle[<span class="string">"/"</span>] = handler.index;</span><br><span class="line">handle[<span class="string">'/index'</span>] = handler.index;</span><br><span class="line">handle[<span class="string">'/products'</span>] = handler.products;</span><br><span class="line">handle[<span class="string">'/detail'</span>] = handler.detail;</span><br><span class="line">handle[<span class="string">'/favicon.ico'</span>] = handler.favicon;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.启动服务器</span></span><br><span class="line">server.startServer(router.route,handle)</span><br></pre></td></tr></table></figure><p>这样如果增加路由页面，只需在相应的位置依次增加即可，结构清晰！</p><p>当使用GET或POST请求时，需要对服务器模块做一些更改:</p><ol><li>请求为GET时,解析路由地址’?’后面的query语句;</li><li>请求为POST时,监听数据流并解析;</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> queryString=<span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startServer</span>(<span class="params">route,handle</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> onRequest=<span class="function"><span class="keyword">function</span>(<span class="params">req,resp</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//url路径</span></span><br><span class="line">    <span class="keyword">var</span> pathName=url.parse(req.url).pathname;</span><br><span class="line">    <span class="comment">//请求为POST时,监听数据流</span></span><br><span class="line">    <span class="keyword">if</span>(req.method==<span class="string">"POST"</span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> data=<span class="string">""</span>;</span><br><span class="line">      req.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;).on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        data+=chunk;</span><br><span class="line">      &#125;).on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> params=queryString.parse(data);</span><br><span class="line">      route(handle,pathName,resp,params);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求为GET时,解析路由query</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> params=url.parse(req.url,<span class="literal">true</span>).query;</span><br><span class="line">      route(handle,pathName,resp,params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> server= http.createServer(onRequest)</span><br><span class="line">  server.listen(<span class="number">3000</span>,<span class="string">'127.0.0.1'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'运行在3000端口'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.startServer = startServer;</span><br></pre></td></tr></table></figure><p>相应的，增加router和handler的传参。</p><p>详细代码：<a href="https://github.com/yifoo/Node/tree/master/Demo-web" target="_blank" rel="noopener">Demo-web</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://haohome.top/18-5-3/35609573.jpg&quot; width=&quot;40%&quot;&gt;&lt;/p&gt;
&lt;p&gt;Node使JavaScript操作服务器成为可能，同时其带来了强大的文件操作方法。我们在创建一个服务器时，会遇到路由切换的问题，当前express等库是可以识别不同路由并执行不同操作的，最近在回顾Node.js的一些用法，这里就尝试采用原生的方法重构一个路由功能。&lt;/p&gt;
&lt;p&gt;原始路由方法：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; http=&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;http&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fs=&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fs&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; server=http.createServer(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;req,res&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(req.url==&lt;span class=&quot;string&quot;&gt;&#39;/index&#39;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.writeHead(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;text/html;charset=UTF-8&#39;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.write(&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;h1&amp;gt;这是首页&amp;lt;/h1&amp;gt;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(req.url==&lt;span class=&quot;string&quot;&gt;&#39;/products&#39;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.writeHead(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;text/html;charset=UTF-8&#39;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.write(&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;h1&amp;gt;这是产品页&amp;lt;/h1&amp;gt;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(req.url==&lt;span class=&quot;string&quot;&gt;&#39;/detail&#39;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.writeHead(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;text/html;charset=UTF-8&#39;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.write(&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;h1&amp;gt;这是详情页&amp;lt;/h1&amp;gt;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.writeHead(&lt;span class=&quot;number&quot;&gt;404&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;text/html;charset=UTF-8&#39;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.write(&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;h1&amp;gt;这是404页&amp;lt;/h1&amp;gt;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  res.end(&lt;span class=&quot;string&quot;&gt;&#39;欢迎来到NodeJs&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server.listen(&lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;开始监听3000端口&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="node" scheme="http://blog.haohome.top/tags/node/"/>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
  </entry>
  
</feed>
