<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>靖风行&#39;S blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.haohome.top/"/>
  <updated>2018-08-28T02:22:29.386Z</updated>
  <id>http://blog.haohome.top/</id>
  
  <author>
    <name>Daniel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS判断当前文本输入状态</title>
    <link href="http://blog.haohome.top/2018/08/28/Program/js%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E6%96%87%E6%9C%AC%E8%BE%93%E5%85%A5%E7%8A%B6%E6%80%81/"/>
    <id>http://blog.haohome.top/2018/08/28/Program/js判断当前文本输入状态/</id>
    <published>2018-08-27T16:00:00.000Z</published>
    <updated>2018-08-28T02:22:29.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近在重构我的网址导航页面,这是我认识前端网页的启蒙项目,网上找的模板,然后修改链接、微调样式，成为了最初的网页导航1.0。</p></blockquote><p>在搜索的时候，我们需要按<code>Enter</code>键实现直接跳转搜索，因此添加了按键监听事件。但问题出现了:</p><ul><li><p>绑定<code>keyup</code>事件会将输入法中的英文文字输入到文字框并直接触发搜索按钮</p></li><li><p>单纯按键监听，并没有判断中文输入状态</p></li></ul><p>网上查了一些资料：</p><ol><li><p>键盘事件:<br>当一个键盘被按下并松开时,每个浏览器都会触发三个事件:<code>keydown、keypress、keyup</code><br><code>keydown</code>事件发生在按键被按下的时候，接着触发<code>keypress</code>，松开按键的时候触发<code>keyup</code>事件</p><p>还有一个事件就是<code>input</code>:input事件能够检测用户的每一次输入</p><p>以上事件在英文状态下没有问题,但在中文状态下,依然捕获到的是英文,如下图:</p><p><img src="https://haohome.top/18-8-28/85753032.jpg" alt="image"></p></li><li><p>中文输入法</p><blockquote><p><code>firfox</code>：输入触发<code>keydown</code>，回车确认输入触发<code>keyup</code><br><code>chrome</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入只触发<code>keydown</code><br><code>IE</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入触发<code>keydown</code>，<code>keyup</code><br><code>Safari</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入触发<code>keydown</code>，<code>keyup</code><br><code>opera</code>：输入触发<code>keydown</code>、<code>keyup</code>，回车确认输入触发<code>keydown</code>，<code>keyup</code><br>在<code>input</code>、<code>textarea</code>中，中文输入法时：没有触发<code>keypress</code>事件<br><code>keypress</code>事件：对中文输入法支持不好，无法响应中文输入；无法响应系统功能键</p></blockquote></li></ol><iframe width="100%" height="300" src="//jsrun.net/bmgKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p><strong>解决方案</strong>:</p><ol><li><p>利用<code>change</code>事件:</p><p>监听输入框最终内容变化识别,当文本输入状态完成,并且<code>input</code>失去焦点再触发<code>enter</code>事件</p><blockquote><p>通常情况下,文本框中文输入状态时,按下回车会触发相应的按钮,此时<code>input</code>会失去焦点并触发<code>change</code>事件,此时将输入状态传给按钮事件,即可判断并执行相应事件</p></blockquote></li><li><p>利用<code>compositionstart</code>和<code>compositionend</code>事件(事件不兼容旧浏览器)</p><p><code>compositionstart</code>:事件触发于一段文字的输入之前</p><p><code>compositionend</code>事件:当文本段落的组成完成或取消时, <code>compositionend</code>事件将被激发</p><p>简单来说，非直接输入法如中文输入开始时，触发<code>compositionstart</code>事件，结束时触发<code>compositionend</code>事件</p><p>两类解决方案都可以监听到当前输入框的输入状态,结合input事件，就能对所有的输入进行实时的检测了</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> doing=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> doSomething=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//我要干点啥</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'testInput'</span>).addEventListener(<span class="string">'compositionstart'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    doing=<span class="literal">true</span>;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'testInput'</span>).addEventListener(<span class="string">'input'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!doing)&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'testInput'</span>).addEventListener(<span class="string">'compositionend'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    doing=<span class="literal">false</span>;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;,<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;最近在重构我的网址导航页面,这是我认识前端网页的启蒙项目,网上找的模板,然后修改链接、微调样式，成为了最初的网页导航1.0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在搜索的时候，我们需要按&lt;code&gt;Enter&lt;/code&gt;键实现直接跳转搜索，
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
      <category term="input" scheme="http://blog.haohome.top/tags/input/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收机制与内存管理</title>
    <link href="http://blog.haohome.top/2018/07/11/JavaScript/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E4%B8%8E%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://blog.haohome.top/2018/07/11/JavaScript/垃圾回收机制与内存管理/</id>
    <published>2018-07-10T16:00:00.000Z</published>
    <updated>2018-07-18T15:02:39.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-垃圾回收机制"><a href="#1-垃圾回收机制" class="headerlink" title="1. 垃圾回收机制"></a>1. 垃圾回收机制</h2><p>JavaScript是一门高级语言,具有自动垃圾回收机制(Garbage Collecatio), js创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放,其主要原理为:</p><blockquote><p> 垃圾收集器会<strong>定期（周期性）</strong>找出那些不在继续使用的变量，然后释放其内存。</p></blockquote><p>JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照<strong>固定的时间间隔周期性的执行</strong>。</p><ul><li>任何程序语言,内存生命周期都是一致的:<ol><li>分配你所需要的内存</li><li>使用分配到的内存（读、写）</li><li>不需要时将其释放/归还 </li></ol></li></ul><a id="more"></a><p><strong>JavaScript的内存分配</strong></p><ol><li><p>在<strong>定义变量时就完成了内存分配</strong>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">"hello"</span>; <span class="comment">// 给字符串分配内存</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></span><br></pre></td></tr></table></figure></li><li><p>通过函数调用分配内存</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); <span class="comment">// 分配一个 Date 对象</span></span><br><span class="line"><span class="keyword">var</span> e = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); <span class="comment">// 分配一个 DOM 元素</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>当内存不再需要使用时释放</strong></p><p>不再使用的变量也就是内存生命周期的结束,只可能是局部变量,局部变量只在函数的执行过程中存在,<strong>全局变量的生命周期直至浏览器卸载页面才会结束</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;<span class="attr">name</span>: <span class="string">'hanzichi'</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;<span class="attr">name</span>:<span class="string">'hanzichi'</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = fn1();</span><br><span class="line"><span class="keyword">var</span> b = fn2();</span><br></pre></td></tr></table></figure><blockquote><p>上面定义了两个function，分别叫做fn1和fn2:</p><ul><li>当fn1被调用时，进入fn1的环境，会开辟一块内存存放对象<code>{name: &#39;hanzichi&#39;, age: 10}</code>,当调用结束后，出了fn1的环境，那么该块内存会被js引擎中的垃圾回收器自动释放；</li><li>在fn2被调用的过程中，返回的对象被全局变量b所指向，所以该块内存并不会被释放。</li></ul></blockquote><p>所以垃圾收集器必须跟踪到底哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存，垃圾回收算法主要依赖于引用的概念。</p><blockquote><p>在内存管理的环境中，一个对象如果有访问另一个对象的权限（隐式或者显式），叫做一个对象引用另一个对象。</p><p>例如:一个Javascript对象具有对它<a href="https://developer.mozilla.org/en/JavaScript/Guide/Inheritance_and_the_prototype_chain" target="_blank" rel="noopener">原型</a>的引用（隐式引用）和对它属性的引用（显式引用）。</p></blockquote><h3 id="1-1-标记清除"><a href="#1-1-标记清除" class="headerlink" title="1.1 标记清除"></a>1.1 标记清除</h3><p>这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">10</span> ;    <span class="comment">//被标记 ，进入环境  </span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span> ;    <span class="comment">//被标记 ，进入环境</span></span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//执行完毕 之后 a、b又被标离开环境，被回收。</span></span><br></pre></td></tr></table></figure><h3 id="1-2-引用计数"><a href="#1-2-引用计数" class="headerlink" title="1.2 引用计数"></a>1.2 引用计数</h3><p>引用计数的含义是跟踪记录每个值被引用的次数。</p><p>当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = &#123;&#125; ; <span class="comment">//a的引用次数为0 </span></span><br><span class="line">    <span class="keyword">var</span> b = a ; <span class="comment">//a的引用次数加1，为1 </span></span><br><span class="line">    <span class="keyword">var</span> c =a; <span class="comment">//a的引用次数再加1，为2</span></span><br><span class="line">    <span class="keyword">var</span> b =&#123;&#125;; <span class="comment">//a的引用次数减1，为1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 引用计数这种方式在老式浏览器中采用,在循环引用是会出现<strong>内存泄露</strong>问题:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> b = &#123;&#125;;</span><br><span class="line">  a.pro = b;</span><br><span class="line">  b.pro = a;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><ul><li>标记清除: fn()执行完毕后，两个对象都已经离开环境,内存回收;</li><li>引用计数: fn()执行完毕后,a和b的引用次数都是2,不会被垃圾回收器回收内存;如果fn函数被大量调用，就会造成<strong>内存泄露</strong>。(在IE7与IE8上，内存直线上升)</li></ul><p>IE中有一部分对象并不是原生js对象。例如，其<strong>内存泄露</strong>DOM和BOM中的对象就是使用C++以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数策略。因此，即使<strong>IE的js引擎采用标记清除策略</strong>来实现，但js访问的<strong>COM对象依然是基于引用计数策略</strong>的。换句话说，只要在IE中涉及COM对象，就会存在循环引用的问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">"element"</span>);</span><br><span class="line">    obj.onclick=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>obj</code>引用了<code>document.getElementById(“element”)</code>，而<code>document.getElementById(“element”)</code>的onclick方法会引用外部环境中德变量，自然也包括obj，是不是很隐蔽?</p><p>最简单的方式就是自己手工解除循环引用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> <span class="title">outerFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">   <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(<span class="string">"element"</span>);</span><br><span class="line">   obj.onclick=<span class="function"><span class="keyword">function</span> <span class="title">innerFunction</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">   obj=<span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>IE9+并不存在循环引用导致Dom内存泄露问题，可能是微软做了优化，或者Dom的回收方式已经改变</p></blockquote><h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2. 内存管理"></a>2. 内存管理</h2><h3 id="2-1-合理的方案"><a href="#2-1-合理的方案" class="headerlink" title="2.1 合理的方案"></a>2.1 合理的方案</h3><p>当前比较合理的方案是标记清除:</p><blockquote><ol><li>遍历所有可访问的对象;</li><li>回收已不可访问的对象</li></ol></blockquote><h3 id="2-2-GC的缺陷"><a href="#2-2-GC的缺陷" class="headerlink" title="2.2 GC的缺陷"></a>2.2 GC的缺陷</h3><p>和其他语言一样，javascript的GC策略也无法避免一个问题：GC时，停止响应其他操作，这是为了安全考虑。而Javascript的GC在100ms甚至以上，对一般的应用还好，但对于JS游戏，动画对连贯性要求比较高的应用，就麻烦了。这就是新引擎需要优化的点：避免GC造成的长时间停止响应。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-垃圾回收机制&quot;&gt;&lt;a href=&quot;#1-垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;1. 垃圾回收机制&quot;&gt;&lt;/a&gt;1. 垃圾回收机制&lt;/h2&gt;&lt;p&gt;JavaScript是一门高级语言,具有自动垃圾回收机制(Garbage Collecatio), js创建变量（对象，字符串等）时分配内存，并且在不再使用它们时“自动”释放,其主要原理为:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 垃圾收集器会&lt;strong&gt;定期（周期性）&lt;/strong&gt;找出那些不在继续使用的变量，然后释放其内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照&lt;strong&gt;固定的时间间隔周期性的执行&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;任何程序语言,内存生命周期都是一致的:&lt;ol&gt;
&lt;li&gt;分配你所需要的内存&lt;/li&gt;
&lt;li&gt;使用分配到的内存（读、写）&lt;/li&gt;
&lt;li&gt;不需要时将其释放/归还 &lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="你不知道的JavaScript" scheme="http://blog.haohome.top/tags/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>点击事件重复请求</title>
    <link href="http://blog.haohome.top/2018/05/29/JavaScript/%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82/"/>
    <id>http://blog.haohome.top/2018/05/29/JavaScript/点击事件重复请求/</id>
    <published>2018-05-28T16:00:00.000Z</published>
    <updated>2018-05-30T13:27:34.623Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>当我们针对某个按钮绑定点击事件后，就可以随时通过点击鼠标来触发按钮的点击事件，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">$(<span class="string">'ele'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">num++;</span><br><span class="line">    <span class="comment">//执行的业务逻辑</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样num值会不断增加，依赖于num值的业务逻辑就会出错；<br>一般出现的场景有：</p><blockquote><ol><li>ajax请求;</li><li>问卷答题</li></ol></blockquote><p>接下来我们根据这些场景来分析下;</p><a id="more"></a><h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><h3 id="1-ajax提交"><a href="#1-ajax提交" class="headerlink" title="1. ajax提交"></a>1. ajax提交</h3><iframe width="100%" height="200px" src="//jsrun.net/ejZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>当用户短时间内重复点击登录按钮时,会触发多次的表单提交;<br>解决方案: 当点击提交按钮后,给按钮添加disabled属性,事件完成后再<code>removeAttr(&#39;disabled&#39;)</code></p><iframe width="100%" height="200px" src="//jsrun.net/tjZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><h3 id="2-问卷答题"><a href="#2-问卷答题" class="headerlink" title="2. 问卷答题"></a>2. 问卷答题</h3><iframe width="100%" height="200px" src="//jsrun.net/RjZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><p>当选择一个答案时,重复点击,机会造成num重复增加,可能会造成中间某些选题未答直接跳到后面的答题，而添加一个name数组判断是否重复就可以避免该问题;</p><iframe width="100%" height="200px" src="//jsrun.net/rjZKp/embedded/all/light/" allowfullscreen="allowfullscreen" frameborder="0"></iframe><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解决重复点击问题可以归结为标记作用位点，有两种方法:</p><ol><li>点击触发请求后，作用点设为disabled属性，请求（或者包括请求后具体的业务流程处理）后，移除disabled属性；</li><li>记录作用点，判断作用点是否重复，重复则直接return</li></ol><p>其实ajax还有一个更好的方法来避免重复提交,我们知道js是单线程执行事件的,所以可以根据此原理定义事件序列，重新封装ajax方法来避免。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;当我们针对某个按钮绑定点击事件后，就可以随时通过点击鼠标来触发按钮的点击事件，如：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; num = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;$(&lt;span class=&quot;string&quot;&gt;&#39;ele&#39;&lt;/span&gt;).on(&lt;span class=&quot;string&quot;&gt;&#39;click&#39;&lt;/span&gt;,&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	num++;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;//执行的业务逻辑&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这样num值会不断增加，依赖于num值的业务逻辑就会出错；&lt;br&gt;一般出现的场景有：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;ajax请求;&lt;/li&gt;
&lt;li&gt;问卷答题&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来我们根据这些场景来分析下;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
      <category term="event" scheme="http://blog.haohome.top/tags/event/"/>
    
  </entry>
  
  <entry>
    <title>Vuex入门基础</title>
    <link href="http://blog.haohome.top/2018/05/14/JavaScript/Vuex%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://blog.haohome.top/2018/05/14/JavaScript/Vuex入门基础/</id>
    <published>2018-05-13T16:00:00.000Z</published>
    <updated>2018-05-15T13:58:59.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Vuex-概念"><a href="#1-Vuex-概念" class="headerlink" title="1. Vuex 概念"></a>1. Vuex 概念</h2><p>Vuex 是一个<strong>状态管理模式</strong>,它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p><p>每一个 Vuex 应用的核心就是 store(仓库)，在store中包含组件中的共享<strong>状态</strong><code>state</code>和改变状态的<strong>方法</strong><code>mutations</code>。</p><p><strong>store仓库</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    state: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    mutations: &#123;</span><br><span class="line">        increment (state) &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>1) Vuex 的状态存储是响应式的<br>2) 不能直接改变 store 中的状态,需显式地<strong>提交 (commit) mutation</strong></p></blockquote><a id="more"></a><h2 id="2-State单一状态树"><a href="#2-State单一状态树" class="headerlink" title="2. State单一状态树"></a>2. State单一状态树</h2><p>用一个对象包含全部的应用层级状态</p><p>Vuex 通过 <code>store</code> 选项，将状态从根组件“注入”到每一个子组件中,子组件需调用 <code>Vue.use(Vuex)</code>：</p><p>根组件:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根组件:</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  store, <span class="comment">// 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span></span><br><span class="line">  components: &#123; Counter &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>子组件: 通过<code>computed</code>(计算属性)返回<code>this.$store.state.count</code>来获取相应数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Counter = &#123;</span><br><span class="line">  computed: &#123;</span><br><span class="line">    count () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count<span class="comment">//获取根组件的state</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mapState-辅助函数"><a href="#mapState-辅助函数" class="headerlink" title="mapState 辅助函数"></a>mapState 辅助函数</h3><p>简化生成计算属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    computed: mapState (&#123;</span><br><span class="line">        count: <span class="function"><span class="params">state</span> =&gt;</span> state.count,</span><br><span class="line">        countAlias: <span class="string">'count'</span>,    <span class="comment">// 别名 `count` 等价于 state =&gt; state.count</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以更简化:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">computed: mapState([</span><br><span class="line">  <span class="comment">// 映射 this.count 为 store.state.count</span></span><br><span class="line">  <span class="string">'count'</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><h2 id="3-Getter-从-store-中的-state-派生出状态"><a href="#3-Getter-从-store-中的-state-派生出状态" class="headerlink" title="3. Getter 从 store 中的 state 派生出状态"></a>3. Getter 从 store 中的 state 派生出状态</h2><p>如果我们需要对<code>state</code>对象进行做处理计算，如对列表进行过滤并计数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    doneTodosCount () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done).length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果多个组件都要进行这样的处理，那么就要在多个组件中复制该函数,这样效率低下。</p><p>Vuex中<code>getters</code>对象，可以方便我们在<code>store</code>中做集中的处理,Getters接受<code>state</code>作为第一个参数：:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">'...'</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doneTodos: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.todos.filter(<span class="function"><span class="params">todo</span> =&gt;</span> todo.done)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Getter 会暴露为 <code>store.getters</code> 对象，可以以属性的形式访问这些值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">store.getters.doneTodos <span class="comment">// -&gt; [&#123; id: 1, text: '...', done: true &#125;]</span></span><br></pre></td></tr></table></figure><p>Getter 也可以接受其他 getter 作为第二个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  doneTodosCount: <span class="function">(<span class="params">state, getters</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.doneTodos.length</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.getters.doneTodosCount <span class="comment">// -&gt; 1</span></span><br></pre></td></tr></table></figure><h3 id="mapGetters辅助函数"><a href="#mapGetters辅助函数" class="headerlink" title="mapGetters辅助函数"></a>mapGetters辅助函数</h3><p>与<code>mapState</code>类似，都能达到简化代码的效果<br><code>mapGetters</code>辅助函数仅仅是将store中的getters映射到局部计算属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  computed: &#123;</span><br><span class="line">    <span class="comment">// 使用对象展开运算符将 getters 混入 computed 对象中</span></span><br><span class="line">    ...mapGetters([</span><br><span class="line">      <span class="string">'doneTodosCount'</span>,</span><br><span class="line">      <span class="string">'anotherGetter'</span>,</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可写作:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">computed: mapGetters([</span><br><span class="line">    <span class="string">'doneTodosCount'</span>,</span><br><span class="line">    <span class="string">'anotherGetter'</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>所以在Vue的<code>computed</code>计算属性中会存在两种辅助函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapState, mapGetters &#125; <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    computed: &#123;</span><br><span class="line">        mapState(&#123; ... &#125;),</span><br><span class="line">        mapGetter(&#123; ... &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-Mutation-更改-Vuex-的-store-中的状态"><a href="#4-Mutation-更改-Vuex-的-store-中的状态" class="headerlink" title="4. Mutation 更改 Vuex 的 store 中的状态"></a>4. Mutation 更改 Vuex 的 store 中的状态</h2><p>每个 mutation 都有一个字符串的 <strong>事件类型 (type)</strong> 和 一个 <strong>回调函数 (handler)</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;<span class="comment">//type:'increment'</span></span><br><span class="line">      <span class="comment">// 变更状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>要唤醒一个 mutation handler，你需要调用 <strong>store.commit</strong> 方法调用<code>mutation type</code>: <code>store.commit(&#39;increment&#39;)</code></p><h3 id="提交载荷（Payload）"><a href="#提交载荷（Payload）" class="headerlink" title="提交载荷（Payload）"></a>提交载荷（Payload）</h3><p> 向 <code>store.commit</code> 传入第二个参数,也就是mutation的<code>payload</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">  increment (state, n) &#123;</span><br><span class="line">    state.count += n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">store.commit(<span class="string">'increment'</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>单单传入一个<code>n</code>，可能并不能满足我们的业务需要，这时候我们可以选择传入一个<code>payload</code>对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mutation: &#123;</span><br><span class="line">    increment (state, payload) &#123;</span><br><span class="line">        state.totalPrice += payload.price + payload.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象风格的提交方式"><a href="#对象风格的提交方式" class="headerlink" title="对象风格的提交方式"></a>对象风格的提交方式</h3><p>提交 mutation 的另一种方式是直接使用包含 <code>type</code> 属性的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">store.commit(&#123;</span><br><span class="line">  type: <span class="string">'increment'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="mapMutations函数"><a href="#mapMutations函数" class="headerlink" title="mapMutations函数"></a>mapMutations函数</h3><p>使用<code>mapMutations</code>辅助函数将组件中的<code>methods</code>映射为<code>store.commit</code>调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapMutations([</span><br><span class="line">      <span class="string">'increment'</span> <span class="comment">// 映射 this.increment() 为 this.$store.commit('increment')</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapMutations(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 映射 this.add() 为 this.$store.commit('increment')</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-Action"><a href="#5-Action" class="headerlink" title="5.Action"></a>5.Action</h2><ul><li>Action 提交的是 mutation，而不是直接变更状态。</li><li>Action 可以包含任意异步操作。</li></ul><p>在vuex中,mutation是同步事件:<code>store.commit(&#39;increment&#39;)</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    increment (context) &#123;</span><br><span class="line">      context.commit(<span class="string">'increment'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 <code>context.commit</code> 提交一个 mutation，或者通过 <code>context.state</code> 和 <code>context.getters</code> 来获取 state 和 getters。</p><h3 id="分发Action"><a href="#分发Action" class="headerlink" title="分发Action"></a>分发Action</h3><p>Action 通过 <code>store.dispatch</code> 方法触发：<code>store.dispatch(&#39;increment&#39;)</code>;</p><p>Actions 支持同样的载荷方式和对象方式进行分发：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以载荷形式分发</span></span><br><span class="line">store.dispatch(<span class="string">'incrementAsync'</span>, &#123;</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以对象形式分发</span></span><br><span class="line">store.dispatch(&#123;</span><br><span class="line">  type: <span class="string">'incrementAsync'</span>,</span><br><span class="line">  amount: <span class="number">10</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="在组件中分发Action"><a href="#在组件中分发Action" class="headerlink" title="在组件中分发Action"></a>在组件中分发Action</h3><p>在组件中使用 <code>this.$store.dispatch(&#39;xxx&#39;)</code> 分发 action，或者使用 <code>mapActions</code> 辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...mapActions([</span><br><span class="line">      <span class="string">'increment'</span>, <span class="comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// `mapActions` 也支持载荷：</span></span><br><span class="line">      <span class="string">'incrementBy'</span> <span class="comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span></span><br><span class="line">    ]),</span><br><span class="line">    ...mapActions(&#123;</span><br><span class="line">      add: <span class="string">'increment'</span> <span class="comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组合-Action"><a href="#组合-Action" class="headerlink" title="组合 Action"></a>组合 Action</h3><p>Action 通常是异步的，如何知道 action 什么时候结束呢？更重要的是，我们如何才能组合多个 action，以处理更加复杂的异步流程？</p><p>首先，你需要明白 <code>store.dispatch</code> 可以处理被触发的 action 的处理函数返回的 Promise，并且 <code>store.dispatch</code> 仍旧返回 Promise：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        commit(<span class="string">'someMutation'</span>)</span><br><span class="line">        resolve()</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">store.dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在另外一个 action 中也可以：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'someOtherMutation'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们利用 <a href="https://tc39.github.io/ecmascript-asyncawait/" target="_blank" rel="noopener">async / await</a>，我们可以如下组合 action：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span></span><br><span class="line"></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'gotData'</span>, <span class="keyword">await</span> getData())</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个 <code>store.dispatch</code> 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Vuex-概念&quot;&gt;&lt;a href=&quot;#1-Vuex-概念&quot; class=&quot;headerlink&quot; title=&quot;1. Vuex 概念&quot;&gt;&lt;/a&gt;1. Vuex 概念&lt;/h2&gt;&lt;p&gt;Vuex 是一个&lt;strong&gt;状态管理模式&lt;/strong&gt;,它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。&lt;/p&gt;
&lt;p&gt;每一个 Vuex 应用的核心就是 store(仓库)，在store中包含组件中的共享&lt;strong&gt;状态&lt;/strong&gt;&lt;code&gt;state&lt;/code&gt;和改变状态的&lt;strong&gt;方法&lt;/strong&gt;&lt;code&gt;mutations&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;store仓库&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Vue &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;vue&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Vuex &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;vuex&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Vue.use(Vuex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; store = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Vuex.Store(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    state: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        count: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    mutations: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        increment (state) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            state.count++&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;1) Vuex 的状态存储是响应式的&lt;br&gt;2) 不能直接改变 store 中的状态,需显式地&lt;strong&gt;提交 (commit) mutation&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
      <category term="vue" scheme="http://blog.haohome.top/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Node.js的web服务器路由重构</title>
    <link href="http://blog.haohome.top/2018/05/02/JavaScript/Node.js%E7%9A%84web%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B7%AF%E7%94%B1%E9%87%8D%E6%9E%84/"/>
    <id>http://blog.haohome.top/2018/05/02/JavaScript/Node.js的web服务器路由重构/</id>
    <published>2018-05-02T15:32:00.000Z</published>
    <updated>2018-05-04T13:38:57.879Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://haohome.top/18-5-3/35609573.jpg" width="40%"></p><p>Node使JavaScript操作服务器成为可能，同时其带来了强大的文件操作方法。我们在创建一个服务器时，会遇到路由切换的问题，当前express等库是可以识别不同路由并执行不同操作的，最近在回顾Node.js的一些用法，这里就尝试采用原生的方法重构一个路由功能。</p><p>原始路由方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">let</span> server=http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(req.url==<span class="string">'/index'</span>)&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    res.write(<span class="string">'&lt;h1&gt;这是首页&lt;/h1&gt;'</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.url==<span class="string">'/products'</span>)&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    res.write(<span class="string">'&lt;h1&gt;这是产品页&lt;/h1&gt;'</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(req.url==<span class="string">'/detail'</span>)&#123;</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    res.write(<span class="string">'&lt;h1&gt;这是详情页&lt;/h1&gt;'</span>)</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.writeHead(<span class="number">404</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    res.write(<span class="string">'&lt;h1&gt;这是404页&lt;/h1&gt;'</span>)</span><br><span class="line">  res.end(<span class="string">'欢迎来到NodeJs'</span>);</span><br><span class="line">&#125;)</span><br><span class="line">server.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'开始监听3000端口'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>这样的路由方法看似结构清晰，但实际情况比这复杂的多，有大量的路由和相应的页面响应方法，就会显得臃肿了。</p><p>其实，我们可以采用ES6的模块语法，使创建服务器、路由控制、地址处理方法执行分别处于不同模块，最终在一个入口文件中引入：</p><p>服务器模块:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="comment">//1.http创建服务器并监听端口方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startServer</span>(<span class="params">route,handle</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> onRequest=<span class="function"><span class="keyword">function</span>(<span class="params">req,resp</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//路由处理</span></span><br><span class="line">    route(handle,req.url,resp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//http创建服务器</span></span><br><span class="line">  <span class="keyword">var</span> server= http.createServer(onRequest)</span><br><span class="line">  <span class="comment">//服务器监听3000端口</span></span><br><span class="line">  server.listen(<span class="number">3000</span>,<span class="string">'127.0.0.1'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'运行在3000端口'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.导出路由模块</span></span><br><span class="line"><span class="built_in">module</span>.exports.startServer = startServer;</span><br></pre></td></tr></table></figure><p>地址处理方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">//网站默认图标</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">favicon</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">'/favicon.ico'</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//首页</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">'/index.html'</span>,<span class="string">'utf8'</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//产品页</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">products</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">'/products.html'</span>,<span class="string">'utf8'</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//详情页</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">detail</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line">  fs.createReadStream(__dirname +<span class="string">'/detail.html'</span>,<span class="string">'utf8'</span>).pipe(resp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将不同页面的方法导出</span></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">  index:index,</span><br><span class="line">  products:products,</span><br><span class="line">  detail:detail,</span><br><span class="line">  favicon:favicon</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由模块:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">//1.路由处理方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">handle,url,resp</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">typeof</span> handle[url] ===<span class="string">'function'</span>)&#123;</span><br><span class="line">    resp.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    handle[url](resp);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    resp.writeHead(<span class="number">404</span>, &#123;<span class="string">'Content-Type'</span>:<span class="string">'text/html;charset=UTF-8'</span>&#125;);</span><br><span class="line">    fs.createReadStream(__dirname+<span class="string">'/404.html'</span>,<span class="string">'utf8'</span>).pipe(resp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.route=route;</span><br></pre></td></tr></table></figure><p>入口app.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server=<span class="built_in">require</span>(<span class="string">'./server'</span>);</span><br><span class="line"><span class="keyword">var</span> router=<span class="built_in">require</span>(<span class="string">'./router'</span>)</span><br><span class="line"><span class="keyword">var</span> handler = <span class="built_in">require</span>(<span class="string">'./handler'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.匹配url地址,</span></span><br><span class="line"><span class="keyword">var</span> handle = &#123;&#125;;</span><br><span class="line">handle[<span class="string">"/"</span>] = handler.index;</span><br><span class="line">handle[<span class="string">'/index'</span>] = handler.index;</span><br><span class="line">handle[<span class="string">'/products'</span>] = handler.products;</span><br><span class="line">handle[<span class="string">'/detail'</span>] = handler.detail;</span><br><span class="line">handle[<span class="string">'/favicon.ico'</span>] = handler.favicon;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.启动服务器</span></span><br><span class="line">server.startServer(router.route,handle)</span><br></pre></td></tr></table></figure><p>这样如果增加路由页面，只需在相应的位置依次增加即可，结构清晰！</p><p>当使用GET或POST请求时，需要对服务器模块做一些更改:</p><ol><li>请求为GET时,解析路由地址’?’后面的query语句;</li><li>请求为POST时,监听数据流并解析;</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http=<span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> url=<span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> queryString=<span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">startServer</span>(<span class="params">route,handle</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> onRequest=<span class="function"><span class="keyword">function</span>(<span class="params">req,resp</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//url路径</span></span><br><span class="line">    <span class="keyword">var</span> pathName=url.parse(req.url).pathname;</span><br><span class="line">    <span class="comment">//请求为POST时,监听数据流</span></span><br><span class="line">    <span class="keyword">if</span>(req.method==<span class="string">"POST"</span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> data=<span class="string">""</span>;</span><br><span class="line">      req.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;).on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">        data+=chunk;</span><br><span class="line">      &#125;).on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> params=queryString.parse(data);</span><br><span class="line">      route(handle,pathName,resp,params);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求为GET时,解析路由query</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> params=url.parse(req.url,<span class="literal">true</span>).query;</span><br><span class="line">      route(handle,pathName,resp,params);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> server= http.createServer(onRequest)</span><br><span class="line">  server.listen(<span class="number">3000</span>,<span class="string">'127.0.0.1'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'运行在3000端口'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports.startServer = startServer;</span><br></pre></td></tr></table></figure><p>相应的，增加router和handler的传参。</p><p>详细代码：<a href="https://github.com/yifoo/Node/tree/master/Demo-web" target="_blank" rel="noopener">Demo-web</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://haohome.top/18-5-3/35609573.jpg&quot; width=&quot;40%&quot;&gt;&lt;/p&gt;
&lt;p&gt;Node使JavaScript操作服务器成为可能，同时其带来了强大的文件操作方法。我们在创建一个服务器时，会遇到路由切换的问题，当前express等库是可以识别不同路由并执行不同操作的，最近在回顾Node.js的一些用法，这里就尝试采用原生的方法重构一个路由功能。&lt;/p&gt;
&lt;p&gt;原始路由方法：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; http=&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;http&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; fs=&lt;span class=&quot;built_in&quot;&gt;require&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;fs&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; server=http.createServer(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;req,res&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(req.url==&lt;span class=&quot;string&quot;&gt;&#39;/index&#39;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.writeHead(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;text/html;charset=UTF-8&#39;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.write(&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;h1&amp;gt;这是首页&amp;lt;/h1&amp;gt;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(req.url==&lt;span class=&quot;string&quot;&gt;&#39;/products&#39;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.writeHead(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;text/html;charset=UTF-8&#39;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.write(&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;h1&amp;gt;这是产品页&amp;lt;/h1&amp;gt;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(req.url==&lt;span class=&quot;string&quot;&gt;&#39;/detail&#39;&lt;/span&gt;)&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.writeHead(&lt;span class=&quot;number&quot;&gt;200&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;text/html;charset=UTF-8&#39;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.write(&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;h1&amp;gt;这是详情页&amp;lt;/h1&amp;gt;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.writeHead(&lt;span class=&quot;number&quot;&gt;404&lt;/span&gt;, &amp;#123;&lt;span class=&quot;string&quot;&gt;&#39;Content-Type&#39;&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;text/html;charset=UTF-8&#39;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    res.write(&lt;span class=&quot;string&quot;&gt;&#39;&amp;lt;h1&amp;gt;这是404页&amp;lt;/h1&amp;gt;&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  res.end(&lt;span class=&quot;string&quot;&gt;&#39;欢迎来到NodeJs&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;server.listen(&lt;span class=&quot;number&quot;&gt;3000&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;&#39;开始监听3000端口&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="node" scheme="http://blog.haohome.top/tags/node/"/>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>模拟jQuery的ajax方法封装</title>
    <link href="http://blog.haohome.top/2018/04/14/JavaScript/%E6%A8%A1%E6%8B%9FjQuery%E7%9A%84ajax%E6%96%B9%E6%B3%95%E5%B0%81%E8%A3%85/"/>
    <id>http://blog.haohome.top/2018/04/14/JavaScript/模拟jQuery的ajax方法封装/</id>
    <published>2018-04-14T08:19:00.000Z</published>
    <updated>2018-04-15T05:55:55.349Z</updated>
    
    <content type="html"><![CDATA[<p>ajax在我们的前后端交互占据着重要的位置,前段时间在自己的小项目里模仿jQuery的模式封装了ajax请求的方法,但似乎没有达到满意的效果,同步异步实现并不是很满意,而且有一些局限性。感觉还是要单独拿出来记录，深入的去剖析ajax的原生封装更为妥当！</p><h3 id="jQuery的常规ajax实现："><a href="#jQuery的常规ajax实现：" class="headerlink" title="jQuery的常规ajax实现："></a>jQuery的常规ajax实现：</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">url:<span class="string">"http://...."</span>,</span><br><span class="line">  method:<span class="string">"GET"</span>,</span><br><span class="line">  data:&#123;&#125;,</span><br><span class="line">  dataType:<span class="string">'json'</span>,</span><br><span class="line">  success:<span class="function"><span class="keyword">function</span>(<span class="params">resp,status</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(resp)</span><br><span class="line">  &#125;,</span><br><span class="line">  error:<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到jQuery的ajax方法是$.ajax()传了一个对象参数。</p><a id="more"></a><h3 id="ajax交互的四个基本步骤"><a href="#ajax交互的四个基本步骤" class="headerlink" title="ajax交互的四个基本步骤:"></a>ajax交互的四个基本步骤:</h3><blockquote><ol><li>创建对象</li><li>创建请求xhr.open;</li><li>设置onreadystatechange，判断readyState以及status并接受响应</li><li>发送请求：xhr.send()</li></ol></blockquote><ul><li>创建的对象obj需要包含url、method、data、dataType、success、error等属性</li><li>获得xhr对象:</li><li>判断请求方法是get还是post</li><li>data参数处理</li><li>ajax请求状态判断,要考虑重定向的情况</li><li>获得响应数据</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $=&#123;</span><br><span class="line">  <span class="comment">/*get方法传入data,返回一个拼接好的字符串uname=min&amp;age=12*/</span></span><br><span class="line">  params:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr=[];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> data)&#123;</span><br><span class="line">      arr.push(key+<span class="string">"="</span>+data[key])<span class="comment">//将对象键值对以字符串形式存入数组中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> str=arr.join(<span class="string">"&amp;"</span>);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/*该方法发送http请求*/</span></span><br><span class="line">  ajax:<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> url=obj.url;</span><br><span class="line">    <span class="keyword">var</span> type=obj.method || obj.type;<span class="comment">//支持方法属性为method或type;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">async</span>=obj.async == <span class="literal">undefined</span> ? <span class="literal">true</span> : obj.async;</span><br><span class="line"><span class="keyword">var</span> data = obj.data == <span class="literal">undefined</span> ? &#123;&#125; : obj.data;</span><br><span class="line">    <span class="keyword">var</span> success=obj.success;</span><br><span class="line">    <span class="keyword">var</span> error=obj.error;</span><br><span class="line">    <span class="comment">//创建一个XMLHttpRequest 对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">window</span>.XMLHttpRequest)&#123;</span><br><span class="line">      xhr=<span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;<span class="comment">//微软IE浏览器的xhr对象</span></span><br><span class="line">      xhr=<span class="keyword">new</span> ActiveXObject(<span class="string">"MicroSoft.XMLHttp"</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//判断请求类型是"get"还是"post"</span></span><br><span class="line">    <span class="keyword">if</span>(type.toLowerCase()===<span class="string">"get"</span>)&#123;</span><br><span class="line">      <span class="comment">//get类型的url参数为拼接字符串</span></span><br><span class="line">      url=url+<span class="string">"?"</span>+<span class="keyword">this</span>.params(data);</span><br><span class="line">      data=<span class="literal">null</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="comment">//post类型要给服务器端一个请求头</span></span><br><span class="line">      xhr.setRequestHeader(<span class="string">'Content-Type'</span>,<span class="string">"application/x-www-form-urlencoded"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建请求</span></span><br><span class="line">    xhr.open(type,url,<span class="keyword">async</span>);</span><br><span class="line">    <span class="comment">//当xhr的readyState发生改变时，要自动激发的操作</span></span><br><span class="line">    xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//返回的状态可能为200成功,也可能是304重定向</span></span><br><span class="line">       <span class="keyword">if</span>(xhr.readyState==<span class="number">4</span> &amp;&amp; xhr.status==<span class="number">200</span> || xhr.status==<span class="number">304</span>)&#123;</span><br><span class="line">         <span class="keyword">var</span> respData=xhr.responseText;</span><br><span class="line">         success(data);<span class="comment">//</span></span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">         error();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//xhr.send()方法要放在后面,这样xhr.onreadystatechange方法提前绑定监听xhr.readyState,同步请求才能拿到数据</span></span><br><span class="line">    xhr.send(data);<span class="comment">//get类型data为null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上有一点需要<strong>注意</strong>,就是xhr.send()方法一定要放在最后,这样xhr.onreadystatechange才能监听xhr的readyState变化,否则同步发送请求时不能监听xhr的readyState变化</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ajax在我们的前后端交互占据着重要的位置,前段时间在自己的小项目里模仿jQuery的模式封装了ajax请求的方法,但似乎没有达到满意的效果,同步异步实现并不是很满意,而且有一些局限性。感觉还是要单独拿出来记录，深入的去剖析ajax的原生封装更为妥当！&lt;/p&gt;
&lt;h3 id=&quot;jQuery的常规ajax实现：&quot;&gt;&lt;a href=&quot;#jQuery的常规ajax实现：&quot; class=&quot;headerlink&quot; title=&quot;jQuery的常规ajax实现：&quot;&gt;&lt;/a&gt;jQuery的常规ajax实现：&lt;/h3&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$.ajax(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	url:&lt;span class=&quot;string&quot;&gt;&quot;http://....&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  method:&lt;span class=&quot;string&quot;&gt;&quot;GET&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  data:&amp;#123;&amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  dataType:&lt;span class=&quot;string&quot;&gt;&#39;json&#39;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  success:&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;resp,status&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(resp)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  error:&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;err&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(err)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;可以看到jQuery的ajax方法是$.ajax()传了一个对象参数。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="ajax" scheme="http://blog.haohome.top/tags/ajax/"/>
    
      <category term="jQuery" scheme="http://blog.haohome.top/tags/jQuery/"/>
    
  </entry>
  
  <entry>
    <title>跨域请求的jsonp处理</title>
    <link href="http://blog.haohome.top/2018/04/07/Web/%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E7%9A%84jsonp%E5%A4%84%E7%90%86/"/>
    <id>http://blog.haohome.top/2018/04/07/Web/跨域请求的jsonp处理/</id>
    <published>2018-04-06T16:00:00.000Z</published>
    <updated>2018-05-02T15:28:24.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="跨域简介"><a href="#跨域简介" class="headerlink" title="跨域简介"></a>跨域简介</h3><p>跨域是指不用域之间相互请求资源,只要协议，主机名，端口号，二级域名等不同都算跨域。</p><p>浏览器认为多数由js程序发起的跨域请求都是不合法的，主要为xhr，但不由js发起的跨域是允许的，包括：img，link，script，iframe；</p><a id="more"></a><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><ul><li>JSON with Padding 填充式 json</li></ul><p>正常的ajax请求是不允许跨域请求的，只能用允许跨域请求的元素script代替</p><ul><li><p>处理步骤</p><ol><li>客户端定义一个专门处理相应的有名函数doResponse(<strong>处理函数中仅接受并处理服务端json数据,不用xhr对象，更不用判断状态</strong>)</li><li>服务器端php: 接受请求数据并处理,返回一条js语句echo ‘doResponse($json)’;</li><li>动态创建一个script元素,设置src指向服务器端的php地址</li></ol><p>客户端js:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doResponse</span>(<span class="params">resp</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(resp);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> resp)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">$(<span class="string">"#btn"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/*动态追加script元素*/</span></span><br><span class="line">  $(<span class="string">"body"</span>).append(<span class="string">`&lt;script src="http://127.0.0.1/jsonp.php?callback=doResponse"&gt;&lt;\/script&gt;`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也可以采用ajax获得返回数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(<span class="string">"https://www.haohome.top/demo/jsonp.php?callback=doResponse"</span>,data=&gt;&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  type:<span class="string">"GET"</span>,</span><br><span class="line">  url:<span class="string">"https://www.haohome.top/demo/jsonp.php?callback=doResponse"</span>,</span><br><span class="line">  success:<span class="function"><span class="params">data</span>=&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"返回数据"</span>,data);</span><br><span class="line">  &#125;,</span><br><span class="line">  dataType:<span class="string">"jsonp"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>服务器端php:</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">"Content-type:application/javascript;charset:utf-8"</span>);</span><br><span class="line">$getData=$_GET[<span class="string">'callback'</span>];</span><br><span class="line">$hello=json_encode([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">echo</span> $getData.<span class="string">"('$hello')"</span>;</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;跨域简介&quot;&gt;&lt;a href=&quot;#跨域简介&quot; class=&quot;headerlink&quot; title=&quot;跨域简介&quot;&gt;&lt;/a&gt;跨域简介&lt;/h3&gt;&lt;p&gt;跨域是指不用域之间相互请求资源,只要协议，主机名，端口号，二级域名等不同都算跨域。&lt;/p&gt;
&lt;p&gt;浏览器认为多数由js程序发起的跨域请求都是不合法的，主要为xhr，但不由js发起的跨域是允许的，包括：img，link，script，iframe；&lt;/p&gt;
    
    </summary>
    
      <category term="web" scheme="http://blog.haohome.top/categories/web/"/>
    
    
      <category term="http" scheme="http://blog.haohome.top/tags/http/"/>
    
      <category term="web" scheme="http://blog.haohome.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>创建对象的Object.create与new</title>
    <link href="http://blog.haohome.top/2018/04/07/JavaScript/%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84Object.create%E4%B8%8Enew/"/>
    <id>http://blog.haohome.top/2018/04/07/JavaScript/创建对象的Object.create与new/</id>
    <published>2018-04-06T16:00:00.000Z</published>
    <updated>2018-04-10T05:53:47.296Z</updated>
    
    <content type="html"><![CDATA[<p>创建对象有几种方式:</p><ul><li><p>直接量:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1=&#123;<span class="attr">name</span>:<span class="string">"xiaowang"</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj2=<span class="keyword">new</span> <span class="built_in">Object</span>(&#123;<span class="attr">name</span>:<span class="string">"xiaowang"</span>&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(obj1,obj2);</span><br></pre></td></tr></table></figure></li><li><p>构造函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> M=<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;<span class="keyword">this</span>.name=name&#125;;</span><br><span class="line"><span class="keyword">var</span> obj3=<span class="keyword">new</span> M(<span class="string">'xiaowang'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj3);</span><br></pre></td></tr></table></figure></li><li><p>Object.create</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p=&#123;<span class="attr">name</span>:<span class="string">'xiaowang'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> obj4=<span class="built_in">Object</span>.create(p);</span><br><span class="line"><span class="built_in">console</span>.log(obj4);</span><br></pre></td></tr></table></figure><p>对应的输出结果为:</p><p><img src="https://haohome.top/18-4-7/88488666.jpg" alt="img"></p><a id="more"></a><p>可以看到,Object.create方法得到的对象是空对象，再输出各自对象的name属性看看:</p><p><code>console.log(obj2.name,obj3.name,obj4.name)</code></p><p>得到的结果为<code>xiaowang xiaowang xiaowang</code></p><p>这是为什么???</p></li></ul><ol><li><p><code>Object.create</code> 的实现方式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;&#125;</span></span><br><span class="line">obj1.name = <span class="string">'jian'</span>;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">Object</span>.create(obj1);</span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2.name); <span class="comment">// 'jian', </span></span><br><span class="line">conosle.log(obj2.__proto__===obj1.prototype) <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>obj2是空对象,但obj2.name输出了’jian’,obj2继承自obj1的原型对象</p><p>由此可以总结<code>Object.create()</code>做了： </p></li></ol><p>​    1. 创建空对象{} </p><p>​    2. 指定空对象{}继承自参数的原型对象,即空对象的    <code>__proto__</code> 指向Object.create()参数的原型对象。</p><ol><li><p><code>var obj1=new M({name:&#39;xiaowang&#39;})</code> 的实现方式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义构造函数Person </span></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = firstName;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义Person原型对象的新方法</span></span><br><span class="line">Person.prototype.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, I'm "</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//实例化对象</span></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>);</span><br><span class="line"><span class="comment">//对象调用method</span></span><br><span class="line">person1.sayHello(); <span class="comment">// logs "Hello, I'm Alice"</span></span><br></pre></td></tr></table></figure><p>由此可以总结<code>new</code>做了： </p><ol><li>创建实例对象person1 </li><li>调用构造函数(Person)初始化person1成员变量（name)。 </li><li>指定实例对象的继承自Person.prototype对象。即<code>person1.__proto__</code>指向构造函数的原型对象Person.prototype。</li></ol></li></ol><table><thead><tr><th style="text-align:center">对比</th><th style="text-align:center">Object.create</th><th style="text-align:center">new</th></tr></thead><tbody><tr><td style="text-align:center">创建对象</td><td style="text-align:center">创建空对象</td><td style="text-align:center">创建实例对象,并将参数初始化赋值</td></tr><tr><td style="text-align:center">继承</td><td style="text-align:center">空对象继承自参数对象的原型对象,本身为空对象</td><td style="text-align:center">实例对象继承自构造函数的原型对象</td></tr></tbody></table><p>  总结:Object.create得到的对象未实例化,本身为空对象,可继承对象,而new得到的对象是实例化的对象</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;创建对象有几种方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;直接量:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj1=&amp;#123;&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;xiaowang&quot;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj2=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;(&amp;#123;&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&quot;xiaowang&quot;&lt;/span&gt;&amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj1,obj2);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;构造函数:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; M=&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;name&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name=name&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj3=&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; M(&lt;span class=&quot;string&quot;&gt;&#39;xiaowang&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj3);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Object.create&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; p=&amp;#123;&lt;span class=&quot;attr&quot;&gt;name&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;&#39;xiaowang&#39;&lt;/span&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; obj4=&lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;.create(p);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(obj4);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对应的输出结果为:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haohome.top/18-4-7/88488666.jpg&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="js" scheme="http://blog.haohome.top/tags/js/"/>
    
      <category term="对象" scheme="http://blog.haohome.top/tags/%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>浏览器缓存问题</title>
    <link href="http://blog.haohome.top/2018/03/29/Web/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.haohome.top/2018/03/29/Web/浏览器缓存问题/</id>
    <published>2018-03-28T16:06:25.000Z</published>
    <updated>2018-04-10T05:53:47.208Z</updated>
    
    <content type="html"><![CDATA[<p>请求缓存的路线图:</p><p><img src="https://haohome.top/18-3-28/12713380.jpg" width="60%"></p><h2 id="两个概念"><a href="#两个概念" class="headerlink" title="两个概念"></a>两个概念</h2><ol><li><p>强缓存<br>用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。</p></li><li><p>协商缓存<br>用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源。</p></li></ol><blockquote><p>共同点: 客户端获得的数据最后都是从客户端缓存中获得</p><p>区别: 强缓存不与服务器交互，而协商缓存则需要与服务器交互。</p></blockquote><a id="more"></a><h2 id="四个过程详解"><a href="#四个过程详解" class="headerlink" title="四个过程详解"></a>四个过程详解</h2><h3 id="（a）浏览器判定是否有缓存"><a href="#（a）浏览器判定是否有缓存" class="headerlink" title="（a）浏览器判定是否有缓存"></a>（a）浏览器判定是否有缓存</h3><p>所谓“客户端缓存”就是指用户设备中本地资源。不同浏览器缓存文件的地址也不尽相同。</p><p>对于一个html页面，缓存分3部分，一个是页面内容，一个是css样式，一个是JS文件</p><p>我们以chrome为例来查看下浏览器缓存文件的地址，<br>1）首先在chrome中输入：chrome://chrome-urls/，看到一堆列表,里面隐藏了许多浏览器的奥秘，有兴趣的可以自己深扒。<br>2）找到 chrome://cache（当然也可以直接输入这个地址）</p><h3 id="（b）缓存是否过期"><a href="#（b）缓存是否过期" class="headerlink" title="（b）缓存是否过期"></a>（b）缓存是否过期</h3><p><img src="https://haohome.top/18-3-29/57859267.jpg" width="80%"></p><ul><li>expires</li></ul><p>Http1.0 中的标准，表明过期时间，注意此处的时间都是指的是服务器的时间。</p><p><strong>存在的问题：服务器时间与客户端时间的不一致，就会导致缓存跟期待效果出现偏差。</strong></p><ul><li><p>Cache-Control<br>Http1.1 中的标准，可以看成是 expires 的补充。使用的是相对时间的概念。<br>Cache-Control的属性:</p><p>1）max-age: 设置缓存的最大的有效时间，单位为秒（s）。max-age会覆盖掉Expires</p><p>2)  s-maxage: 只用于共享缓存，比如CDN缓存（s -&gt; share）。与max-age 的区别是：max-age用于普通缓存，<br>而s-maxage用于代理缓存。如果存在s-maxage,则会覆盖max-age 和 Expires.</p><p>3)  public：响应会被缓存，并且在多用户间共享。默认是public。</p><p>4)  private: 响应只作为私有的缓存，不能在用户间共享。如果要求HTTP认证，响应会自动设置为private。</p><p>5）no-cache: 指定不缓存响应，表明资源不进行缓存。但是设置了no-cache之后并不代表浏览器不缓存，而是在缓存前要向服务器确认资源是否被更改。因此有的时候只设置no-cache防止缓存还是不够保险，还可以加上private指令，将过期时间设为过去的时间。</p><p>6）no-store: 绝对禁止缓存。</p><p>7）must-revalidate: 如果页面过期，则去服务器进行获取。</p><p><img src="https://haohome.top/18-3-29/21518884.jpg" width="60%"></p><p>所以判断缓存是否过期步骤是：<br>1） 查看是否有cache-control 的max-age / s-maxage , 如果有，则用服务器时间date值 + max-age/s-maxage 的秒数计算出新的过期时间，将当前时间与过期时间进行比较，判断是否过期<br>2）查看是否有cache-control 的max-age / s-maxage，则用expires 作为过期时间比较</p></li></ul><blockquote><p>总结：（b）过程执行完后，如果判定为未过期，则使用客户端缓存。那么就是属于“强缓存”。</p></blockquote><h3 id="（c）跟服务器协商是否使用缓存"><a href="#（c）跟服务器协商是否使用缓存" class="headerlink" title="（c）跟服务器协商是否使用缓存"></a>（c）跟服务器协商是否使用缓存</h3><p><img src="https://haohome.top/18-3-29/19908920.jpg" width="80%"></p><p>到这一步的时候，浏览器会向服务器发送请求，同时如果上一次的缓存中有Last-modified 和 Etag 字段，<br>浏览器将在request header 中加入If-Modified-Since（对应于Last-modified）， 和If-None-Match（对应于Etag）。</p><ul><li><p>Last-modified: 表明请求的资源上次的修改时间。</p></li><li><p>If-Modified-Since：客户端保留的资源上次的修改时间。</p></li><li><p>Etag：资源的内容标识。（不唯一，通常为文件的md5或者一段hash值，只要保证写入和验证时的方法一致即可）</p></li><li><p>If-None-Match： 客户端保留的资源内容标识。</p><blockquote><p>1） 分布式系统尽量关闭Etag，因为每台机器生成的Etag都不一样。<br>2）分布式系统里多台机器间文件的Last-Modified必须一致，以免负载均衡不同导致对比失败。</p></blockquote></li></ul><p>通常情况下，如果同时发送 If-None-Match 、If-Modified-Since字段，服务器只要比较etag 的内容即可，当然具体处理方式，看服务器的约定规则。</p><h3 id="（d）协商缓存"><a href="#（d）协商缓存" class="headerlink" title="（d）协商缓存"></a>（d）协商缓存</h3><p>在这个阶段，服务器一般会将Cache-control、expires 、last-modified、date、etag 等字段在response header 中返回，便于下次缓存。当然具体的场景，也是看服务器的约定规则设定。</p><h2 id="缓存的不同来源"><a href="#缓存的不同来源" class="headerlink" title="缓存的不同来源"></a>缓存的不同来源</h2><h3 id="from-disk-cache"><a href="#from-disk-cache" class="headerlink" title="from disk cache"></a>from disk cache</h3><p>从磁盘中获取缓存资源，等待下次访问时不需要重新下载资源，而直接从磁盘中获取。它的直接操作对象为CurlCacheManager。</p><h3 id="from-memory-cache"><a href="#from-memory-cache" class="headerlink" title="from memory cache"></a>from memory cache</h3><p>从内存中获取资源，等待下次访问时不需要重新下载资源，而直接从内存中获取。Webkit早已支持memoryCache。<br>目前Webkit资源分成两类，一类是主资源，比如HTML页面，或者下载项，一类是派生资源，比如HTML页面中内嵌的图片或者脚本链接，分别对应代码中两个类：　　　　MainResourceLoader和SubresourceLoader。虽然Webkit支持memoryCache，但是也只是针对派生资源，它对应的类为CachedResource，用于保存原始数据（比如CSS，JS等），以及解码过的图片数据。</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>当退出进程时，内存中的数据会被清空，而磁盘的数据不会，所以，当下次再进入该进程时，该进程仍可以从diskCache中获得数据，而memoryCache则不行。</p><h3 id="相似"><a href="#相似" class="headerlink" title="相似"></a>相似</h3><p>diskCache与memoryCache相似之处就是也只能存储一些派生类资源文件。它的存储形式为一个index.dat文件，记录存储数据的url，然后再分别存储该url的response信息和content内容。Response信息最大作用就是用于判断服务器上该url的content内容是否被修改。</p><h3 id="用户行为"><a href="#用户行为" class="headerlink" title="用户行为"></a>用户行为</h3><p><img src="https://haohome.top/18-3-29/99992671.jpg" width="80%"></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h2><h4 id="1、页面内容"><a href="#1、页面内容" class="headerlink" title="1、页面内容"></a>1、页面内容</h4><p><meta http-equiv="Expires" content="0"></p><p><meta http-equiv="Pragma" content="no-cache"></p><p><meta http-equiv="Cache-control" content="no-cache"></p><meta http-equiv="Cache" content="no-cache"><h4 id="2、CSS和JS文件"><a href="#2、CSS和JS文件" class="headerlink" title="2、CSS和JS文件"></a>2、CSS和JS文件</h4><p><link rel="stylesheet" href="../css/register.css"></p><p><script src="../scripts/register.js"></script><br>改成</p><p><link rel="stylesheet" href="../css/register.css?v=20161020"></p><p><script src="../scripts/register.js?v=20161020"></script><br>就是只要在每次修改后改一下版本号即可</p><p>这样每次修改后都要改，有没有自动加版本号的东西，估计有，如果是JSP和php可以通过脚本<br>自动生成，如果是纯html也可以通过document.write，或者用动态加载JS的框架啥的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;请求缓存的路线图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haohome.top/18-3-28/12713380.jpg&quot; width=&quot;60%&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;两个概念&quot;&gt;&lt;a href=&quot;#两个概念&quot; class=&quot;headerlink&quot; title=&quot;两个概念&quot;&gt;&lt;/a&gt;两个概念&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;强缓存&lt;br&gt;用户发送的请求，直接从客户端缓存中获取，不发送请求到服务器，不与服务器发生交互行为。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;协商缓存&lt;br&gt;用户发送的请求，发送到服务器后，由服务器判定是否从缓存中获取资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;共同点: 客户端获得的数据最后都是从客户端缓存中获得&lt;/p&gt;
&lt;p&gt;区别: 强缓存不与服务器交互，而协商缓存则需要与服务器交互。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="http://blog.haohome.top/categories/web/"/>
    
    
      <category term="http" scheme="http://blog.haohome.top/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>通俗易懂的原型与原型链</title>
    <link href="http://blog.haohome.top/2018/03/11/JavaScript/%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://blog.haohome.top/2018/03/11/JavaScript/通俗易懂的原型与原型链/</id>
    <published>2018-03-11T13:23:00.000Z</published>
    <updated>2018-04-10T05:53:47.352Z</updated>
    
    <content type="html"><![CDATA[<h2 id="普通对象与函数对象"><a href="#普通对象与函数对象" class="headerlink" title="普通对象与函数对象"></a>普通对象与函数对象</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> o2 =<span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> f1();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'str'</span>,<span class="string">'console.log(str)'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">//function </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">//function  </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1); <span class="comment">//function </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f2); <span class="comment">//function </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f3); <span class="comment">//function   </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o1); <span class="comment">//object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o2); <span class="comment">//object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o3); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><p>上面的例子中: o1、o2、o3都是普通对象object，而f1、f2、f3是函数对象function</p><blockquote><p><strong>凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1、f2归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的</strong>。</p></blockquote><a id="more"></a>    <h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, job</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">this</span>.name = name;</span><br><span class="line"> <span class="keyword">this</span>.age = age;</span><br><span class="line"> <span class="keyword">this</span>.job = job;</span><br><span class="line"> <span class="keyword">this</span>.intr = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="keyword">this</span>.name+<span class="string">"年龄是"</span>+<span class="keyword">this</span>.age) &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> lilei = <span class="keyword">new</span> Student(<span class="string">'lilei'</span>, <span class="number">28</span>, <span class="string">'Software Engineer'</span>);</span><br><span class="line"><span class="keyword">var</span> hmm = <span class="keyword">new</span> Student(<span class="string">'hmm'</span>, <span class="number">23</span>, <span class="string">'Doctor'</span>);</span><br></pre></td></tr></table></figure><p>这个例子中lilei、hmm都是构造函数Student的实例</p><h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><p>JavaScript中,每定义一个对象,对象中都会包含一些预定义的属性,每个普通对象和函数对象都包含<code>__proto__</code> ，而每个函数对象都会有<code>prototype</code> 属性，指向函数的原型对象;</p><p>看一个简单示意图:</p><p><img src="https://haohome.top/18-3-11/88286547.jpg" width="70%"></p><p>例子中,<code>Student</code> 是构造函数(昵称”妈”),其<code>prototype</code>(原型对象)就是<code>Student.prototype</code> (昵称”爹”)，原型对象(爹)的构造函数属性(妈)是构造函数，而lilei和hmm都是构造函数Student(妈)的实例(儿子/女儿)，儿子/女儿都继承(<code>__proto__</code>)了爹，遗传了爹的方法和属性，用公式表示即：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student===Student.prototype.constructor;<span class="comment">//true</span></span><br><span class="line">lilei.__proto__===Student.prototype;<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>构造函数具有<code>prototype</code> 属性，指向原型对象</li><li>原型对象具有<code>constructor</code> 属性，指向构造函数</li><li>实例对象具有<code>__protot__</code> 属性，指向原型对象</li></ul><blockquote><p>从 ECMAScript 6 开始，<code>[[Prototype]]</code> 可以通过<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getPrototypeOf" target="_blank" rel="noopener"><code>Object.getPrototypeOf()</code></a>和<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/setPrototypeOf" target="_blank" rel="noopener"><code>Object.setPrototypeOf()</code></a>访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 <code>__proto__</code>。</p></blockquote><p>原型对象其实就是普通对象，但Function.prototype除外，它是函数对象，且没有prototype属性(前面说函数对象具有prototype属性)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"> <span class="built_in">console</span>.log(Student.prototype) <span class="comment">//Student&#123;&#125; 空对象,具有constructor属性</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> Student.prototype) <span class="comment">//object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype) <span class="comment">// function，这个特殊</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype) <span class="comment">// object</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>.prototype.prototype) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><h2 id="原型对象的应用"><a href="#原型对象的应用" class="headerlink" title="原型对象的应用"></a>原型对象的应用</h2><p>原型对象的应用主要就是继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name; <span class="comment">// tip: 当函数执行时这个 this 指该构造函数的实例</span></span><br><span class="line">  &#125;;</span><br><span class="line"><span class="comment">/*给Student添加getName方法*/</span></span><br><span class="line">  Student.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;  <span class="comment">// tip: 当函数执行时这个 this 指该构造函数的实例</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> lilei = <span class="keyword">new</span> Student(<span class="string">'lilei'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(lilei.name); <span class="comment">//'lilei' 此时 lilei 已经有 name 这个属性了</span></span><br><span class="line">  <span class="built_in">console</span>.log(lilei.getName()); <span class="comment">//lilei</span></span><br></pre></td></tr></table></figure><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><img src="https://haohome.top/18-3-11/41073082.jpg" width="90%"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lilei.__proto__ 是Student.prototype</span><br><span class="line">Student.__proto__ 是<span class="built_in">Function</span>.prototype</span><br><span class="line">Student.prototype.__proto__ 是<span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="built_in">Object</span>.__proto__ 是<span class="built_in">Function</span>.prototype,<span class="built_in">Object</span>也是构造函数</span><br><span class="line"><span class="built_in">Object</span>.prototype__proto__ 是<span class="literal">null</span></span><br></pre></td></tr></table></figure><h2 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h2><p>所有的函数对象的<code>__proto__</code> 都指向<code>Function.prototype</code> ,它是一个空函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Boolean</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Boolean</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.constructor == <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 所有的构造器都来自于Function.prototype，甚至包括根构造器Object及Function自身</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">RegExp</span>.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">RegExp</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>.__proto__ === <span class="built_in">Function</span>.prototype   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Error</span>.constructor == <span class="built_in">Function</span> <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Date</span>.__proto__ === <span class="built_in">Function</span>.prototype    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>JavaScript中有内置(build-in)构造器/对象共计12个（ES5中新加了JSON），这里列举了可访问的8个构造器。剩下如Global不能直接访问，Arguments仅在函数调用时由JS引擎创建，Math，JSON是以对象形式存在的，无需new。它们的<code>__proto__</code> 是Object.prototype。如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Math</span>.construrctor == <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">JSON</span>.__proto__ === <span class="built_in">Object</span>.prototype  <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.construrctor == <span class="built_in">Object</span> <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>本文借鉴了</p><p>Yi罐可乐: <a href="https://www.jianshu.com/p/dee9f8b14771" target="_blank" rel="noopener">最详尽的 JS 原型与原型链终极详解，没有「可能是」</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;普通对象与函数对象&quot;&gt;&lt;a href=&quot;#普通对象与函数对象&quot; class=&quot;headerlink&quot; title=&quot;普通对象与函数对象&quot;&gt;&lt;/a&gt;普通对象与函数对象&lt;/h2&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o1 = &amp;#123;&amp;#125;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o2 =&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; o3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; f1();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f1&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f2 = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; f3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&#39;str&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;console.log(str)&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Object&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//function &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Function&lt;/span&gt;); &lt;span class=&quot;comment&quot;&gt;//function  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; f1); &lt;span class=&quot;comment&quot;&gt;//function &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; f2); &lt;span class=&quot;comment&quot;&gt;//function &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; f3); &lt;span class=&quot;comment&quot;&gt;//function   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; o1); &lt;span class=&quot;comment&quot;&gt;//object &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; o2); &lt;span class=&quot;comment&quot;&gt;//object &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;keyword&quot;&gt;typeof&lt;/span&gt; o3); &lt;span class=&quot;comment&quot;&gt;//object&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的例子中: o1、o2、o3都是普通对象object，而f1、f2、f3是函数对象function&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;凡是通过 new Function() 创建的对象都是函数对象，其他的都是普通对象。f1、f2归根结底都是通过 new Function()的方式进行创建的。Function Object 也都是通过 New Function()创建的&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="js" scheme="http://blog.haohome.top/tags/js/"/>
    
      <category term="原型" scheme="http://blog.haohome.top/tags/%E5%8E%9F%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>原生JS实现瀑布流效果</title>
    <link href="http://blog.haohome.top/2018/03/10/JavaScript/%E5%8E%9F%E7%94%9Fjs%E5%AE%9E%E7%8E%B0%E7%80%91%E5%B8%83%E6%B5%81%E6%95%88%E6%9E%9C/"/>
    <id>http://blog.haohome.top/2018/03/10/JavaScript/原生js实现瀑布流效果/</id>
    <published>2018-03-09T16:00:00.000Z</published>
    <updated>2018-04-06T18:16:32.688Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @name:瀑布流</span></span><br><span class="line"><span class="comment">   * @param:parent(容器元素)</span></span><br><span class="line"><span class="comment">   * @param:oneGap(只有一列时元素的间距,其他列数自适应)</span></span><br><span class="line"><span class="comment">   * @description:自适应瀑布流,多列间距自适应</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">waterFall:<span class="function"><span class="keyword">function</span> (<span class="params">parent,oneGap</span>)</span>&#123;</span><br><span class="line">  <span class="comment">/**容器的宽度(包含内边距、边框) */</span></span><br><span class="line">  <span class="keyword">var</span> width=parent.offsetWidth;</span><br><span class="line">  <span class="comment">/**容器内盒子元素的宽度(包含内边距、边框)  */</span></span><br><span class="line">  <span class="keyword">var</span> items=parent.children;</span><br><span class="line">  <span class="keyword">var</span> itemWidth = items[<span class="number">0</span>].offsetWidth;</span><br><span class="line">  <span class="keyword">var</span> gap=(width-<span class="built_in">parseInt</span>(width / (itemWidth))*itemWidth)/<span class="number">2</span>;</span><br><span class="line">  <span class="comment">/**计算每列放的盒子元素个数 */</span></span><br><span class="line">  <span class="keyword">var</span> columns = <span class="built_in">parseInt</span>(width / (itemWidth + gap));</span><br><span class="line">  <span class="comment">/**定义一个空数组,用来储存每列元素的高度 */</span></span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; items.length; i++) &#123;</span><br><span class="line">    <span class="comment">/**1.将第一行元素的高度都存到arr中 */</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; columns) &#123;</span><br><span class="line">      items[i].style.top = <span class="number">0</span>;</span><br><span class="line">      items[i].style.left = (itemWidth + gap) * i + <span class="string">'px'</span>;</span><br><span class="line">      arr.push(items[i].offsetHeight);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/**2.找到每一行的最小高度 */</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> minHeight = arr[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (minHeight &gt; arr[j]) &#123;</span><br><span class="line">          minHeight = arr[j];<span class="comment">//获得当前行最小高度</span></span><br><span class="line">          index = j;          <span class="comment">//记下当前列下标</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/**3.设置下一行第一个盒子的位置,</span></span><br><span class="line"><span class="comment">           * top值就是最小高度值+gap</span></span><br><span class="line"><span class="comment">           * left值就是最小列距离左边的距离</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">      <span class="keyword">if</span>(gap!=<span class="number">0</span>)&#123;</span><br><span class="line">        items[i].style.top = arr[index] + gap + <span class="string">'px'</span>;</span><br><span class="line">        items[i].style.left = items[index].offsetLeft + <span class="string">'px'</span>;</span><br><span class="line">        <span class="comment">/**4.修改最小列的高度 </span></span><br><span class="line"><span class="comment">             * 最小列的高度 = 当前自己的高度 + 拼接过来的高度 + 间隙的高度</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        arr[index] = arr[index] + items[i].offsetHeight + gap;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        items[i].style.top = arr[index] + oneGap + <span class="string">'px'</span>;</span><br><span class="line">        items[i].style.left = <span class="number">0</span>;</span><br><span class="line">        arr[index] = arr[index] + items[i].offsetHeight + oneGap;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="js" scheme="http://blog.haohome.top/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>利用H5画随机色圆</title>
    <link href="http://blog.haohome.top/2018/03/06/HTML5/%E5%88%A9%E7%94%A8H5%E7%94%BB%E9%9A%8F%E6%9C%BA%E8%89%B2%E5%9C%86/"/>
    <id>http://blog.haohome.top/2018/03/06/HTML5/利用H5画随机色圆/</id>
    <published>2018-03-06T14:42:54.000Z</published>
    <updated>2018-04-10T05:53:46.725Z</updated>
    
    <content type="html"><![CDATA[<p>忽然想到曾经遇到的一个案例：</p><p>​    <strong>在页面上绘制随机数量的圆并填充随机色，但鼠标点击圆时该圆逐渐放大，同时透明度降低，直至消失。</strong></p><p>在这里用代码重现下，首先分析下需求：</p><ul><li>绘制页面：<ul><li>生成随机数，根据随机数生成随机颜色</li><li>利用svg绘图技术在页面绘制随机数量的圆</li><li>将圆填充随机色</li></ul></li><li><p>JS事件：</p><ul><li><p>为每个圆绑定单击事件</p></li><li><p>创建定时器</p></li></ul></li></ul><a id="more"></a><p>代码：</p><ol><li>生成随机数和随机颜色方法</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*获取指定范围内的随机数字*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomNum</span>(<span class="params">min,max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n=<span class="built_in">Math</span>.random()*(max-min)+min;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.floor(n)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*生成随机色*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">randomColor</span>(<span class="params">min,max</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> r=randomNum(min,max);</span><br><span class="line">    <span class="keyword">var</span> g=randomNum(min,max);</span><br><span class="line">    <span class="keyword">var</span> b=randomNum(min,max);</span><br><span class="line">    <span class="keyword">var</span> a=<span class="built_in">Math</span>.random();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`rgba(<span class="subst">$&#123;r&#125;</span>,<span class="subst">$&#123;g&#125;</span>,<span class="subst">$&#123;b&#125;</span>,<span class="subst">$&#123;a&#125;</span>)`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>利用svg绘图</li></ol><p>html:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">id</span>=<span class="string">"svg"</span> <span class="attr">width</span>=<span class="string">"1000px"</span>  <span class="attr">height</span>=<span class="string">"500px"</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> svg=<span class="built_in">document</span>.getElementById(<span class="string">"svg"</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">50</span>;i++)&#123;</span><br><span class="line">    <span class="comment">//创建圆元素</span></span><br><span class="line"><span class="keyword">var</span> c=<span class="built_in">document</span>.createElementNS(<span class="string">"http://www.w3.org/2000/svg"</span>,<span class="string">"circle"</span>);</span><br><span class="line">    c.setAttribute(<span class="string">"r"</span>,randomNum(<span class="number">10</span>,<span class="number">80</span>));</span><br><span class="line">    c.setAttribute(<span class="string">"cx"</span>,randomNum(<span class="number">0</span>,<span class="number">800</span>));</span><br><span class="line">    c.setAttribute(<span class="string">"cy"</span>,randomNum(<span class="number">0</span>,<span class="number">400</span>));</span><br><span class="line">    c.setAttribute(<span class="string">"fill"</span>,randomColor(<span class="number">0</span>,<span class="number">255</span>));</span><br><span class="line">    c.setAttribute(<span class="string">"fill-opacity"</span>,<span class="built_in">Math</span>.random());</span><br><span class="line">    svg.appendChild(c)</span><br><span class="line">  <span class="comment">//绑定单击事件</span></span><br><span class="line">  c.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that=<span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">//设置循环定时器</span></span><br><span class="line">    <span class="keyword">var</span> timer=setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">var</span> r=that.getAttribute(<span class="string">"r"</span>);</span><br><span class="line">      r*=<span class="number">1.05</span>;</span><br><span class="line">      that.setAttribute(<span class="string">"r"</span>,r);</span><br><span class="line">      <span class="keyword">var</span> fillOpac=that.getAttribute(<span class="string">"fill-opacity"</span>);</span><br><span class="line">      fillOpac*=<span class="number">0.9</span>;</span><br><span class="line">      that.setAttribute(<span class="string">"fill-opacity"</span>,fillOpac);</span><br><span class="line">      <span class="comment">//设置循环定时器停止条件</span></span><br><span class="line">      <span class="keyword">if</span>(fillOpac&lt;<span class="number">0.001</span>)&#123;</span><br><span class="line">      clearInterval(timer);</span><br><span class="line">        timer=<span class="literal">null</span>;</span><br><span class="line">       svg.removeChild(that);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,<span class="number">20</span>)()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上<a href="https://codepen.io/hfood/full/gvVovo/" target="_blank" rel="noopener">codePen链接</a></p><p>效果图:</p><p><img src="https://haohome.top/18-3-8/79565300.jpg" width="80%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;忽然想到曾经遇到的一个案例：&lt;/p&gt;
&lt;p&gt;​    &lt;strong&gt;在页面上绘制随机数量的圆并填充随机色，但鼠标点击圆时该圆逐渐放大，同时透明度降低，直至消失。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这里用代码重现下，首先分析下需求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;绘制页面：&lt;ul&gt;
&lt;li&gt;生成随机数，根据随机数生成随机颜色&lt;/li&gt;
&lt;li&gt;利用svg绘图技术在页面绘制随机数量的圆&lt;/li&gt;
&lt;li&gt;将圆填充随机色&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JS事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;为每个圆绑定单击事件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;创建定时器&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="HTML5" scheme="http://blog.haohome.top/categories/HTML5/"/>
    
    
      <category term="HTML5" scheme="http://blog.haohome.top/tags/HTML5/"/>
    
      <category term="css3" scheme="http://blog.haohome.top/tags/css3/"/>
    
  </entry>
  
  <entry>
    <title>一道简单的setTimeout面试题</title>
    <link href="http://blog.haohome.top/2018/03/05/Web/%E4%B8%80%E9%81%93%E7%AE%80%E5%8D%95%E7%9A%84JavaScript%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://blog.haohome.top/2018/03/05/Web/一道简单的JavaScript面试题/</id>
    <published>2018-03-05T15:48:00.000Z</published>
    <updated>2018-04-10T05:53:47.029Z</updated>
    
    <content type="html"><![CDATA[<p>这是一道很入门的js面试题，考察JavaScript的单线程事件执行机制:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)<span class="comment">//10*10</span></span><br><span class="line">  &#125;, <span class="number">10</span> * i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不理解原因的可能会认为输出0,1,2,3,4,5,6,7,8,9。事实并不是这样，原因很简单：</p><p>先看下JavaScript的单线程和异步：</p><p><img src="https://haohome.top/18-3-5/89406852.jpg" width="80%"></p><blockquote><ul><li>JS是单线程语言，浏览器只分配给JS一个主线程用来执行任务（函数）；</li><li>任务一次只能一次，任务会形成队列排队执行；</li><li>浏览器会为setTimeout（定时器，异步）单独开一个线程，异步任务完成后会触发回调函数，这时就把回调函数放到主线程任务队列等待执行</li></ul></blockquote><a id="more"></a><p>具体到例子：</p><ul><li>js没有块级作用域，for循环中i提升为全局变量；</li><li>setTimeout是异步执行，而for循环为同步执行，每执行一次for循环，setTimeout执行一次，触发一次回调函数；</li><li>for循环已经执行完时setTimeout内部回调函数开始，i值为10，故最后连续输出10个10</li></ul><p>如果需要输出连续数字，则需要采用闭包或ES6语法中的let</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 闭包</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(j)</span><br><span class="line">    &#125;, <span class="number">10</span> * j)</span><br><span class="line">  &#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;  i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)</span><br><span class="line">  &#125;, <span class="number">10</span> * i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包：</p><ul><li>JavaScript的函数会形成作用域，闭包就是记住变量不受污染</li><li>i作为参数传入匿名函数被记住</li></ul><p>let：</p><ul><li>在{  }内形成块级作用域；</li><li>生成不同的i实例，形成一个匿名函数自调，类似于闭包</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一道很入门的js面试题，考察JavaScript的单线程事件执行机制:&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;; i++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  setTimeout(&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(i)	&lt;span class=&quot;comment&quot;&gt;//10*10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;, &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; * i)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;不理解原因的可能会认为输出0,1,2,3,4,5,6,7,8,9。事实并不是这样，原因很简单：&lt;/p&gt;
&lt;p&gt;先看下JavaScript的单线程和异步：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haohome.top/18-3-5/89406852.jpg&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;JS是单线程语言，浏览器只分配给JS一个主线程用来执行任务（函数）；&lt;/li&gt;
&lt;li&gt;任务一次只能一次，任务会形成队列排队执行；&lt;/li&gt;
&lt;li&gt;浏览器会为setTimeout（定时器，异步）单独开一个线程，异步任务完成后会触发回调函数，这时就把回调函数放到主线程任务队列等待执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="web" scheme="http://blog.haohome.top/categories/web/"/>
    
    
      <category term="面试" scheme="http://blog.haohome.top/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="events" scheme="http://blog.haohome.top/tags/events/"/>
    
  </entry>
  
  <entry>
    <title>闭包与模块</title>
    <link href="http://blog.haohome.top/2018/03/01/JavaScript/%E9%97%AD%E5%8C%85%E4%B8%8E%E6%A8%A1%E5%9D%97/"/>
    <id>http://blog.haohome.top/2018/03/01/JavaScript/闭包与模块/</id>
    <published>2018-03-01T03:30:00.000Z</published>
    <updated>2018-04-06T18:25:12.235Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是闭包"><a href="#什么是闭包" class="headerlink" title="什么是闭包"></a>什么是闭包</h2><p>闭包是有重用机制，同时保护变量不被污染的一种机制</p><table><thead><tr><th style="text-align:center">变量类型</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">全局变量</td><td style="text-align:center">可重用</td><td style="text-align:center">污染/随处可用</td></tr><tr><td style="text-align:center">局部变量</td><td style="text-align:center">仅作用域内部可用,不会污染不可重用全局</td><td style="text-align:center">不可重用</td></tr></tbody></table><blockquote><p>闭包在需要重用一个变量，又需要保护变量不被污染的情况时使用</p><p><strong>即使函数已经完成了运行，它依然可以“记住”并持续访问函数的作用域。</strong></p></blockquote><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;<span class="comment">// 参数x是一个内部变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">y</span>) </span>&#123;<span class="comment">// 内部函数add()使用x，所以它对x拥有一个“闭包”</span></span><br><span class="line"><span class="keyword">return</span> y + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> add;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用<code>makeAdder(...)</code> 所对应的<code>add(...)</code> 函数引用都会记住被传入<code>makeAdder()</code> 的参数<code>X</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plusOne = makeAdder( <span class="number">1</span> ); <span class="comment">//plusOne得到一个指向内部函数add(..)的引用,add()函数拥有对外部makeAdder(..)的参数x的闭包,相当于add()中x=2</span></span><br><span class="line"><span class="keyword">var</span> plusTen = makeAdder( <span class="number">10</span> );<span class="comment">//相当于add()中x=10</span></span><br><span class="line">plusOne( <span class="number">3</span> );<span class="comment">//调用add()方法,y=3,返回值为4</span></span><br><span class="line">plusOne( <span class="number">41</span> );<span class="comment">//调用add()方法,y=41,返回值为42</span></span><br><span class="line">plusTen( <span class="number">13</span> );<span class="comment">//x=10,调用add()方法,y=13,返回值为23</span></span><br></pre></td></tr></table></figure><p> 这段代码的工作机制:</p><blockquote><ul><li>当调用makeAdder(1)时,会得到返回的内部函数add(),该函数引用了<strong>参数x</strong>为1并记住了1;</li><li>将调用返回的函数引用为plusOne;</li><li>当调用plusOne(3)时,它会在传入参数y为3的基础上加上记住的x为1，结果为4；</li></ul></blockquote><p>实现闭包的三个步骤：</p><ol><li>用外层函数包裹要保护的变量和操作变量的函数</li><li>外层函数将内层函数的对象返回到外部</li><li>使用者调用外层函数,获得内层函数对象</li></ol><p><strong>闭包形成原因：外层函数的作用域对象(AO)无法释放,被内层函数对象引用着</strong></p><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>模块是闭包中最常见的用法，模块让你定义对外面世界不可见的私有实现细节（变量，函数），和暴露给外面可访问的公有API。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">User</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> username, password;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doLogin</span>(<span class="params">user,pw</span>) </span>&#123;<span class="comment">//登录的方法</span></span><br><span class="line">username = user;</span><br><span class="line">password = pw;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> publicAPI = &#123;<span class="comment">//需要暴露给外面的API</span></span><br><span class="line">login: doLogin</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">return</span> publicAPI;<span class="comment">//将API暴露出来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fred = User();<span class="comment">// 创建一个 `User` 模块的实例</span></span><br><span class="line">fred.login( <span class="string">"fred"</span>, <span class="string">"12Battery34!"</span> );</span><br></pre></td></tr></table></figure><p>工作机制:</p><blockquote><ul><li>接口 <code>publicAPI</code>是一个带有一个属性/方法的对象，<code>login</code>是一个指向内部<code>doLogin()</code>函数的引用</li><li>方法<code>User()</code> 内部包含两个局部作用域变量username和password，私有的doLogin()方法接受从API传入的两个参数值,并赋值给相应的username和password</li><li>执行<code>User()</code>创建了<code>User</code>模块的一个 <em>实例</em> —— 一个全新的作用域会被创建，而每个内部变量/函数因此被创建新的副本。将这个实例赋值给<code>fred</code> 如果再次运行<code>User()</code> ，将会得到一个与fred完全分离的新实例；</li><li>当<code>User()</code> 函数执行完，<code>username</code> 和<code>password</code> 这样的内部变量不会消失，因为<code>login()</code> 函数里有一个闭包保护变量</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是闭包&quot;&gt;&lt;a href=&quot;#什么是闭包&quot; class=&quot;headerlink&quot; title=&quot;什么是闭包&quot;&gt;&lt;/a&gt;什么是闭包&lt;/h2&gt;&lt;p&gt;闭包是有重用机制，同时保护变量不被污染的一种机制&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;变量类型&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;优点&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;缺点&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;全局变量&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;可重用&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;污染/随处可用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;局部变量&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;仅作用域内部可用,不会污染不可重用全局&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;不可重用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;闭包在需要重用一个变量，又需要保护变量不被污染的情况时使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即使函数已经完成了运行，它依然可以“记住”并持续访问函数的作用域。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="js" scheme="http://blog.haohome.top/tags/js/"/>
    
      <category term="function" scheme="http://blog.haohome.top/tags/function/"/>
    
  </entry>
  
  <entry>
    <title>flex弹性布局</title>
    <link href="http://blog.haohome.top/2018/02/25/CSS/Flex%E5%B8%83%E5%B1%80/"/>
    <id>http://blog.haohome.top/2018/02/25/CSS/Flex布局/</id>
    <published>2018-02-25T12:30:54.000Z</published>
    <updated>2018-04-10T05:53:46.853Z</updated>
    
    <content type="html"><![CDATA[<h2 id="flex布局是什么"><a href="#flex布局是什么" class="headerlink" title="flex布局是什么"></a>flex布局是什么</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><blockquote><p>任何一个容器都可以指定为flex布局,包括行内元素</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p></blockquote><p>设为 Flex 布局以后，子元素的<code>float</code>、<code>clear</code>和<code>vertical-align</code>属性将失效。</p><a id="more"></a><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p><img src="https://haohome.top/18-2-25/20821183.jpg" alt=""></p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><blockquote><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p></blockquote><h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><p>有六个属性设置在容器上:</p><ul><li><p>flex-direction</p></li><li><p>flex-wrap</p></li><li><p>flex-flow  :  flex-direction和flex-wrap的简写  <code>.box {  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;}</code></p><p>默认值为<code>row nowrap</code></p></li><li><p>justify-content</p></li><li><p>align-items</p></li><li><p>align-content</p></li></ul><h3 id="1-flex-direction属性"><a href="#1-flex-direction属性" class="headerlink" title="1. flex-direction属性"></a>1. flex-direction属性</h3><p><code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。</p><blockquote><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://haohome.top/18-2-25/16870590.jpg" style="width:70%"></p><h3 id="2-flex-wrap属性"><a href="#2-flex-wrap属性" class="headerlink" title="2. flex-wrap属性"></a>2. flex-wrap属性</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><blockquote><ul><li><code>nowrap</code>（默认）：不换行。</li><li><code>wrap</code>：换行，第一行在上方。</li><li><code>wrap-reverse</code>：换行，第一行在下方。</li></ul></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>nowrap</li></ul><p><img src="https://haohome.top/18-2-25/51964219.jpg" style="width:70%"></p><ul><li>wrap</li></ul><p><img src="https://haohome.top/18-2-25/51329599.jpg" style="width:70%"></p><ul><li>wrap-reverse</li></ul><p><img src="https://haohome.top/18-2-25/48930655.jpg" style="width:70%"></p><h3 id="3-justify-content属性"><a href="#3-justify-content属性" class="headerlink" title="3. justify-content属性"></a>3. justify-content属性</h3><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。</p><p>可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p><blockquote><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://haohome.top/18-2-25/54601068.jpg" style="width:50%"></p><h3 id="4-align-items属性"><a href="#4-align-items属性" class="headerlink" title="4. align-items属性"></a>4. align-items属性</h3><p><code>align-items</code>属性定义项目在交叉轴上对齐方式。</p><p>可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。</p><blockquote><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li></ul></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://haohome.top/18-2-25/33824725.jpg" style="width:50%"></p><h3 id="5-align-content属性"><a href="#5-align-content属性" class="headerlink" title="5. align-content属性"></a>5. align-content属性</h3><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><p>可能取6个值:</p><blockquote><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-class">.box</span> &#123;</span><br><span class="line">&gt;   align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://haohome.top/18-2-25/45463771.jpg" style="width:50%"></p><h2 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h2><p>6个属性设置在项目上(子元素);</p><blockquote><ul><li><p><code>order</code></p></li><li><p><code>flex-grow</code></p></li><li><p><code>flex-shrink</code></p></li><li><p><code>flex-basis</code></p></li><li><p><code>flex</code>: 是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><p><code>flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]</code></p><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><blockquote><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p></blockquote></li><li><p><code>align-self</code></p></li></ul></blockquote><h3 id="1-order属性"><a href="#1-order属性" class="headerlink" title="1. order属性"></a>1. order属性</h3><p><code>order</code>属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://haohome.top/18-2-25/98462050.jpg" style="width:50%"></p><h3 id="2-flex-grow属性"><a href="#2-flex-grow属性" class="headerlink" title="2. flex-grow属性"></a>2. flex-grow属性</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line"><span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://haohome.top/18-2-25/98462050.jpg" style="width:50%"></p><p>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h3 id="3-flex-shrink属性"><a href="#3-flex-shrink属性" class="headerlink" title="3. flex-shrink属性"></a>3. flex-shrink属性</h3><p><code>flex-shrink</code>属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://haohome.top/18-2-25/17444861.jpg" style="width:70%"></p><h3 id="4-flex-basis属性"><a href="#4-flex-basis属性" class="headerlink" title="4. flex-basis属性"></a>4. flex-basis属性</h3><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即<strong>项目的本身大小</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  flex-basis: <span class="xml"><span class="tag">&lt;<span class="name">length</span>&gt;</span> | auto; /* default auto */</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><p>它也可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如350px），则项目将占据固定空间。</p><h3 id="5-align-self属性"><a href="#5-align-self属性" class="headerlink" title="5. align-self属性"></a>5. align-self属性</h3><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">  <span class="comment">/*除了auto，其他都与align-items属性完全一致*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://haohome.top/18-2-25/33003949.jpg" style="width:50%"></p><h2 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h2><p><a href="https://codepen.io/hfood/pen/MQqMev" target="_blank" rel="noopener">骰子</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;flex布局是什么&quot;&gt;&lt;a href=&quot;#flex布局是什么&quot; class=&quot;headerlink&quot; title=&quot;flex布局是什么&quot;&gt;&lt;/a&gt;flex布局是什么&lt;/h2&gt;&lt;p&gt;Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;任何一个容器都可以指定为flex布局,包括行内元素&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.box&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: flex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.box&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: inline-flex;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;Webkit 内核的浏览器，必须加上&lt;code&gt;-webkit&lt;/code&gt;前缀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;设为 Flex 布局以后，子元素的&lt;code&gt;float&lt;/code&gt;、&lt;code&gt;clear&lt;/code&gt;和&lt;code&gt;vertical-align&lt;/code&gt;属性将失效。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://blog.haohome.top/categories/CSS/"/>
    
    
      <category term="css" scheme="http://blog.haohome.top/tags/css/"/>
    
      <category term="flex" scheme="http://blog.haohome.top/tags/flex/"/>
    
  </entry>
  
  <entry>
    <title>JS数组以及对象的深拷贝</title>
    <link href="http://blog.haohome.top/2018/02/22/JavaScript/javascript%20%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://blog.haohome.top/2018/02/22/JavaScript/javascript 数组以及对象的深拷贝/</id>
    <published>2018-02-21T16:00:00.000Z</published>
    <updated>2018-04-10T08:27:10.149Z</updated>
    
    <content type="html"><![CDATA[<p>转载自 csdn博客 <strong>FengCms FungLeo</strong>  博客:<a href="http://blog.csdn.net/fungleo/article/details/54931379" target="_blank" rel="noopener">原文链接</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在js中，数组和对象的复制如果使用<code>=</code>号来进行复制，那只是浅拷贝。如下图演示：<br><img src="https://haohome.top/18-4-10/66887533.jpg" alt="img"><br>如上，<code>arr</code>的修改，会影响<code>arr2</code>的值，这显然在绝大多数情况下，并不是我们所需要的结果。<br>因此，数组以及对象的深拷贝就是<code>javascript</code>的一个基本功了。</p><h2 id="数组的深拷贝"><a href="#数组的深拷贝" class="headerlink" title="数组的深拷贝"></a>数组的深拷贝</h2><p>条条大道通罗马，实现数组的深拷贝，是有好几种方法的。举例如下：<br><a id="more"></a></p><h3 id="for-循环实现数组的深拷贝"><a href="#for-循环实现数组的深拷贝" class="headerlink" title="for 循环实现数组的深拷贝"></a>for 循环实现数组的深拷贝</h3><p>for循环是非常好用的。如果不知道高级方法，通过for循环能够完成我们大多数的需求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = copyArr(arr)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> res = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">     res.push(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上，通过对数组的for循环，即可实现对数组的深拷贝了。</p><h3 id="slice-方法实现数组的深拷贝"><a href="#slice-方法实现数组的深拷贝" class="headerlink" title="slice 方法实现数组的深拷贝"></a>slice 方法实现数组的深拷贝</h3><p>这个代码实现非常简单。原理也比较好理解，他是将原数组中抽离部分出来形成一个新数组。我们只要设置为抽离全部，即可完成数组的深拷贝。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.slice(<span class="number">0</span>)</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arr2)</span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="http://ww4.sinaimg.cn/large/0060lm7Tgy1fcj8i9uye5j305n03rmx8.jpg" alt="img"><br>更多 <code>slice</code> 内容请访问 <a href="http://www.w3school.com.cn/jsref/jsref_slice_array.asp" target="_blank" rel="noopener">w3school JavaScript slice 方法 </a></p><h3 id="concat-方法实现数组的深拷贝"><a href="#concat-方法实现数组的深拷贝" class="headerlink" title="concat 方法实现数组的深拷贝"></a>concat 方法实现数组的深拷贝</h3><p>这个代码也非常简单，原理更加粗暴。它是用于连接多个数组组成一个新的数组的方法。那么，我们只要连接它自己，即可完成数组的深拷贝。代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = arr.concat()</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arr2)<span class="comment">//12345</span></span><br></pre></td></tr></table></figure><p>运行结果如下：<br><img src="http://ww1.sinaimg.cn/large/0060lm7Tgy1fcj8mi1kvtj305g043t8s.jpg" alt="img"><br>更多 <code>concat</code> 内容请访问 <a href="http://www.w3school.com.cn/jsref/jsref_concat_array.asp" target="_blank" rel="noopener">w3school JavaScript concat 方法 </a></p><h3 id="2017年10月31日补充：ES6扩展运算符实现数组的深拷贝"><a href="#2017年10月31日补充：ES6扩展运算符实现数组的深拷贝" class="headerlink" title="2017年10月31日补充：ES6扩展运算符实现数组的深拷贝"></a>2017年10月31日补充：ES6扩展运算符实现数组的深拷贝</h3><p>OK，以上之前讲的方法全部过时了，用下面的方法实现数组的深拷贝是最简单的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">var</span> [ ...arr2 ] = arr</span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"><span class="built_in">console</span>.log(arr2)<span class="number">12345</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://img.blog.csdn.net/20171031142723093?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRnVuZ0xlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="ES6扩展运算符实现数组的深拷贝"></p><h2 id="对象的深拷贝"><a href="#对象的深拷贝" class="headerlink" title="对象的深拷贝"></a>对象的深拷贝</h2><p>对象的深拷贝相比数组也没有困难许多，列举两个方法。</p><h3 id="万能的for循环实现对象的深拷贝"><a href="#万能的for循环实现对象的深拷贝" class="headerlink" title="万能的for循环实现对象的深拷贝"></a>万能的for循环实现对象的深拷贝</h3><p>在很多时候，for循环能够解决大问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'FungLeo'</span>,</span><br><span class="line">  sex: <span class="string">'man'</span>,</span><br><span class="line">  old: <span class="string">'18'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = copyObj(obj)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> res = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    res[key] = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转换成json再转换成对象实现对象的深拷贝"><a href="#转换成json再转换成对象实现对象的深拷贝" class="headerlink" title="转换成json再转换成对象实现对象的深拷贝"></a>转换成json再转换成对象实现对象的深拷贝</h3><p>上面的代码实在是比较长，所以，用一个更暴力的方法吧！代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'FungLeo'</span>,</span><br><span class="line">  sex: <span class="string">'man'</span>,</span><br><span class="line">  old: <span class="string">'18'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure><p>这个原理没什么好解释的，实在是够简单粗暴的啦！</p><h3 id="2017年10月31日补充：-扩展运算符实现对象的深拷贝"><a href="#2017年10月31日补充：-扩展运算符实现对象的深拷贝" class="headerlink" title="2017年10月31日补充： 扩展运算符实现对象的深拷贝"></a>2017年10月31日补充： 扩展运算符实现对象的深拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  name: <span class="string">'FungLeo'</span>,</span><br><span class="line">  sex: <span class="string">'man'</span>,</span><br><span class="line">  old: <span class="string">'18'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; ...obj2 &#125; = obj</span><br><span class="line">obj.old = <span class="string">'22'</span></span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br><span class="line"><span class="built_in">console</span>.log(obj2)</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://img.blog.csdn.net/20171031143034799?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvRnVuZ0xlbw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="扩展运算符实现对象的深拷贝"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>数组和对象的深拷贝是js中最常见的应用。理解各种方法是必须的。希望对大家有所帮助。<br>本文中并没有对异常进行处理，主要在讲原理。更多的数组以及对象的操作方法，可以参考<code>lodash</code>的源码，查看它的源码可以让你的js基础变得非常牢固。我也在学习中。</p><blockquote><p>2017年10月31日补充，使用es6提供的扩展运算符的方法实现深拷贝，简单，高效。并且，对象的深拷贝不会像使用 <code>JSON</code> 方法深拷贝一样，丢失函数等信息，只能用来深拷贝 <code>JSON</code> 数据格式的对象。推荐大家使用。</p></blockquote><h3 id="补充一个数组去重的方法"><a href="#补充一个数组去重的方法" class="headerlink" title="补充一个数组去重的方法"></a>补充一个数组去重的方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [...new <span class="built_in">Set</span>(array)]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(dedupe(arr))<span class="comment">//[1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自 csdn博客 &lt;strong&gt;FengCms FungLeo&lt;/strong&gt;  博客:&lt;a href=&quot;http://blog.csdn.net/fungleo/article/details/54931379&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在js中，数组和对象的复制如果使用&lt;code&gt;=&lt;/code&gt;号来进行复制，那只是浅拷贝。如下图演示：&lt;br&gt;&lt;img src=&quot;https://haohome.top/18-4-10/66887533.jpg&quot; alt=&quot;img&quot;&gt;&lt;br&gt;如上，&lt;code&gt;arr&lt;/code&gt;的修改，会影响&lt;code&gt;arr2&lt;/code&gt;的值，这显然在绝大多数情况下，并不是我们所需要的结果。&lt;br&gt;因此，数组以及对象的深拷贝就是&lt;code&gt;javascript&lt;/code&gt;的一个基本功了。&lt;/p&gt;
&lt;h2 id=&quot;数组的深拷贝&quot;&gt;&lt;a href=&quot;#数组的深拷贝&quot; class=&quot;headerlink&quot; title=&quot;数组的深拷贝&quot;&gt;&lt;/a&gt;数组的深拷贝&lt;/h2&gt;&lt;p&gt;条条大道通罗马，实现数组的深拷贝，是有好几种方法的。举例如下：&lt;br&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="js" scheme="http://blog.haohome.top/tags/js/"/>
    
      <category term="数组" scheme="http://blog.haohome.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Viewport剖析</title>
    <link href="http://blog.haohome.top/2018/02/20/CSS/viewports%E5%89%96%E6%9E%90/"/>
    <id>http://blog.haohome.top/2018/02/20/CSS/viewports剖析/</id>
    <published>2018-02-20T08:00:00.000Z</published>
    <updated>2018-04-10T05:53:46.941Z</updated>
    
    <content type="html"><![CDATA[<p>转载自W3CPlus创始人 <strong>大漠</strong>  博客:<a href="https://www.w3cplus.com/css/viewports.html" target="_blank" rel="noopener">原文链接</a></p><h2 id="1-桌面（pc）浏览器"><a href="#1-桌面（pc）浏览器" class="headerlink" title="1. 桌面（pc）浏览器"></a>1. 桌面（pc）浏览器</h2><h3 id="1-1-设备的pixels和CSS的pixels"><a href="#1-1-设备的pixels和CSS的pixels" class="headerlink" title="1.1 设备的pixels和CSS的pixels"></a>1.1 设备的pixels和CSS的pixels</h3><p>pixels决定了你工作所用的那些设备上正式的分辨率。在大多数情况下，能够从screen.width/height上取出具体值</p><p>如果用户缩放（zoom）了浏览器，当然必须改变计算方式。</p><p>现代浏览器上的缩放，是基于“伸展”pixels。结果是，html元素上的宽度并没有因为缩放200%而由128pix变成256px，而是真实的pixels的被计算成了双倍。html元素在形式上依然是128CSS的pixels，即便它占用了256设备的pixels 。</p><a id="more"></a><ul><li>有4个1像素，缩放为100%的html元素，CSS的pixels完整的和设备的pixels重叠:</li></ul><p><img src="https://haohome.top/18-2-20/75842280.jpg" alt=""></p><ul><li>当我们缩小浏览器时，CSS的pixels开始收缩，导致1单位的设备的pixels上重叠了多个CSS的pixels</li></ul><p><img src="https://haohome.top/18-2-20/45453120.jpg" alt=""></p><ul><li>同理，放大浏览器时，相反的事情发生了，CSS的pixels开始扩大，导致1单位的CSS的pixels上重叠了多个设备的pixels</li></ul><p><img src="https://haohome.top/18-2-20/30776207.jpg" alt=""></p><blockquote><p>你只需要关注CSS的pixels，这些pixels指定你的样式被如何渲染.</p></blockquote><h3 id="1-2-100-缩放"><a href="#1-2-100-缩放" class="headerlink" title="1.2 100% 缩放"></a>1.2 100% 缩放</h3><p>在缩放级别为100%时，1单位的CSS的pixel是严格相等于1单位的设备pixel，通常会在100%缩放级别下测试网站</p><h4 id="1-2-1-屏幕尺寸-Screen-size"><a href="#1-2-1-屏幕尺寸-Screen-size" class="headerlink" title="1.2.1 屏幕尺寸 Screen size"></a>1.2.1 屏幕尺寸 Screen size</h4><blockquote><p>含义：用户的屏幕的完整大小。这两个属性包含了用户屏幕的完整宽度/高度,尺寸使用设备的pixels来定义，他们的值不会因为缩放而改变(显示器的特征，而不是浏览器)</p><p>度量：设备的pixels,<strong>screen.width/height</strong>  (基本无用)</p><p>兼容性问题：IE8里，不管使用IE7模式还是IE8模式，都以CSS的pixels来度量</p></blockquote><p><img src="https://haohome.top/18-2-20/90621892.jpg" alt="img-w150"></p><h4 id="1-2-2-浏览器尺寸-Window-size"><a href="#1-2-2-浏览器尺寸-Window-size" class="headerlink" title="1.2.2 浏览器尺寸 Window size"></a>1.2.2 浏览器尺寸 Window size</h4><blockquote><p>含义：包含滚动条尺寸的浏览器完整尺寸; 想要知道的浏览器的内部尺寸。它定义了当前用户有多大区域，可供你的CSS布局占用<br>度量：CSS的pixels, <strong>window.innerWidth/Height</strong><br>兼容性问题：IE不支持，Opera用设备pixels来度量</p></blockquote><p><img src="https://haohome.top/18-2-20/38410284.jpg" alt=""></p><h4 id="1-2-3-滚动移位-Scrolling-offset"><a href="#1-2-3-滚动移位-Scrolling-offset" class="headerlink" title="1.2.3 滚动移位 Scrolling offset"></a>1.2.3 滚动移位 Scrolling offset</h4><ul><li><blockquote><p>含义：页面的移位 , 定义了页面(document)的相对于窗口原点的水平、垂直位移。因此你能够定位用户滚动了多少的滚动条距离。</p><p>度量：CSS的pixels, <strong>window.pageX/YOffset</strong></p><p>兼容性问题：pageXOffset 和 pageYOffset 在 IE 8 及之前版本的IE不支持, 使用”document.body.scrollLeft” and “document.body.scrollTop” 来取代</p></blockquote><p><img src="https://haohome.top/18-2-20/96319637.jpg" alt=""></p></li></ul><h4 id="1-2-4-视窗-viewport"><a href="#1-2-4-视窗-viewport" class="headerlink" title="1.2.4 视窗 viewport"></a>1.2.4 视窗 viewport</h4><p>viewport的功能在于控制你网站的最高块状（block）容器：<code>&lt;html&gt;</code> 元素。viewport是严格的等于浏览器的窗口,viewport不是一个HTML的概念，不能通过CSS修改它。</p><blockquote><p>举个例子~假设你定义了一个可变尺寸的布局（liquid layout），且你定义一个侧边栏的宽度为width: 10%。当你改变浏览器窗口大小时，该侧边栏会自动扩张和收缩。</p><p><strong>原理是侧边栏的宽度为它父元素宽度的10%</strong></p></blockquote><p>一个块级元素占有起父元素的100%的宽度（这里有异常情况，暂时忽略）。所以<code>&lt;body&gt;</code>的宽度就是其父元素<code>&lt;html&gt;</code>的宽度。</p><p>那么<code>&lt;html&gt;</code>元素到底有多宽？因为它的宽度恰好为浏览器的宽度。所以你的侧边栏宽度width: 10%会占用10%的浏览器宽度。所以的web开发人员都直观的知道和使用该特性了。 但是你也许不知道原理。在原理上，<code>&lt;html&gt;</code>的宽度受viewport所限制，<code>&lt;html&gt;</code>元素为viewport宽度的100%。</p><h4 id="1-2-5-页面宽度-document-width"><a href="#1-2-5-页面宽度-document-width" class="headerlink" title="1.2.5 页面宽度 document width"></a>1.2.5 页面宽度 document width</h4><ul><li><strong>度量viewport 尺寸</strong> :</li></ul><blockquote><p>含义：viewport的尺寸</p><p>度量：CSS的pixels,  <strong>document. documentElement. clientWidth/Height</strong></p><p>兼容性问题：无</p></blockquote><p>document.documentElement实际上就是·<code>&lt;html&gt;</code>元素：HTML文档的根元素，然而viewport是比<code>&lt;html&gt;</code>更高级别的元素，打个比喻，它是容纳<code>&lt;html&gt;</code>元素的元素。</p><p>document. documentElement. clientWidth/Height只会给出viewport的尺寸，而不管<code>&lt;html&gt;</code>元素尺寸如何改变</p><ul><li><strong>度量<code>&lt;html&gt;</code> 元素</strong></li></ul><blockquote><p>含义：<code>&lt;html&gt;</code>的尺寸</p><p>度量：CSS的pixels, <strong>document. documentElement. offsetWidth/Height</strong></p><p>兼容性问题：IE用这个值标示viewport的尺寸而非<code>&lt;html&gt;</code></p></blockquote><p>如果clientWidth/Height一直用以标示viewport的尺寸，我们该如何去获取<code>&lt;html&gt;</code>元素的尺寸呢？答案是：document.documentElement.offsetWidth/Height。</p><p><img src="https://haohome.top/18-2-20/47353138.jpg" style="width:50%"></p><p>这个特性对真实的让你访问块级元素<code>&lt;html&gt;</code>元素，如果你为<code>&lt;html&gt;</code>元素赋值了宽度，offsetWidth会真实的反应出来</p><p><img src="https://haohome.top/18-2-20/39845698.jpg" alt=""></p><h3 id="1-3-几种尺寸区别"><a href="#1-3-几种尺寸区别" class="headerlink" title="1.3 几种尺寸区别"></a>1.3 几种尺寸区别</h3><ul><li>window.innerWidth/Height 包含滚动条</li><li>document. documentElement. clientWidth/Height: 不包含滚动条 viewport尺寸</li><li>document. documentElement. offsetWidth：html尺寸</li></ul><h3 id="1-4-事件坐标"><a href="#1-4-事件坐标" class="headerlink" title="1.4 事件坐标"></a>1.4 事件坐标</h3><ul><li>pageX/Y：从<code>&lt;html&gt;</code>原点到事件触发点的CSS的 pixels   <strong>(使用概率:90%)</strong></li><li>clientX/Y：从viewport原点（浏览器窗口）到事件触发点的CSS的 pixels <strong>(使用概率:10%)</strong></li><li>screenX/Y：从用户显示器窗口原点到事件触发点的设备 的 pixels。<strong>(使用概率:0%)</strong></li><li>兼容性问题：IE不支持pageX/Y,IE使用CSSpixels来度量screanX/Y</li></ul><p><img src="https://haohome.top/18-2-20/56020173.jpg" style="width:50%"></p><p><img src="https://haohome.top/18-2-20/40182805.jpg" style="width:50%"></p><p><img src="https://haohome.top/18-2-20/3998183.jpg" style="width:50%"></p><h3 id="1-5-Media查询"><a href="#1-5-Media查询" class="headerlink" title="1.5 Media查询"></a>1.5 Media查询</h3><ul><li>含义：可以根据页面的特定宽度来定义特殊的CSS规则。</li><li>度量：<strong>width/height 和 device-width/device-heigh</strong></li><li>兼容性问题：IE不支持.</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.sidebar</span> &#123; <span class="attribute">width</span>: <span class="number">300px</span>; &#125; </span><br><span class="line">@<span class="keyword">media</span> all and (max-width: <span class="number">400px</span>) &#123; </span><br><span class="line">  <span class="selector-tag">div</span><span class="selector-class">.sidebar</span> &#123; <span class="attribute">width</span>: <span class="number">100px</span>; &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果宽度大于400px，那么sidebar宽度为300px。反之，sidebar宽度为100px*/</span></span><br></pre></td></tr></table></figure><blockquote><ul><li>device-width/height: 使用screen.width/height来做为的判定值。该值<strong>以设备的pixels来度量</strong></li><li>width/height: 使用documentElement.clientWidth/Height即viewport的值。该值<strong>以CSS的pixels来度量</strong></li></ul></blockquote><p><img src="https://haohome.top/18-2-20/35575919.jpg" style="width:70%"></p><h2 id="2-移动端浏览器"><a href="#2-移动端浏览器" class="headerlink" title="2. 移动端浏览器"></a>2. 移动端浏览器</h2><h3 id="2-1-一些概念"><a href="#2-1-一些概念" class="headerlink" title="2.1 一些概念"></a>2.1 一些概念</h3><h4 id="2-1-1-视窗-viewport"><a href="#2-1-1-视窗-viewport" class="headerlink" title="2.1.1 视窗 viewport"></a>2.1.1 视窗 viewport</h4><p>简单的理解，viewport是严格等于浏览器的窗口。在桌面浏览器中，viewport就是浏览器窗口的宽度高度。但在移动端设备上就有点复杂。</p><p>移动端的viewport太窄，为了能更好为CSS布局服务，所以提供了两个viewport：虚拟的viewportvisualviewport和布局的viewportlayoutviewport。</p><h4 id="2-1-2-物理像素-physical-pixel"><a href="#2-1-2-物理像素-physical-pixel" class="headerlink" title="2.1.2 物理像素(physical pixel)"></a>2.1.2 物理像素(physical pixel)</h4><p>又称为设备像素</p><ul><li><strong>设备独立像素(density-independent pixel)</strong></li></ul><p>设备独立像素也称为密度无关像素，可以认为是计算机坐标系统中的一个点，这个点代表一个可以由程序使用的虚拟像素(比如说CSS像素)，然后由相关系统转换为物理像素。</p><ul><li><strong>CSS像素</strong></li></ul><p>CSS像素是一个抽像的单位，主要使用在浏览器上，用来精确度量Web页面上的内容。一般情况之下，CSS像素称为与设备无关的像素(device-independent pixel)，简称DIPs。</p><ul><li><strong>屏幕密度</strong></li></ul><p>屏幕密度是指一个设备表面上存在的像素数量，它通常以每英寸有多少像素来计算(PPI)。</p><ul><li><strong>设备像素比(device pixel ratio)</strong></li></ul><p>设备像素比简称为<strong>dpr</strong>，其定义了物理像素和设备独立像素的对应关系。它的值可以按下面的公式计算得到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">设备像素比 ＝ 物理像素 / 设备独立像素</span><br></pre></td></tr></table></figure><p>在JavaScript中，可以通过window.devicePixelRatio获取到当前设备的dpr。</p><p>在CSS中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。</p><p>dip或dp,（device independent pixels，设备独立像素）与屏幕密度有关。dip可以用来辅助区分视网膜设备还是非视网膜设备。</p><p><img src="https://haohome.top/18-2-20/49223947.jpg" style="width:50%"></p><blockquote><p>iPhone6的设备宽度和高度为<code>375pt * 667pt</code>,可以理解为设备的独立像素；而其dpr为<code>2</code>，根据上面公式，我们可以很轻松得知其物理像素为<code>750pt * 1334pt</code>。</p></blockquote><p>在不同的屏幕上，CSS像素所呈现的物理尺寸是一致的，而不同的是CSS像素所对应的物理像素具数是不一致的。在普通屏幕下1个CSS像素对应1个物理像素，而在Retina屏幕下，1个CSS像素对应的却是4个物理像素。</p><p>在移动端时代屏幕适配除了Layout之外，还要考虑到图片的适配，因为其直接影响到页面显示质量</p><p><img src="https://haohome.top/18-2-20/89052097.jpg" style="width:100%"></p><ul><li><strong>meta标签</strong></li></ul><p>viewport的<code>meta</code>标签，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大。</p><p>在开发移动端页面，我们需要设置<code>meta</code>标签如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1, maximum-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码以显示网页的屏幕宽度定义了视窗宽度。网页的比例和最大比例被设置为100%。</p><ul><li><strong>CSS单位rem</strong></li></ul><p>在<a href="http://www.w3.org/TR/css3-values/#rem-unit" target="_blank" rel="noopener">W3C</a>规范中是这样描述<code>rem</code>的: <code>font size of the root element</code> </p><p>简单的理解，rem就是相对于根元素<code>&lt;html&gt;</code> 的font-size来做计算。</p><h3 id="2-2-适配方案"><a href="#2-2-适配方案" class="headerlink" title="2.2 适配方案"></a>2.2 适配方案</h3><p>在移动端布局，我们需要面对两个最为重要的问题：</p><ul><li>各终端下的适配问题</li><li>Retina屏的细节处理</li></ul><h4 id="2-2-1-适配终端"><a href="#2-2-1-适配终端" class="headerlink" title="2.2.1 适配终端"></a>2.2.1 适配终端</h4><p>以前的<a href="https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">Flexible方案</a>是通过JavaScript来模拟<code>vw</code>的特性，如今<code>vw</code>已经得到了众多浏览器的支持，也就是说，可以直接考虑将<code>vw</code>单位运用于我们的适配布局中。</p><p><code>vw</code> 是基于Viewport视窗的长度单位，这里的视窗（Viewport）指的就是浏览器可视化的区域，而这个可视区域是<code>window.innerWidth/window.innerHeight</code>的大小。用下图简单的来示意一下：</p><p><img src="https://haohome.top/18-2-20/13841113.jpg" style="width:100%"></p><p>在<a href="https://www.w3.org/TR/css3-values/" target="_blank" rel="noopener">CSS Values and Units Module Level 3</a>中和Viewport相关的单位有四个，分别为<code>vw</code>、<code>vh</code>、<code>vmin</code>和<code>vmax</code>。</p><ul><li><code>vw</code>：是Viewport’s width的简写,<code>1vw</code>等于<code>window.innerWidth</code>的<code>1%</code></li><li><code>vh</code>：和<code>vw</code>类似，是Viewport’s height的简写，<code>1vh</code>等于<code>window.innerHeihgt</code>的<code>1%</code></li><li><code>vmin</code>：<code>vmin</code>的值是当前<code>vw</code>和<code>vh</code>中较小的值</li><li><code>vmax</code>：<code>vmax</code>的值是当前<code>vw</code>和<code>vh</code>中较大的值</li></ul><blockquote><p><code>vmin</code>和<code>vmax</code>是根据Viewport中长度偏大的那个维度值计算出来的，如果<code>window.innerHeight &gt; window.innerWidth</code>则<code>vmin</code>取百分之一的<code>window.innerWidth</code>，<code>vmax</code>取百分之一的<code>window.innerHeight</code>计算。</p></blockquote><p><img src="https://haohome.top/18-2-20/54143700.jpg" style="width:50%"></p><p>这个方案中大胆的使用<code>vw</code>来替代以前Flexible中的<code>rem</code>缩放方案</p><p>目前出视觉设计稿，我们都是使用<code>750px</code>宽度的，从上面的原理来看，那么<code>100vw = 750px</code>，即<code>1vw = 7.5px</code>。那么我们可以根据设计图上的<code>px</code>值直接转换成对应的<code>vw</code>值。看到这里，很多同学开始感到崩溃，又要计算，能不能简便一点，能不能再简单一点，其实是可以的，我们可以使用PostCSS的插件<a href="https://github.com/evrone/postcss-px-to-viewport" target="_blank" rel="noopener">postcss-px-to-viewport</a>，让我们可以直接在代码中写<code>px</code>，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[w-369]</span>&#123; <span class="attribute">width</span>: <span class="number">369px</span>; &#125; </span><br><span class="line"><span class="selector-attr">[w-369]</span> <span class="selector-tag">h2</span> <span class="selector-tag">span</span> &#123; </span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#FF5000</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">2px</span> <span class="number">2px</span> <span class="number">#FF5000</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">5px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PostCSS编译之后就是我们所需要的带vw代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[w-369]</span> &#123; <span class="attribute">width</span>: <span class="number">49.2vw</span>; &#125; </span><br><span class="line"><span class="selector-attr">[w-369]</span> <span class="selector-tag">h2</span> <span class="selector-tag">span</span> &#123; </span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ff5000</span>; </span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>; </span><br><span class="line">  <span class="attribute">display</span>: inline-block; </span><br><span class="line">  <span class="attribute">border-radius</span>: .<span class="number">53333vw</span>; </span><br><span class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0.26667vw</span> <span class="number">0.26667vw</span> <span class="number">#ff5000</span>; </span><br><span class="line">  <span class="attribute">padding</span>: .<span class="number">26667vw</span> .<span class="number">66667vw</span>; &#125; </span><br><span class="line"><span class="selector-attr">[w-369]</span> <span class="selector-tag">h2</span> <span class="selector-tag">span</span>, </span><br><span class="line"><span class="selector-attr">[w-369]</span> <span class="selector-tag">i</span> &#123; </span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">2.66667vw</span>; </span><br><span class="line">  <span class="attribute">margin-right</span>: .<span class="number">66667vw</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际使用的时候，你可以对该插件进行相关的参数配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"postcss-px-to-viewport"</span>: &#123;</span><br><span class="line">    viewportWidth: <span class="number">750</span>,</span><br><span class="line">    viewportHeight: <span class="number">1334</span>,</span><br><span class="line">    unitPrecision: <span class="number">5</span>,</span><br><span class="line">    viewportUnit: <span class="string">'vw'</span>,</span><br><span class="line">    selectorBlackList: [],</span><br><span class="line">    minPixelValue: <span class="number">1</span>,</span><br><span class="line">    mediaQuery: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设你的设计稿不是<code>750px</code>而是<code>1125px</code>，那么你就可以修改<code>vewportWidth</code>的值。有关于该插件的详细介绍，<a href="https://github.com/evrone/postcss-px-to-viewport" target="_blank" rel="noopener">可以阅读其官方使用文档</a>。</p><p>在哪些地方可以使用<code>vw</code>来适配我们的页面。根据相关的测试：</p><ul><li>容器适配，可以使用<code>vw</code></li><li>文本的适配，可以使用<code>vw</code></li><li>大于<code>1px</code>的边框、圆角、阴影都可以使用<code>vw</code></li><li>内距和外距，可以使用<code>vw</code></li></ul><p>另外有一个细节需要特别的提出，比如我们有一个这样的设计：</p><p><img src="https://haohome.top/18-2-20/51749019.jpg" style="width:60%"></p><p>如果我们直接使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[w-188-246]</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">188px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[w-187-246]</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">187px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的效果会造成<code>[w-187-246]</code>容器的高度小于<code>[w-188-246]</code>容器的高度。这个时候我们就需要考虑到<a href="https://www.w3cplus.com/css/aspect-ratio.html" target="_blank" rel="noopener">容器的长宽比缩放</a>。这方面的方案很多，但我还是推荐工具化来处理，这里推荐@一丝 姐姐写的一个PostCSS插件<a href="https://github.com/yisibl/postcss-aspect-ratio-mini" target="_blank" rel="noopener">postcss-aspect-ratio-mini</a>。这个插件使用很简单，不需要做任何的配置，你只需要本地安装一下就OK。使用的时候如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[aspectratio]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[aspectratio]</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[aspectratio-content]</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-attr">[aspectratio]</span><span class="selector-attr">[aspect-ratio="188/246"]</span>&#123;</span><br><span class="line">    <span class="attribute">aspect-ratio</span>: <span class="string">'188:246'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译出来：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[aspectratio]</span><span class="selector-attr">[aspect-ratio="188/246"]</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">    <span class="attribute">padding-top</span>: <span class="number">130.85106382978725%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以完美的实现长宽比的效果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转载自W3CPlus创始人 &lt;strong&gt;大漠&lt;/strong&gt;  博客:&lt;a href=&quot;https://www.w3cplus.com/css/viewports.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-桌面（pc）浏览器&quot;&gt;&lt;a href=&quot;#1-桌面（pc）浏览器&quot; class=&quot;headerlink&quot; title=&quot;1. 桌面（pc）浏览器&quot;&gt;&lt;/a&gt;1. 桌面（pc）浏览器&lt;/h2&gt;&lt;h3 id=&quot;1-1-设备的pixels和CSS的pixels&quot;&gt;&lt;a href=&quot;#1-1-设备的pixels和CSS的pixels&quot; class=&quot;headerlink&quot; title=&quot;1.1 设备的pixels和CSS的pixels&quot;&gt;&lt;/a&gt;1.1 设备的pixels和CSS的pixels&lt;/h3&gt;&lt;p&gt;pixels决定了你工作所用的那些设备上正式的分辨率。在大多数情况下，能够从screen.width/height上取出具体值&lt;/p&gt;
&lt;p&gt;如果用户缩放（zoom）了浏览器，当然必须改变计算方式。&lt;/p&gt;
&lt;p&gt;现代浏览器上的缩放，是基于“伸展”pixels。结果是，html元素上的宽度并没有因为缩放200%而由128pix变成256px，而是真实的pixels的被计算成了双倍。html元素在形式上依然是128CSS的pixels，即便它占用了256设备的pixels 。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://blog.haohome.top/categories/CSS/"/>
    
    
      <category term="css" scheme="http://blog.haohome.top/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>前端网摘</title>
    <link href="http://blog.haohome.top/2018/02/20/Web/%E5%89%8D%E7%AB%AF%E7%BD%91%E6%91%98/"/>
    <id>http://blog.haohome.top/2018/02/20/Web/前端网摘/</id>
    <published>2018-02-20T07:00:00.000Z</published>
    <updated>2018-04-06T18:08:43.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-移动端网摘"><a href="#1-移动端网摘" class="headerlink" title="1. 移动端网摘"></a>1. 移动端网摘</h2><ol><li><a href="https://www.w3cplus.com/css/viewports.html" target="_blank" rel="noopener">viewports剖析</a></li><li><a href="https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">使用Flexible实现手淘H5页面的终端适配</a></li><li><a href="https://www.w3cplus.com/css/vw-for-layout.html" target="_blank" rel="noopener">再聊移动端适配</a></li><li><a href="https://www.w3cplus.com/mobile/vw-layout-in-vue.html" target="_blank" rel="noopener">如何在Vue项目中使用vw实现移动端适配</a></li><li><a href="https://material.io/devices/" target="_blank" rel="noopener">谷歌device列表</a></li><li><a href="http://www.shejidaren.com/examples/tools/chichun/ui-design-spec.html#nogo" target="_blank" rel="noopener">最新Android &amp; iOS设计尺寸规范——2015</a></li><li><a href="http://www.woshipm.com/pmd/176328.html" target="_blank" rel="noopener">px、pt、ppi、dpi、dp、sp之间的关系</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-移动端网摘&quot;&gt;&lt;a href=&quot;#1-移动端网摘&quot; class=&quot;headerlink&quot; title=&quot;1. 移动端网摘&quot;&gt;&lt;/a&gt;1. 移动端网摘&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.w3cplus.com/css/viewp
      
    
    </summary>
    
      <category term="web" scheme="http://blog.haohome.top/categories/web/"/>
    
    
      <category term="网摘" scheme="http://blog.haohome.top/tags/%E7%BD%91%E6%91%98/"/>
    
  </entry>
  
  <entry>
    <title>DOM通用事件绑定</title>
    <link href="http://blog.haohome.top/2018/02/18/JavaScript/DOM%E9%80%9A%E7%94%A8%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"/>
    <id>http://blog.haohome.top/2018/02/18/JavaScript/DOM通用事件绑定/</id>
    <published>2018-02-17T16:00:00.000Z</published>
    <updated>2018-04-10T05:53:46.974Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-认识DOM"><a href="#1-认识DOM" class="headerlink" title="1. 认识DOM"></a>1. 认识DOM</h3><p>DOM(Document Object Model),即文档对象模型,是为了<strong>以编程的方法操作HTML和XML文档内容</strong>制定的标准,主要有三种:</p><ul><li>核心 DOM - 针对任何结构化文档的标准模型</li><li>XML DOM - 针对 XML 文档的标准模型</li><li>HTML DOM - 针对 HTML 文档的标准模型</li></ul><p>这里主要认识HTML DOM</p><blockquote><p>HTML DOM: 关于如何获取、修改、添加或删除 HTML 元素的标准</p></blockquote><a id="more"></a><p>在DOM中,HTML 文档中的所有内容都是节点,通过HTML DOM,树中的所有节点均可通过Js进行增删改查(操作DOM);</p><p><img src="https://haohome.top/18-2-18/22599283.jpg" alt="节点树"></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM 教程<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>DOM 第一课<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello world!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"btn"</span>&gt;</span>点击<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.querySelector(<span class="string">"p"</span>);<span class="comment">//根据选择器标签查找DOM元素</span></span><br><span class="line"><span class="keyword">var</span> btn=<span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);<span class="comment">//根据ID查找DOM元素</span></span><br><span class="line">btn.onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="comment">//通过操作DOM事件绑定事件</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"你点击了我"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事件的绑定有一个通用的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">btn.addEventListener(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"绑定了点击事件"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="2-DOM事件绑定"><a href="#2-DOM事件绑定" class="headerlink" title="2. DOM事件绑定"></a>2. DOM事件绑定</h3><p>上面讲了两种点击事件绑定的方法，addEventListener是一个通用的事件绑定API，但单词太多，最好自己封装一个绑定方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem,type,fn</span>)</span>&#123;</span><br><span class="line">  event.addEventListener(type,fn)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//给按钮btn绑定点击事件</span></span><br><span class="line">bindEvent(btn,click,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"绑定了点击事件"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>重写的bindEvent是一个通用事件绑定,结合事件冒泡情况,可以更完善:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"div1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p1"</span>&gt;</span>激活1<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p2"</span>&gt;</span>激活2<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p3"</span>&gt;</span>激活3<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"p4"</span>&gt;</span>激活4<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>按之前的事件绑定方式,给每个p元素绑定事件,打印输出对应的innerHTML值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1=<span class="built_in">document</span>.getElementById(<span class="string">'p1'</span>);</span><br><span class="line">bindEvent(p1,<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerHTML)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> body=<span class="built_in">document</span>.body;</span><br><span class="line">bindEvent(body,<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(e.target.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>运行后发现,点击p1元素会输出两次,说明该元素绑定了两次单击事件,这是由于给p1元素绑定单击事件时冒泡到父元素div1上;</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bindEvent(p1,<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  e.stopPropagation();</span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>那么这样通用事件绑定方法就不通用,需要进行改造:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindEvent</span>(<span class="params">elem,type,selector,fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(fn==<span class="literal">null</span>)&#123;<span class="comment">//如果没有第四个参数</span></span><br><span class="line">  fn=selector;</span><br><span class="line">    selector=<span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  elem.addEventListener(type,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(selector)&#123;</span><br><span class="line">    <span class="keyword">var</span> target=e.target</span><br><span class="line">      <span class="keyword">if</span>(target.matches(selector))&#123;</span><br><span class="line">        fn.call(<span class="keyword">this</span>,e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      fn(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> div1=<span class="built_in">document</span>.getElementById(<span class="string">'div1'</span>);</span><br><span class="line">bindEvent(div1,<span class="string">'click'</span>,<span class="string">'p'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// e.stopPropagation();</span></span><br><span class="line">  <span class="built_in">console</span>.log(e.target.innerHTML)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-认识DOM&quot;&gt;&lt;a href=&quot;#1-认识DOM&quot; class=&quot;headerlink&quot; title=&quot;1. 认识DOM&quot;&gt;&lt;/a&gt;1. 认识DOM&lt;/h3&gt;&lt;p&gt;DOM(Document Object Model),即文档对象模型,是为了&lt;strong&gt;以编程的方法操作HTML和XML文档内容&lt;/strong&gt;制定的标准,主要有三种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;核心 DOM - 针对任何结构化文档的标准模型&lt;/li&gt;
&lt;li&gt;XML DOM - 针对 XML 文档的标准模型&lt;/li&gt;
&lt;li&gt;HTML DOM - 针对 HTML 文档的标准模型&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里主要认识HTML DOM&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;HTML DOM: 关于如何获取、修改、添加或删除 HTML 元素的标准&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://blog.haohome.top/categories/JavaScript/"/>
    
    
      <category term="js" scheme="http://blog.haohome.top/tags/js/"/>
    
      <category term="DOM" scheme="http://blog.haohome.top/tags/DOM/"/>
    
  </entry>
  
  <entry>
    <title>Vue的点赞效果</title>
    <link href="http://blog.haohome.top/2018/02/14/JavaScript/Vue%E7%9A%84%E7%82%B9%E8%B5%9E%E6%95%88%E6%9E%9C/"/>
    <id>http://blog.haohome.top/2018/02/14/JavaScript/Vue的点赞效果/</id>
    <published>2018-02-14T12:45:00.000Z</published>
    <updated>2018-04-10T05:53:47.240Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-原生-利用CSS3-Animation-实现"><a href="#1-原生-利用CSS3-Animation-实现" class="headerlink" title="1. 原生: 利用CSS3 Animation 实现"></a>1. 原生: 利用CSS3 Animation 实现</h3><p>animation的动画效果通常是连贯性的，简单的说就是线性渐变的动画。但有些效果不需要连贯性，只需要关键帧之间的跳跃，这时应该使用<code>steps</code> 过渡方式，称之为帧动画。</p><p>比较知名的Twitter点赞功能就是采用steps方式：</p><p>HTML</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"heart"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.heart</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(heart.png);</span><br><span class="line">  <span class="attribute">background-size</span>: auto <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">:active</span> &#123; <span class="comment">/*当鼠标点击激活时执行动画效果*/</span></span><br><span class="line">  <span class="attribute">transition</span>: background <span class="number">1s</span> <span class="built_in">steps</span>(28); </span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">140rem</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="https://haohome.top/18-2-14/71551117.jpg" alt="点赞"></p><a id="more"></a><p>transition的简写方式为:</p><p><strong>transition:</strong> property duration timing-function delay</p><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">transition-property</td><td style="text-align:center">设置过渡效果的 CSS 属性的名称。</td></tr><tr><td style="text-align:center">transition-duration</td><td style="text-align:center">完成过渡效果需要多少秒或毫秒。</td></tr><tr><td style="text-align:center">transition-timing-function</td><td style="text-align:center">速度效果的速度曲线。</td></tr><tr><td style="text-align:center">transition-delay</td><td style="text-align:center">定义过渡效果何时开始。</td></tr></tbody></table><p>上面的CSS动画效果等同于:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.heart</span><span class="selector-pseudo">:active</span>&#123;</span><br><span class="line">  <span class="attribute">animation </span>: heartBlast <span class="number">1s</span> <span class="number">1</span>;</span><br><span class="line">  <span class="attribute">animation-timing-function</span>:<span class="built_in">steps</span>(28);</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">keyframes</span> heartBlast &#123;</span><br><span class="line">  0% &#123;<span class="attribute">background-position</span>: left;&#125;</span><br><span class="line">  100% &#123;<span class="attribute">background-position</span>: right;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐帧播放红心背景图片达到实现效果</p><h3 id="2-Vue的实现方法"><a href="#2-Vue的实现方法" class="headerlink" title="2. Vue的实现方法"></a>2. Vue的实现方法</h3><p>与原生DOM不同的是,vue是一个以数据驱动的框架,可以直接在html上直接绑定相关事件或属性</p><p>template</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;i class=&quot;heart&quot; :style=&quot;star&quot; :class=&quot;&#123;hover:parseInt(item.isHover)&#125;&quot; @click=&quot;heart(item)&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;!--item是v-for循环中的某个子项,有pid/isHover/count等属性--&gt;</span><br></pre></td></tr></table></figure><blockquote><p>通过绑定设置元素背景图片,双向绑定css类hover,通过点击事件heart控制hover类显示以及点赞数量count变化</p></blockquote><p>script</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name:<span class="string">'MainBox'</span>,</span><br><span class="line">  data()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      star:&#123;</span><br><span class="line">        backgroundImage:<span class="string">'url('</span> + <span class="built_in">require</span>(<span class="string">'../../assets/img/web_heart_animation.png'</span>) + <span class="string">')'</span></span><br><span class="line">      &#125;,</span><br><span class="line">      isHover:<span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    updateCount(pid,count)&#123;</span><br><span class="line">      <span class="keyword">this</span>.$axios(&#123;</span><br><span class="line">        url:<span class="string">'/updateCarrousel.php'</span>,</span><br><span class="line">        baseURL: <span class="string">'http://www.haohome.top/yx/data'</span>,</span><br><span class="line">        methods:<span class="string">'post'</span>,</span><br><span class="line">        params:&#123;<span class="attr">pid</span>:pid,<span class="attr">count</span>:count&#125;, <span class="comment">//pid:当前id,count:当前id已点赞数量</span></span><br><span class="line">        responseType: <span class="string">'json'</span>,</span><br><span class="line">        transformResponse:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">          <span class="keyword">var</span> code=data.code;</span><br><span class="line">          <span class="keyword">if</span>(code)&#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">"点赞成功"</span>);</span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"点赞失败"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    heart(item)&#123;</span><br><span class="line">      <span class="keyword">if</span>(item.isHover==<span class="string">"0"</span>)&#123;</span><br><span class="line">        item.isHover=<span class="string">"1"</span>,<span class="comment">//点赞动画class:hover绑定</span></span><br><span class="line">        item.count++;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        item.isHover=<span class="string">"0"</span></span><br><span class="line">        item.count--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">this</span>.updateCount(item.pid,item.count)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>style</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.heart</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">background-size</span>: auto <span class="number">5rem</span>;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.heart</span><span class="selector-class">.hover</span> &#123; </span><br><span class="line">  <span class="attribute">transition</span>: background <span class="number">1s</span> <span class="built_in">steps</span>(28); </span><br><span class="line">  <span class="attribute">background-position</span>: -<span class="number">140rem</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://haohome.top/18-2-14/71807336.jpg" alt="vue点赞"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-原生-利用CSS3-Animation-实现&quot;&gt;&lt;a href=&quot;#1-原生-利用CSS3-Animation-实现&quot; class=&quot;headerlink&quot; title=&quot;1. 原生: 利用CSS3 Animation 实现&quot;&gt;&lt;/a&gt;1. 原生: 利用CSS3 Animation 实现&lt;/h3&gt;&lt;p&gt;animation的动画效果通常是连贯性的，简单的说就是线性渐变的动画。但有些效果不需要连贯性，只需要关键帧之间的跳跃，这时应该使用&lt;code&gt;steps&lt;/code&gt; 过渡方式，称之为帧动画。&lt;/p&gt;
&lt;p&gt;比较知名的Twitter点赞功能就是采用steps方式：&lt;/p&gt;
&lt;p&gt;HTML&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;class&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;heart&quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;i&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;CSS&lt;br&gt;&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.heart&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;display&lt;/span&gt;: inline-block;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;width&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5rem&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;5rem&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;background&lt;/span&gt;: &lt;span class=&quot;built_in&quot;&gt;url&lt;/span&gt;(heart.png);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;background-size&lt;/span&gt;: auto &lt;span class=&quot;number&quot;&gt;5rem&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;background-position&lt;/span&gt;: &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;selector-class&quot;&gt;.heart&lt;/span&gt;&lt;span class=&quot;selector-pseudo&quot;&gt;:active&lt;/span&gt; &amp;#123; &lt;span class=&quot;comment&quot;&gt;/*当鼠标点击激活时执行动画效果*/&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;transition&lt;/span&gt;: background &lt;span class=&quot;number&quot;&gt;1s&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;steps&lt;/span&gt;(28); &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;attribute&quot;&gt;background-position&lt;/span&gt;: -&lt;span class=&quot;number&quot;&gt;140rem&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://haohome.top/18-2-14/71551117.jpg&quot; alt=&quot;点赞&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://blog.haohome.top/categories/Framework/"/>
    
    
      <category term="css3" scheme="http://blog.haohome.top/tags/css3/"/>
    
      <category term="vue" scheme="http://blog.haohome.top/tags/vue/"/>
    
  </entry>
  
</feed>
